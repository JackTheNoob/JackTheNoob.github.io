<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">
<meta name="google-site-verification" content="H2oSN0uYOmfFvx5hCvt0zPYP4ekyAQlLKkExeaFjhrg">








<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="None">
<meta name="keywords" content="iOS,swift,react-native,javascript,微信开发,微信小程序,C,C语言,程序猿,博客,Lyddwn,码农">
<meta property="og:type" content="website">
<meta property="og:title" content="Lyddwn">
<meta property="og:url" content="http://jackthenoob.github.io/index.html">
<meta property="og:site_name" content="Lyddwn">
<meta property="og:description" content="None">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lyddwn">
<meta name="twitter:description" content="None">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://jackthenoob.github.io/">





  <title>Lyddwn</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Lyddwn</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">生活不只是代码</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            Commonweal 404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jackthenoob.github.io/2019/06/10/iPadOS新功能/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="垂杨小梳雨">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lyddwn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/10/iPadOS新功能/" itemprop="url">iPadOS新功能</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-10T11:04:30+08:00">
                2019-06-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iPad/" itemprop="url" rel="index">
                    <span itemprop="name">iPad</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="iPadOS"><a href="#iPadOS" class="headerlink" title="iPadOS"></a>iPadOS</h2><p>苹果基于iOS系统为iPad打造了全新的iPadOS系统。不仅增加了悬浮框功能，还让分屏显示功能更加便捷。极大提高了同屏浏览信息量。同时，新增了手势可以进行复制、粘贴、删除和撤销操作，提高了iPad生产力。</p>
<h3 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h3><p>可以将Widget固定在HOME页面。只需要一个向右的拖拽手势。</p>
<p><img src="/2019/06/10/iPadOS新功能/a001.png" alt></p>
<h3 id="多窗口"><a href="#多窗口" class="headerlink" title="多窗口"></a>多窗口</h3><p>iPad在iOS11就支持了多窗口。可以同时使用两个App。</p>
<p><img src="/2019/06/10/iPadOS新功能/a002.gif" alt></p>
<p>iPadOS将支持多窗口堆叠显示，比如统一应用可以开启两个窗口，然后并排显示。</p>
<p>这意味着你可以同时打开两个备忘录，或者同时打开两个Word窗口，页面与页面之间的拖拽功能也得到了优化。</p>
<p><img src="/2019/06/10/iPadOS新功能/iPadOS_mutilp_task_01.gif" alt></p>
<p>第三方App也可以： Word</p>
<p><img src="/2019/06/10/iPadOS新功能/a003.png" alt></p>
<p>更多的切换手势功能</p>
<p><img src="/2019/06/10/iPadOS新功能/iPadOS_gesture_switch.gif" alt></p>
<h3 id="与Mac交互"><a href="#与Mac交互" class="headerlink" title="与Mac交互"></a>与Mac交互</h3><p>搭配最新版MacOS Catelina，iPad可以变成Mac的外接屏幕和数位板。用户可以把电脑上打开的App直接拖拽到iPad上，并进行触控/笔触操作。</p>
<h3 id="文件功能"><a href="#文件功能" class="headerlink" title="文件功能"></a>文件功能</h3><p>原本支持的文件管理App在iPadOS上有了重大功能提升，现在加入分栏视图，支持相机和U盘导入文件。</p>
<p><img src="/2019/06/10/iPadOS新功能/a004.png" alt></p>
<p><img src="/2019/06/10/iPadOS新功能/a005.png" alt></p>
<p><img src="/2019/06/10/iPadOS新功能/a006.png" alt></p>
<h3 id="新的手势"><a href="#新的手势" class="headerlink" title="新的手势"></a>新的手势</h3><p>新增的强大的手势交互。可以直接使用三指捏合和松开的手势完成复制、粘贴，而三指滑动即可实现撤销操作。</p>
<h4 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h4><p><img src="/2019/06/10/iPadOS新功能/iPadOS_gesture_selecting.gif" alt></p>
<h4 id="复制-粘贴"><a href="#复制-粘贴" class="headerlink" title="复制|粘贴"></a>复制|粘贴</h4><p><img src="/2019/06/10/iPadOS新功能/iPadOS_gesture_copy_paste.gif" alt></p>
<h4 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h4><p><img src="/2019/06/10/iPadOS新功能/iPadOS_gesture_undo.gif" alt></p>
<h3 id="Apple-Pencil"><a href="#Apple-Pencil" class="headerlink" title="Apple Pencil"></a>Apple Pencil</h3><p>更多的第三方App可以使用苹果PencilKit API，让笔触交互更加自然和敏捷。输入延迟也从20ms降低到9ms。在任何App环境下用笔从屏幕角落向中间滑动，可以开启截图笔记模式。</p>
<h3 id="鼠标"><a href="#鼠标" class="headerlink" title="鼠标"></a>鼠标</h3><p><img src="/2019/06/10/iPadOS新功能/iPadOS_mouse_01.gif" alt></p>
<h3 id="Safari"><a href="#Safari" class="headerlink" title="Safari"></a>Safari</h3><p>Safari 桌面级的浏览器</p>
<p>支持下载管理</p>
<p>支持多达30个快捷键</p>
<p><img src="/2019/06/10/iPadOS新功能/a007.png" alt></p>
<p><img src="/2019/06/10/iPadOS新功能/a008.png" alt></p>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>下载管理你喜爱的字体，在App中使用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jackthenoob.github.io/2019/05/28/iOS-Runtime/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="垂杨小梳雨">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lyddwn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/28/iOS-Runtime/" itemprop="url">iOS Runtime</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-28T21:09:46+08:00">
                2019-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>Objective-C 扩展了 C 语言，并加入了面向对象特性和 Smalltalk 式的消息传递机制。而这个扩展的核心是一个用 C 和 编译语言 写的 Runtime 库。它是 Objective-C 面向对象和动态机制的基石。</p>
<p>Objective-C 是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。理解 Objective-C 的 Runtime 机制可以帮我们更好的了解这个语言，适当的时候还能对语言进行扩展，从系统层面解决项目中的一些设计或技术问题。了解 Runtime ，要先了解它的核心 - 消息传递 （Messaging）。</p>
</blockquote>
<p>Runtime有两个版本: “modern” 和 “legacy”。</p>
<p>我们现在用的 Objective-C 2.0采用的是现行 (Modern) 版的 Runtime系统，只能运行在 iOS和 macOS 10.5之后的 64位程序中。而 macOS较老的32位程序仍采用 Objective-C 1中的（早期）Legacy版本的 Runtime系统。这两个版本最大的区别在于当你更改一个类的实例变量的布局时，在早期版本中你需要重新编译它的子类，而现行版就不需要。</p>
<p>Runtime基本是用 C和汇编写的，可见苹果为了动态系统的高效而作出的努力。你可以在这里下到苹果维护的开源代码。苹果和GNU各自维护一个开源的 runtime版本，这两个版本之间都在努力的保持一致。</p>
<p>平时的业务中主要是使用<a href="https://developer.apple.com/documentation/objectivec/objective-c_runtime?language=objc" target="_blank" rel="noopener">官方Api</a>，解决我们框架性的需求。</p>
<p>高级编程语言想要成为可执行文件需要先编译为汇编语言再汇编为机器语言，机器语言也是计算机能够识别的唯一语言，但是OC并不能直接编译为汇编语言，而是要先转写为纯C语言再进行编译和汇编的操作，从OC到C语言的过渡就是由runtime来实现的。然而我们使用OC进行面向对象开发，而C语言更多的是面向过程开发，这就需要将面向对象的类转变为面向过程的结构体。</p>
<h2 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h2><p>调用一个对象的方法像这样</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[obj foo]</span><br></pre></td></tr></table></figure>
<p>编译器转成消息发送</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(obj, foo)</span><br></pre></td></tr></table></figure>
<p>Runtime时执行的流程是这样的：</p>
<ul>
<li>首先，通过obj的isa指针找到它的 class;</li>
<li>在 class的 method list找 foo;</li>
<li>如果 class中没到 foo，继续往它的 superclass中找 ;</li>
<li>一旦找到 foo这个函数，就去执行它的实现IMP。</li>
</ul>
<p>但这种实现有个问题，效率低。</p>
<p>因为一个class往往只有 20%的函数会被经常调用，可能占总调用次数的 80%。每个消息都需要遍历一次objc_method_list并不合理。</p>
<p>如果把经常被调用的函数缓存下来，那可以大大提高函数查询的效率。</p>
<p>这也就是objc_class中另一个重要成员objc_cache做的事情。</p>
<p>再找到foo之后，把foo的method_name作为key，method_imp作为value给存起来。当再次收到foo消息的时候，可以直接在cache里找到，避免去遍历objc_method_list。从前面的源代码可以看到objc_cache是存在objc_class结构体中的。</p>
<p>objec_msgSend的方法定义如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT id objc_msgSend(id self, SEL op, ...)</span><br></pre></td></tr></table></figure>
<p>那消息传递是怎么实现的呢？我们看看对象(object)，类(class)，方法(method)这几个的结构体：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//对象</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line">//类</span><br><span class="line">struct objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"><span class="comment">#if !__OBJC2__</span></span><br><span class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">    const char *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br><span class="line">//方法列表</span><br><span class="line">struct objc_method_list &#123;</span><br><span class="line">    struct objc_method_list *obsolete                        OBJC2_UNAVAILABLE;</span><br><span class="line">    int method_count                                         OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="comment">#ifdef __LP64__</span></span><br><span class="line">    int space                                                OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">    /* variable length structure */</span><br><span class="line">    struct objc_method method_list[1]                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br><span class="line">//方法</span><br><span class="line">struct objc_method &#123;</span><br><span class="line">    SEL method_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    char *method_types                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp                                           OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>系统首先找到消息的接收对象，然后通过对象的isa找到它的类。</li>
<li>在它的类中查找method_list，是否有selector方法。</li>
<li>没有则查找父类的method_list。</li>
<li>找到对应的method，执行它的IMP。</li>
<li>转发IMP的return值。</li>
</ol>
<p>消息传递涉及到的一些概念：</p>
<ul>
<li>类对象(objc_class)</li>
<li>实例(objc_object)</li>
<li>元类(Meta Class)</li>
<li>Method(objc_method)</li>
<li>SEL(objc_selector)</li>
<li>IMP</li>
<li>类缓存(objc_cache)</li>
<li>Category(objc_category)</li>
</ul>
<h3 id="类对象-objc-class"><a href="#类对象-objc-class" class="headerlink" title="类对象(objc_class)"></a>类对象(objc_class)</h3><p>Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure>
<p>查看objc/runtime.h中objc_class结构体的定义如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#if !__OBJC2__</span></span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</span><br><span class="line">    const char * _Nonnull name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p>struct objc_class结构体定义了很多变量，通过命名不难发现， 结构体里保存了指向父类的指针、类的名字、版本、实例大小、实例变量列表、方法列表、缓存、遵守的协议列表等， 一个类包含的信息也不就正是这些吗？没错，类对象就是一个结构体struct objc_class，这个结构体存放的数据称为元数据(metadata)， 该结构体的第一个成员变量也是isa指针，这就说明了Class本身其实也是一个对象，因此我们称之为类对象，类对象在编译期产生用于创建实例对象，是单例。</p>
<h3 id="实例-objc-object"><a href="#实例-objc-object" class="headerlink" title="实例(objc_object)"></a>实例(objc_object)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/// Represents an instance of a class.</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/// A pointer to an instance of a class.</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure>
<p>类对象中的元数据存储的都是如何创建一个实例的相关信息，那么类对象和类方法应该从哪里创建呢？ 就是从isa指针指向的结构体创建，类对象的isa指针指向的我们称之为元类(metaclass)， 元类中保存了创建类对象以及类方法所需的所有信息，因此整个结构应该如下图所示:</p>
<p><img src="/2019/05/28/iOS-Runtime/a001.png" alt></p>
<h3 id="元类-Meta-Class"><a href="#元类-Meta-Class" class="headerlink" title="元类(Meta Class)"></a>元类(Meta Class)</h3><p>通过上图我们可以看出整个体系构成了一个自闭环，struct objc_object结构体实例它的isa指针指向类对象， 类对象的isa指针指向了元类，super_class指针指向了父类的类对象， 而元类的super_class指针指向了父类的元类，那元类的isa指针又指向了自己。</p>
<p>元类(Meta Class)是一个类对象的类。 在上面我们提到，所有的类自身也是一个对象，我们可以向这个对象发送消息(即调用类方法)。 为了调用类方法，这个类的isa指针必须指向一个包含这些类方法的一个objc_class结构体。这就引出了meta-class的概念，元类中保存了创建类对象以及类方法所需的所有信息。 任何NSObject继承体系下的meta-class都使用NSObject的meta-class作为自己的所属类，而基类的meta-class的isa指针是指向它自己。</p>
<h3 id="Method-objc-method"><a href="#Method-objc-method" class="headerlink" title="Method(objc_method)"></a>Method(objc_method)</h3><p>先看下定义</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/// An opaque <span class="built_in">type</span> that represents a method <span class="keyword">in</span> a class definition.代表类定义中一个方法的不透明类型</span><br><span class="line">typedef struct objc_method *Method;</span><br><span class="line">struct objc_method &#123;</span><br><span class="line">    SEL method_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    char *method_types                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp                                           OBJC2_UNAVAILABLE;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Method和我们平时理解的函数是一致的，就是表示能够独立完成一个功能的一段代码，比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)logName</span><br><span class="line">&#123;</span><br><span class="line">        NSLog(@<span class="string">"name"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码，就是一个函数。</p>
<p>我们来看下objc_method这个结构体的内容：</p>
<ul>
<li>SEL method_name 方法名</li>
<li>char *method_types 方法类型</li>
<li>IMP method_imp 方法实现</li>
</ul>
<p>在这个结构体重，我们已经看到了SEL和IMP，说明SEL和IMP其实都是Method的属性。<br>我们接着来看SEL。</p>
<h3 id="SEL-objc-selector"><a href="#SEL-objc-selector" class="headerlink" title="SEL(objc_selector)"></a>SEL(objc_selector)</h3><p>先看下定义</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Objc.h</span><br><span class="line">/// An opaque <span class="built_in">type</span> that represents a method selector.代表一个方法的不透明类型</span><br><span class="line">typedef struct objc_selector *SEL;</span><br></pre></td></tr></table></figure>
<p>objc_msgSend函数第二个参数类型为SEL，它是selector在Objective-C中的表示类型（Swift中是Selector类）。selector是方法选择器，可以理解为区分方法的 ID，而这个 ID的数据结构是SEL:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property SEL selector;</span><br></pre></td></tr></table></figure>
<p>可以看到selector是SEL的一个实例。</p>
<blockquote>
<p>A method selector is a C string that has been registered (or “mapped“) with the Objective-C runtime. Selectors generated by the compiler are automatically mapped by the runtime when the class is loaded.</p>
</blockquote>
<p>其实selector就是个映射到方法的C字符串，你可以用 Objective-C编译器命令@selector()或者 Runtime系统的sel_registerName函数来获得一个 SEL类型的方法选择器。</p>
<p>selector既然是一个string，我觉得应该是类似className+method的组合，命名规则有两条：</p>
<ul>
<li>同一个类，selector不能重复</li>
<li>不同的类，selector可以重复</li>
</ul>
<p>这也带来了一个弊端，我们在写C代码的时候，经常会用到函数重载，就是函数名相同，参数不同，但是这在Objective-C中是行不通的，因为selector只记了method的name，没有参数，所以没法区分不同的method。</p>
<p>比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)caculate(NSInteger)num;</span><br><span class="line">- (void)caculate(CGFloat)num;</span><br></pre></td></tr></table></figure>
<p>是会报错的。</p>
<p>我们只能通过命名来区别：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)caculateWithInt(NSInteger)num;</span><br><span class="line">- (void)caculateWithFloat(CGFloat)num;</span><br></pre></td></tr></table></figure>
<p>在不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器。</p>
<h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h3><p>看下IMP的定义</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/// A pointer to the <span class="keyword">function</span> of a method implementation.  指向一个方法实现的指针</span><br><span class="line">typedef id (*IMP)(id, SEL, ...); </span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure>
<p>就是指向最终实现程序的内存地址的指针。</p>
<p>在iOS的Runtime中，Method通过selector和IMP两个属性，实现了快速查询方法及实现，相对提高了性能，又保持了灵活性。</p>
<h3 id="类缓存-objc-cache"><a href="#类缓存-objc-cache" class="headerlink" title="类缓存(objc_cache)"></a>类缓存(objc_cache)</h3><p>当Objective-C运行时通过跟踪它的isa指针检查对象时，它可以找到一个实现许多方法的对象。然而，你可能只调用它们的一小部分，并且每次查找时，搜索所有选择器的类分派表没有意义。所以类实现一个缓存，每当你搜索一个类分派表，并找到相应的选择器，它把它放入它的缓存。所以当objc_msgSend查找一个类的选择器，它首先搜索类缓存。这是基于这样的理论：如果你在类上调用一个消息，你可能以后再次调用该消息。</p>
<p>为了加速消息分发， 系统会对方法和对应的地址进行缓存，就放在上述的objc_cache，所以在实际运行中，大部分常用的方法都是会被缓存起来的，Runtime系统实际上非常快，接近直接执行内存地址的程序速度。</p>
<h3 id="Category-objc-category"><a href="#Category-objc-category" class="headerlink" title="Category(objc_category)"></a>Category(objc_category)</h3><p>Category是表示一个指向分类的结构体的指针，其定义如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct category_t &#123; </span><br><span class="line">    const char *name; </span><br><span class="line">    classref_t cls; </span><br><span class="line">    struct method_list_t *instanceMethods; </span><br><span class="line">    struct method_list_t *classMethods;</span><br><span class="line">    struct protocol_list_t *protocols;</span><br><span class="line">    struct property_list_t *instanceProperties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>name：是指 class_name 而不是 category_name。</li>
<li>cls：要扩展的类对象，编译期间是不会定义的，而是在Runtime阶段通过name对 应到对应的类对象。</li>
<li>instanceMethods：category中所有给类添加的实例方法的列表。</li>
<li>classMethods：category中所有添加的类方法的列表。</li>
<li>protocols：category实现的所有协议的列表。</li>
<li>instanceProperties：表示Category里所有的properties，这就是我们可以通过objc_setAssociatedObject和objc_getAssociatedObject增加实例变量的原因，不过这个和一般的实例变量是不一样的。</li>
</ul>
<p>从上面的category_t的结构体中可以看出，分类中可以添加实例方法，类方法，甚至可以实现协议，添加属性，不可以添加成员变量。</p>
<h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><p>前文介绍了进行一次发送消息会在相关的类对象中搜索方法列表，如果找不到则会沿着继承树向上一直搜索知道继承树根部（通常为NSObject），如果还是找不到并且消息转发都失败了就回执行doesNotRecognizeSelector:方法报unrecognized selector错。</p>
<p>那么消息转发到底是什么呢？接下来将会逐一介绍最后的三次机会。</p>
<ul>
<li>动态方法解析</li>
<li>备用接收者</li>
<li>完整消息转发</li>
</ul>
<p><img src="/2019/05/28/iOS-Runtime/a001.png" alt></p>
<h3 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h3><p>首先，Objective-C运行时会调用 +resolveInstanceMethod:或者 +resolveClassMethod:，让你有机会提供一个函数实现。如果你添加了函数并返回YES， 那运行时系统就会重新启动一次消息发送的过程。</p>
<p>实现一个动态方法解析的例子如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view, typically from a nib.</span><br><span class="line">    //执行foo函数</span><br><span class="line">    [self performSelector:@selector(foo:)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">if</span> (sel == @selector(foo:)) &#123;//如果是执行foo函数，就动态解析，指定新的IMP</span><br><span class="line">        class_addMethod([self class], sel, (IMP)fooMethod, <span class="string">"v@:"</span>);</span><br><span class="line">        <span class="built_in">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void fooMethod(id obj, SEL _cmd) &#123;</span><br><span class="line">    NSLog(@<span class="string">"Doing foo"</span>);//新的foo函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打印结果： Doing foo</span><br></pre></td></tr></table></figure>
<p>可以看到虽然没有实现foo:这个函数，但是我们通过class_addMethod动态添加fooMethod函数，并执行fooMethod这个函数的IMP。</p>
<p>从打印结果看，成功实现了。</p>
<p>如果resolve方法返回 NO，运行时就会移到下一步：forwardingTargetForSelector。</p>
<h3 id="备用接收者"><a href="#备用接收者" class="headerlink" title="备用接收者"></a>备用接收者</h3><p>如果目标对象实现了-forwardingTargetForSelector:，Runtime这时就会调用这个方法，给你把这个消息转发给其他对象的机会。</p>
<p>实现一个备用接收者的例子如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#import "ViewController.h"</span></span><br><span class="line"><span class="comment">#import "objc/runtime.h"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface Person: NSObject</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)foo &#123;</span><br><span class="line">    NSLog(@<span class="string">"Doing foo"</span>);//Person的foo函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view, typically from a nib.</span><br><span class="line">    //执行foo函数</span><br><span class="line">    [self performSelector:@selector(foo)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="built_in">return</span> YES;//返回YES，进入下一步转发</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == @selector(foo)) &#123;</span><br><span class="line">        <span class="built_in">return</span> [Person new];//返回Person对象，让Person对象接收这个消息</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">return</span> [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打印结果： Doing foo</span><br></pre></td></tr></table></figure>
<p>可以看到我们通过forwardingTargetForSelector把当前ViewController的方法转发给了Person去执行了。打印结果也证明我们成功实现了转发。</p>
<h3 id="完整消息转发"><a href="#完整消息转发" class="headerlink" title="完整消息转发"></a>完整消息转发</h3><p>如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。 首先它会发送-methodSignatureForSelector:消息获得函数的参数和返回值类型。如果-methodSignatureForSelector:返回nil，Runtime则会发出 -doesNotRecognizeSelector:消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送 -forwardInvocation:消息给目标对象。</p>
<p>实现一个完整转发的例子如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#import "ViewController.h"</span></span><br><span class="line"><span class="comment">#import "objc/runtime.h"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface Person: NSObject</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)foo &#123;</span><br><span class="line">    NSLog(@<span class="string">"Doing foo"</span>);//Person的foo函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view, typically from a nib.</span><br><span class="line">    //执行foo函数</span><br><span class="line">    [self performSelector:@selector(foo)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="built_in">return</span> YES;//返回YES，进入下一步转发</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="built_in">return</span> nil;//返回nil，进入下一步转发</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> ([NSStringFromSelector(aSelector) isEqualToString:@<span class="string">"foo"</span>]) &#123;</span><br><span class="line">        <span class="built_in">return</span> [NSMethodSignature signatureWithObjCTypes:<span class="string">"v@:"</span>];//签名，进入forwardInvocation</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">return</span> [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    SEL sel = anInvocation.selector;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Person *p = [Person new];</span><br><span class="line">    <span class="keyword">if</span>([p respondsToSelector:sel]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        [self doesNotRecognizeSelector:sel];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打印结果：Doing foo</span><br></pre></td></tr></table></figure>
<p>从打印结果来看，我们实现了完整的转发。通过签名，Runtime生成了一个对象anInvocation，发送给了forwardInvocation，我们在forwardInvocation方法里面让Person对象去执行了foo函数。签名参数v@:怎么解释呢，这里苹果文档<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="noopener">Type Encodings</a>有详细的解释。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>Method Swizzling</li>
<li>KVO</li>
<li>MJExtension</li>
<li>模拟多继承</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jackthenoob.github.io/2019/05/28/ios-NSObject从创建到销毁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="垂杨小梳雨">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lyddwn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/28/ios-NSObject从创建到销毁/" itemprop="url">ios NSObject从创建到销毁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-28T21:07:19+08:00">
                2019-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jackthenoob.github.io/2019/05/27/iOS-NSObject对象模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="垂杨小梳雨">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lyddwn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/27/iOS-NSObject对象模型/" itemprop="url">iOS NSObject对象模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-27T20:33:52+08:00">
                2019-05-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们编写的Objective-C代码，底层通过C/C++代码实现。</p>
<blockquote>
<p>Objective-C -&gt; C/C++ -&gt; 汇编语言 -&gt; 机器语言</p>
</blockquote>
<p>那么一个Objective-C类、对象是如何通过C/C++实现、储存的呢？</p>
<h2 id="源码探究"><a href="#源码探究" class="headerlink" title="源码探究"></a>源码探究</h2><h3 id="ISA"><a href="#ISA" class="headerlink" title="ISA"></a>ISA</h3><p>我们通过以下命令，将.m文件转化为C/C++代码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc **.m</span><br></pre></td></tr></table></figure>
<p>可以获取 **.cpp文件。</p>
<p>在7700多行，可以获取如下结构体</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct NSObject_IMPL &#123;</span><br><span class="line">	Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在objc.h头文件中，我们可以发现如下代码 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#if !OBJC_TYPES_DEFINED</span></span><br><span class="line">/// An opaque <span class="built_in">type</span> that represents an Objective-C class.</span><br><span class="line">typedef struct objc_class *Class;</span><br><span class="line"></span><br><span class="line">/// Represents an instance of a class.</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过注释我们得知：</p>
<ul>
<li>结构体objc_class表示一个Objective-C的类。</li>
<li>结构体objc_object表示一个Objective-C Class的实例。</li>
</ul>
<blockquote>
<p>那么objc_class又是什么呢？</p>
</blockquote>
<p>在runtime.h文件中，我们可以发现如下代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line"><span class="comment">#if !__OBJC2__</span></span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</span><br><span class="line">    const char * _Nonnull name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br><span class="line">/* Use `Class` instead of `struct objc_class *` */</span><br></pre></td></tr></table></figure>
<p>我们可以得知：在Objective-C中，每个对象都是一个结构体，都有一个isa指针，类对象Class也是一个对象。在运行时，可以通过isa指针查找该对象是什么类。</p>
<hr>
<blockquote>
<p>那么isa到底是什么？为什么需要isa呢？  </p>
</blockquote>
<p>我们可以通过<a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="noopener">objc4</a>源码获取一些信息</p>
<blockquote>
<p>objc4 的源码不能直接编译，需要配置相关环境才能运行。可以在这里下载可调式的源码。<br>objc 运行时源码的入口在 void _objc_init(void) 函数。  </p>
</blockquote>
<p>objc-private.h</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">	//isa是一个union联合体，包含这个对象所属类的信息</span><br><span class="line">    isa_t isa;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    // ISA() assumes this is NOT a tagged pointer object</span><br><span class="line">    Class ISA();</span><br><span class="line"></span><br><span class="line">    // getIsa() allows this to be a tagged pointer object</span><br><span class="line">    Class getIsa();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>objc-runtime-new.h</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    // Class ISA; （ISA继承于objc_object）</span><br><span class="line">    Class superclass;	//当前类父类</span><br><span class="line">    cache_t cache;             // formerly cache pointer and vtable 缓存指针和vtable，提高方法调用效率</span><br><span class="line">    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags 存储类的方法、属性、协议等信息</span><br><span class="line">    </span><br><span class="line">    // 针对 class_data_bits_t 的 data() 函数的封装，最终返回一个 class_rw_t 类型的结构体变量</span><br><span class="line">    // Objective-C 类中的属性、方法还有遵循的协议等信息都保存在 class_rw_t 中</span><br><span class="line">    class_rw_t *<span class="function"><span class="title">data</span></span>() &#123; </span><br><span class="line">        <span class="built_in">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过源码可以得知，objc_class继承于objc_object，所以二者都存在isa成员变量，类型为：isa_t。isa_t是一个union。</p>
<p>我们回到objc-private.h中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">union isa_t &#123;</span><br><span class="line">    <span class="function"><span class="title">isa_t</span></span>() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line">	//所属类</span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line"><span class="comment">#if defined(ISA_BITFIELD)</span></span><br><span class="line">    struct &#123;</span><br><span class="line">        ISA_BITFIELD;  // defined <span class="keyword">in</span> isa.h</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>isa_t包含一个成员变量 cls。</p>
<blockquote>
<p>每个objc_object通过自己持有的isa查找到自己所属的类。而对于objc_class来说，可以通过isa找到自己的mate class，即元类。</p>
</blockquote>
<p><img src="/2019/05/27/iOS-NSObject对象模型/a001.jpg" alt></p>
<p>对于IAS_BITFIELD，定义如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//__arm64__ </span><br><span class="line"><span class="comment">#   define ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class="line"><span class="comment">#   define ISA_MAGIC_MASK  0x000003f000000001ULL</span></span><br><span class="line"><span class="comment">#   define ISA_MAGIC_VALUE 0x000001a000000001ULL</span></span><br><span class="line"><span class="comment">#   define ISA_BITFIELD                                                      \</span></span><br><span class="line">      uintptr_t nonpointer        : 1;                                       \</span><br><span class="line">      uintptr_t has_assoc         : 1;                                       \</span><br><span class="line">      uintptr_t has_cxx_dtor      : 1;                                       \</span><br><span class="line">      uintptr_t shiftcls          : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \</span><br><span class="line">      uintptr_t magic             : 6;                                       \</span><br><span class="line">      uintptr_t weakly_referenced : 1;                                       \</span><br><span class="line">      uintptr_t deallocating      : 1;                                       \</span><br><span class="line">      uintptr_t has_sidetable_rc  : 1;                                       \</span><br><span class="line">      uintptr_t extra_rc          : 19</span><br></pre></td></tr></table></figure>
<ul>
<li>nonpointer</li>
</ul>
<p>表示 isa_t 的类型，0 表示 raw isa，也就是没有结构体的部分，访问对象的 isa 会直接返回一个指向 cls 的指针，也就是在 iPhone 迁移到 64 位系统之前时 isa 的类型。1 表示当前 isa 不是指针，但是其中也有 cls 的信息，只是其中关于类的指针都是保存在 shiftcls 中。</p>
<ul>
<li>has_assoc</li>
</ul>
<p>对象含有或者曾经含有关联引用（category相关），没有关联引用的可以更快地释放内存（object dealloc相关，其他文章会说到）。</p>
<ul>
<li>has_cxx_dtor</li>
</ul>
<p>表示当前对象有 C++ 或者 ObjC 的析构器(destructor)，如果没有析构器就会快速释放内存（object dealloc相关）。</p>
<ul>
<li>shiftcls</li>
</ul>
<p>见nonpointer</p>
<ul>
<li>magic</li>
</ul>
<p>用于调试器判断当前对象是真的对象还是没有初始化的空间</p>
<ul>
<li>weakly_referenced</li>
</ul>
<p>对象被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放</p>
<ul>
<li>deallocating </li>
</ul>
<p>对象正在释放内存</p>
<ul>
<li>has_sidetable_rc</li>
</ul>
<p>对象的引用计数太大了，存不下</p>
<ul>
<li>extra_rc</li>
</ul>
<p>对象的引用计数超过 1，会存在这个这个里面，如果引用计数为 10，extra_rc 的值就为 9。</p>
<hr>
<h4 id="isa初始化"><a href="#isa初始化" class="headerlink" title="isa初始化"></a>isa初始化</h4><p>我们可以通过isa初始化方法，来了解这64位bits作用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">inline void </span><br><span class="line">objc_object::initIsa(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    initIsa(cls, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline void </span><br><span class="line">objc_object::initClassIsa(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (DisableNonpointerIsa  ||  cls-&gt;instancesRequireRawIsa()) &#123;</span><br><span class="line">        initIsa(cls, <span class="literal">false</span>/*not nonpointer*/, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        initIsa(cls, <span class="literal">true</span>/*nonpointer*/, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline void </span><br><span class="line">objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)</span><br><span class="line">&#123;</span><br><span class="line">    assert(!cls-&gt;instancesRequireRawIsa());</span><br><span class="line">    assert(hasCxxDtor == cls-&gt;hasCxxDtor());</span><br><span class="line"></span><br><span class="line">    initIsa(cls, <span class="literal">true</span>, hasCxxDtor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline void </span><br><span class="line">objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) </span><br><span class="line">&#123; </span><br><span class="line">    assert(!isTaggedPointer()); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!nonpointer) &#123;</span><br><span class="line">        isa.cls = cls;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(!DisableNonpointerIsa);</span><br><span class="line">        assert(!cls-&gt;instancesRequireRawIsa());</span><br><span class="line"></span><br><span class="line">        isa_t newisa(0);</span><br><span class="line"></span><br><span class="line"><span class="comment">#if SUPPORT_INDEXED_ISA</span></span><br><span class="line">        assert(cls-&gt;classArrayIndex() &gt; 0);</span><br><span class="line">        newisa.bits = ISA_INDEX_MAGIC_VALUE;</span><br><span class="line">        // isa.magic is part of ISA_MAGIC_VALUE</span><br><span class="line">        // isa.nonpointer is part of ISA_MAGIC_VALUE</span><br><span class="line">        newisa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">        newisa.indexcls = (uintptr_t)cls-&gt;classArrayIndex();</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">        newisa.bits = ISA_MAGIC_VALUE;</span><br><span class="line">        // isa.magic is part of ISA_MAGIC_VALUE</span><br><span class="line">        // isa.nonpointer is part of ISA_MAGIC_VALUE</span><br><span class="line">        newisa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">        newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">        // This write must be performed <span class="keyword">in</span> a single store <span class="keyword">in</span> some cases</span><br><span class="line">        // (<span class="keyword">for</span> example when realizing a class because other threads</span><br><span class="line">        // may simultaneously try to use the class).</span><br><span class="line">        // fixme use atomics here to guarantee single-store and to</span><br><span class="line">        // guarantee memory order w.r.t. the class index table</span><br><span class="line">        // ...but not too atomic because we don<span class="string">'t want to hurt instantiation</span></span><br><span class="line"><span class="string">        isa = newisa;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>当我们初始化一个Objective-C对象，为其分配内存时，调用栈中包含了 initInstanceIsa与initIsa这2个方法。</p>
<p>initInstanceIsa方法，传入的nonpointer为true。所以initIsa方法可以简化为(<strong>ARM_ARCH_7K</strong>应该是watch指令集，所以我们只看else部分)：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">inline void </span><br><span class="line">objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor)  &#123;</span><br><span class="line">	isa_t newisa(0);</span><br><span class="line">    newisa.bits = ISA_MAGIC_VALUE;</span><br><span class="line">    newisa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">    newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3;</span><br><span class="line">    isa = newisa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/27/iOS-NSObject对象模型/a002.jpg" alt></p>
<p>先将 newisa 的 bits 赋值为常量 ISA_MAGIC_VALUE</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define ISA_MAGIC_VALUE 0x000001a000000001ULL</span></span><br></pre></td></tr></table></figure>
<p>里面包括了 magic 和 nonpointer 的值。然后将是否有 C++ 析构函数标示上，最后将位移（shift）后的 cls 存入 shiftcls。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将当前地址右移三位的主要原因是用于将 Class 指针中无用的后三位清除减小内存的消耗，因为类的指针要按照字节（8 bits）对齐内存，其指针后三位都是没有意义的 0。  </p>
<p>绝大多数机器的架构都是 byte-addressable 的，但是对象的内存地址必须对齐到字节的倍数，这样可以提高代码运行的性能，在 iPhone5s 中虚拟地址为 33 位，所以用于对齐的最后三位比特为 000，我们只会用其中的 30 位来表示对象的地址。  </p>
</blockquote>
<p>最后将 isa = newisa，工作就结束了。</p>
<h4 id="方法、属性、协议"><a href="#方法、属性、协议" class="headerlink" title="方法、属性、协议"></a>方法、属性、协议</h4><p>在Objective-C中，对象的方法储存在类中，而非实例对象中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">struct class_rw_t &#123;</span><br><span class="line">    // Be warned that Symbolication knows the layout of this structure.</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line"></span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line"></span><br><span class="line">    method_array_t methods;</span><br><span class="line">    property_array_t properties;</span><br><span class="line">    protocol_array_t protocols;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">    char *demangledName;</span><br><span class="line"></span><br><span class="line"><span class="comment">#if SUPPORT_INDEXED_ISA</span></span><br><span class="line">    uint32_t index;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">    void setFlags(uint32_t <span class="built_in">set</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        OSAtomicOr32Barrier(<span class="built_in">set</span>, &amp;flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void clearFlags(uint32_t clear) </span><br><span class="line">    &#123;</span><br><span class="line">        OSAtomicXor32Barrier(clear, &amp;flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // <span class="built_in">set</span> and clear must not overlap</span><br><span class="line">    void changeFlags(uint32_t <span class="built_in">set</span>, uint32_t clear) </span><br><span class="line">    &#123;</span><br><span class="line">        assert((<span class="built_in">set</span> &amp; clear) == 0);</span><br><span class="line"></span><br><span class="line">        uint32_t oldf, newf;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            oldf = flags;</span><br><span class="line">            newf = (oldf | <span class="built_in">set</span>) &amp; ~clear;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!OSAtomicCompareAndSwap32Barrier(oldf, newf, (volatile int32_t *)&amp;flags));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 用于存储一个 Objective-C 类在编译期就已经确定的属性、方法以及遵循的协议</span><br><span class="line">struct class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;</span><br><span class="line"><span class="comment">#ifdef __LP64__</span></span><br><span class="line">    uint32_t reserved;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">    const uint8_t * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    const char * name;</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    const ivar_list_t * ivars;</span><br><span class="line"></span><br><span class="line">    const uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line"></span><br><span class="line">    method_list_t *baseMethods() const &#123;</span><br><span class="line">        <span class="built_in">return</span> baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当一个对象的实例方法被调用时，需要先通过持有的isa指针查找相应的类，然后在类的class_data_bits_t 结构体中查找对应方法的实现（每个对象可以通过 cls-&gt;data()-&gt; methods 来访问所属类的方法）。同时，每一个 objc_class 也有一个指向自己的父类的指针 super_class 用来查找继承的方法。</p>
<p>而当一个类的类方法被调用时，通过类的isa在元类中获取方法的实现。如上图。</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>isa用于查找对象（或类对象）所属类（或元类）的信息，比如方法列表、属性、协议等。</p>
<h3 id="ivar-t"><a href="#ivar-t" class="headerlink" title="ivar_t"></a>ivar_t</h3><h3 id="protocol-t"><a href="#protocol-t" class="headerlink" title="protocol_t"></a>protocol_t</h3><h3 id="method-t"><a href="#method-t" class="headerlink" title="method_t"></a>method_t</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jackthenoob.github.io/2019/05/24/字符集和字符编码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="垂杨小梳雨">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lyddwn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/24/字符集和字符编码/" itemprop="url">字符集和字符编码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-24T17:56:48+08:00">
                2019-05-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Coding/" itemprop="url" rel="index">
                    <span itemprop="name">Coding</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于计算机来说，它无法处理文本，只能与0，1数字打交道。为了可以在计算机中用数字表示文本，我们指定了一个从字符到数字的映射。这个映射叫做编码(encoding)。反之，我们将计算机中数字解析显示为字符，成为解码(decoding)。</p>
<blockquote>
<p>字符集（Charset） </p>
<p>是一个系统支持的所有抽象字符的集合。字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。  </p>
</blockquote>
<p>*</p>
<blockquote>
<p>字符编码（Character Encoding） </p>
<p>是一套法则，将符号集合转换为计算机可以理解的数字。  </p>
</blockquote>
<hr>
<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><ul>
<li>常见的字符集  </li>
</ul>
<blockquote>
<p>ASCII<br>GB2312<br>GB18030<br>BIG5<br>Unicode  </p>
</blockquote>
<h3 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h3><p>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统。它主要用于显示现代英语，而其扩展版本<a href="https://zh.wikipedia.org/wiki/EASCII" target="_blank" rel="noopener">EASCII</a>则可以可以部分支持其他西欧语言，并等同于国际标准<a href="https://zh.wikipedia.org/wiki/ISO/IEC_646" target="_blank" rel="noopener">ISO/IEC 646</a>。</p>
<p>ASCII 码是 7 位的，它将英文字母，数字 0-9 以及一些标点符号和控制字符映射为 0-127 这些整型。</p>
<p>ASCII的最大缺点是只能显示26个基本拉丁字母、阿拉伯数目字和英式标点符号，因此只能用于显示现代美国英语（而且在处理英语当中的外来词如naïve、café、élite等等时，所有重音符号都不得不去掉，即使这样做会违反拼写规则）。而EASCII虽然解决了部份西欧语言的显示问题，但对更多其他语言依然无能为力。因此现在的苹果电脑已经抛弃ASCII而转用<a href="https://zh.wikipedia.org/wiki/Unicode" target="_blank" rel="noopener">Unicode</a>。</p>
<h3 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h3><p><a href="https://zh.wikipedia.org/wiki/GB_2312" target="_blank" rel="noopener">GB 2312</a> 或 GB 2312–80 是中华人民共和国国家标准简体中文字符集，全称《信息交换用汉字编码字符集·基本集》，通常簡稱GB，又稱GB0，由中国国家标准总局发布，1981年5月1日实施。GB 2312编码通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持GB 2312。</p>
<p>GB 2312标准共收录6763个汉字，其中<a href="https://zh.wikipedia.org/wiki/常用字" target="_blank" rel="noopener">一级汉字</a>3755个，<a href="https://zh.wikipedia.org/wiki/次常用字" target="_blank" rel="noopener">二级汉字</a>3008个；同时收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的682个字符。</p>
<p>GB 2312的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆99.75%的使用频率。但对于人名、古汉语等方面出现的罕用字和繁體字，GB 2312不能处理，因此后来<a href="https://zh.wikipedia.org/wiki/汉字内码扩展规范" target="_blank" rel="noopener">GBK</a>及<a href="https://zh.wikipedia.org/wiki/GB_18030" target="_blank" rel="noopener">GB 18030</a>汉字字符集相继出现以解決這些問題。</p>
<h3 id="GB18030"><a href="#GB18030" class="headerlink" title="GB18030"></a>GB18030</h3><p><a href="https://zh.wikipedia.org/wiki/GB_18030" target="_blank" rel="noopener">GB 18030</a>，全称《信息技术　中文编码字符集》，是中华人民共和国国家标准所规定的变长多字节字符集。其对GB 2312-1980完全向后兼容，与GBK基本向后兼容，并支持Unicode（GB 13000）的所有码位。GB 18030共收录汉字70,244个。</p>
<ul>
<li>GB 18030主要有以下特点</li>
</ul>
<blockquote>
<p>采用变长多字节编码，每个字可以由1个、2个或4个字节组成。<br>编码空间庞大，最多可定义161万个字元。<br>完全支持Unicode，无需动用造字区即可支持中国国內少数民族文字、中日韩和繁体汉字以及emoji等字符。  </p>
</blockquote>
<h3 id="BIG5"><a href="#BIG5" class="headerlink" title="BIG5"></a>BIG5</h3><p><a href="https://zh.wikipedia.org/wiki/大五碼" target="_blank" rel="noopener">Big5</a>，又称为大五码或五大码，是使用繁体中文（正体中文）社区中最常用的电脑汉字字符集标准，共收录13,060个汉字。</p>
<p>中文码分为内码及交换码两类，Big5属中文内码，知名的中文交换码有CCCII、CNS11643。Big5虽普及于台湾、香港与澳门等繁体中文通行区，但长期以来并非当地的国家标准，而只是业界标准。倚天中文系统、Windows等主要系统的字符集都是以Big5为基准，但厂商又各自增加不同的造字与造字区，派生成多种不同版本。</p>
<p>2003年，Big5被收录到CNS11643中文标准交换码的附录当中，取得了较正式的地位。这个最新版本被称为Big5-2003。</p>
<blockquote>
<p>不同国家、不同语言在网络上交流时，如果都实现类似GB2312/GB18030/BIG5的编码方案，各自出一套方案，相互不兼容，就非常容易出现乱码。</p>
</blockquote>
<h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>为了解决这个问题，<a href="https://zh.wikipedia.org/wiki/Unicode" target="_blank" rel="noopener">Unicode</a>（统一码、万国码、单一码、标准万国码）应运而生。Unicode为世界上几乎所有的书写系统里所使用的每一个字符或符号定义了一个唯一的数字，这个数字叫做码点（code points）。它使用4字节的数字来表达每个字母、符号，或者表意文字(ideograph)。</p>
<p>最初，Unicode 编码是被设计为 16 位的，提供了 65,536 个字符的空间。当时人们认为这已经大到足够编码世界上现代文本里所有的文字和字符了。</p>
<p>后来，考虑到要编码历史上的文字以及一些很少使用的日本汉字和中国汉字，Unicode 编码扩展到了 21 位（从 U+0000 到 U+10FFFF）。Unicode 不是 16 位的编码！它是 21 位的。这 21 位提供了 1,114,112 个码点，其中，只有大概 10% 正在使用，所以还有相当大的扩充空间。</p>
<blockquote>
<p>简单来说：Unicode是一个统一了地球上所有语言的字符集。</p>
</blockquote>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>字符和码点之间的映射已经有了，但还需要定义另一种编码来确定码点在内存和硬盘中要如何表示。</p>
<p>Unicode 标准为此定义了几种映射，叫做「Unicode 转换格式」（Unicode Transformation Formats，简称 UTF）。</p>
<p>日常工作中，人们就直接把它们叫做「编码」—— 因为按照定义，如果是用 UTF 编码的，那么就要使用 Unicode，所以也就没必要明确区分这两个步骤了。</p>
<h3 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h3><p>最清楚明了的一个 UTF 就是 UTF-32：它在每个码点上使用整 32 位。32 大于 21，因此每一个 UTF-32 值都可以直接表示对应的码点。</p>
<p>尽管简单，UTF-32却几乎从来不在实际中使用，因为每个字符占用 4 字节太浪费空间了。比如：表述一个字母A（只需要7位一个字节），前3字节空间被浪费了。</p>
<h3 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h3><p>尽管有Unicode字符非常多，但是实际上大多数人不会用到超过前65535个以外的字符。因此，就有了另外一种Unicode编码方式，叫做UTF-16。</p>
<p>UTF-16 本身是一种长度可变的编码。基本多文种平面（BMP）中的每一个码点都直接与一个码元相映射。鉴于 BMP 几乎囊括了所有常见字符，UTF-16 一般只需要 UTF-32 一半的空间。其它平面里很少使用的码点都是用两个 16 位的码元来编码的，这两个合起来表示一个码点的码元就叫做代理对（surrogate pair）。</p>
<p>和所有多字节长度的编码系统一样，UTF-16（以及 UTF-32）还得解决<a href="https://en.wikipedia.org/wiki/Endianness" target="_blank" rel="noopener">字节顺序</a>的问题。在内存里存储字符串时，大多数实现方式自然都采用自己运行平台的 CPU 的字节序（endianness）；而在硬盘里存储或者通过网络传输字符串时，UTF-16 允许在字符串的开头插入一个「<a href="https://en.wikipedia.org/wiki/Byte_order_mark" target="_blank" rel="noopener">字节顺序标记</a>」（Byte Order Mask，简称 BOM）。</p>
<p>字节顺序标记是一个值为 U+FEFF 的码元，通过检查文件的头两个字节，解码器就可以识别出其字节顺序。字节顺序标记不是必须的，Unicode 标准把高字节顺序（big-endian byte order）定为默认情况。UTF-16 需要指明字节顺序，这也是为什么 UTF-16 在文件格式和网络传输方面不受欢迎的一个原因，不过微软和苹果都在自己的操作系统内部使用它。</p>
<h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>UTF-16 还是在常用的英文和西欧文本上浪费了大量的空间：每个 16 位的码点的高 8 位的值都会是 0。</p>
<p>UTF-8（8-bit Unicode Transformation Format）是一种针对Unicode的可变长度字符编码。它可以用来表示Unicode标准中的任何字符，且其编码中的第一个字节仍与ASCII兼容，这使得原来处理ASCII字符的软件无须或只须做少部份修改，即可继续使用。因此，它逐渐成为电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。</p>
<p>UTF-8使用一至四个字节为每个字符编码：</p>
<ul>
<li>128个US-ASCII字符只需一个字节编码（Unicode范围由U+0000至U+007F）。  </li>
<li>带有附加符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及它拿字母则需要二个字节编码（Unicode范围由U+0080至U+07FF）。  </li>
<li>其他基本多文种平面（BMP）中的字符（这包含了大部分常用字）使用三个字节编码。    </li>
<li>其他极少使用的Unicode辅助平面的字符使用四字节编码。</li>
</ul>
<hr>
<h2 id="iOS相关"><a href="#iOS相关" class="headerlink" title="iOS相关"></a>iOS相关</h2><h3 id="NSString和Unicode"><a href="#NSString和Unicode" class="headerlink" title="NSString和Unicode"></a>NSString和Unicode</h3><p>NSString文档</p>
<blockquote>
<p>An NSString object encodes a Unicode-compliant text string, represented as a sequence of UTF–16 code units. All lengths, character indexes, and ranges are expressed in terms of UTF–16 code units, with index values starting at 0.  The length property of an NSString returns the number of UTF-16 code units in an NSString, and the characterAtIndex: method retrieves a specific UTF-16 code unit. These two “primitive” methods provide basic access to the contents of a string object.</p>
</blockquote>
<p>我们已经了解了 Unicode 是一种 21 位的编码方案。</p>
<p>就想文档所说，NSString 代表的是用 UTF-16 编码的文本，长度、索引和范围都基于 UTF-16 的码元。除非你知道字符串的内容，或者你提前有所防范，不然 NSString 类里的方法都是基于上述概念的，无法给你提供可靠的信息。每当文档提及「字符」（character）或者 unichar 时，它其实都说的是码元。</p>
<p>NSString 对象代表的是用 UTF-16 编码的码元组成的数组。相应地，length 方法的返回值也是字符串包含的码元个数（而不是字符个数）。</p>
<p><font color="#000000" size="5">length </font> </p>
<blockquote>
<p>The number of UTF-16 code units in the receiver.  </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Declaration</span><br><span class="line">@property(<span class="built_in">readonly</span>) NSUInteger length;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Discussion  </p>
<p>This number includes the individual characters of composed character sequences, so you cannot use this property to determine if a string will be visible when printed or how long it will appear.  </p>
</blockquote>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>文本很复杂，程序员还是需要了解其中的运作机制以便能正确处理它。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jackthenoob.github.io/2019/05/23/iOS测试代码运行效率-diapatch-benchmark/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="垂杨小梳雨">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lyddwn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/23/iOS测试代码运行效率-diapatch-benchmark/" itemprop="url">iOS测试代码运行效率-diapatch_benchmark</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-23T13:57:02+08:00">
                2019-05-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在日常开发过程中，我们经常会遇到这样的疑问：</p>
<blockquote>
<p>这段代码相对效率是多少？方法A与方法B哪个更快？</p>
</blockquote>
<h4 id="打时间戳"><a href="#打时间戳" class="headerlink" title="打时间戳"></a>打时间戳</h4><p>逻辑很简单：代码运行前记录一次时间，运行后记录一次，然后比较时间差即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CFTimeInterval startTime = CACurrentMediaTime();</span><br><span class="line"></span><br><span class="line">//your <span class="built_in">test</span> code goes here</span><br><span class="line"></span><br><span class="line">CFTimeInterval endTime = CACurrentMediaTime();</span><br><span class="line">NSLog(@<span class="string">"Total Runtime: %g s"</span>, endTime - startTime);</span><br></pre></td></tr></table></figure>
<h4 id="diapatch-benchmark"><a href="#diapatch-benchmark" class="headerlink" title="diapatch_benchmark"></a>diapatch_benchmark</h4><p>dispatch_benchmark 是 libdispatch (Grand Central Dispatch) 的一部分。但这个方法并没有被公开声明，所以你必须要自己声明：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern uint64_t dispatch_benchmark(size_t count, void (^block)(void));</span><br></pre></td></tr></table></figure>
<p>因为没有公开的函数定义， dispatch_benchmark 在 Xcode 中也没有公开的文档。但幸运的是有 man 页面</p>
<p>dispatch_benchmark(3)</p>
<blockquote>
<p>The dispatch_benchmark function executes the given block multiple times according to the count variable and then returns the average number of nanoseconds per execution. This function is for debugging and performance analysis work. For the best results, pass a high count value to dispatch_benchmark.<br>Please look for inflection points with various data sets and keep the following facts in mind:</p>
<ul>
<li>Code bound by computational bandwidth may be inferred by proportional changes in performance as concurrency is increased.</li>
<li>Code bound by memory bandwidth may be inferred by negligible changes in performance as concurrency is increased.</li>
<li>Code bound by critical sections may be inferred by retrograde changes in performance as concurrency is increased.<ul>
<li>Intentional: locks, mutexes, and condition variables.</li>
<li>Accidental: unrelated and frequently modified data on the same cache-line.  </li>
</ul>
</li>
</ul>
</blockquote>
<h6 id="dispatch-benchmark是一个根据传入的count参数多次执行给定block然后返回平均执行时间（纳秒）的方法。这个方法用于调试和测试分析代码性能。为了获取跟好的效果，传入的一个较大的count值"><a href="#dispatch-benchmark是一个根据传入的count参数多次执行给定block然后返回平均执行时间（纳秒）的方法。这个方法用于调试和测试分析代码性能。为了获取跟好的效果，传入的一个较大的count值" class="headerlink" title="dispatch_benchmark是一个根据传入的count参数多次执行给定block然后返回平均执行时间（纳秒）的方法。这个方法用于调试和测试分析代码性能。为了获取跟好的效果，传入的一个较大的count值"></a>dispatch_benchmark是一个根据传入的count参数多次执行给定block然后返回平均执行时间（纳秒）的方法。这个方法用于调试和测试分析代码性能。为了获取跟好的效果，传入的一个较大的count值</h6><h5 id="使用Sample"><a href="#使用Sample" class="headerlink" title="使用Sample"></a>使用Sample</h5><p>对于iOS中NSMutableArray，它对首尾插入/删除有较高的效率，近乎常数。</p>
<p>下面我们对比下，首尾删除与在中间删除有多少差距。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//测试函数</span><br><span class="line">- (void)benchmark &#123;</span><br><span class="line">    </span><br><span class="line">    NSUInteger iterations = 100;</span><br><span class="line">    NSMutableArray *iterationArray = [NSMutableArray arrayWithArray:_testArray];</span><br><span class="line">    NSMutableArray *iterationArray2 = [NSMutableArray arrayWithArray:_testArray];;</span><br><span class="line">    </span><br><span class="line">    uint64_t t_0 = dispatch_benchmark(iterations, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; self-&gt;_count; i ++) &#123;</span><br><span class="line">            NSUInteger index = iterationArray.count/2;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; iterationArray.count) &#123;</span><br><span class="line">                [iterationArray removeObjectAtIndex:index];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@<span class="string">"Remove Array At Middle Avg. Runtime: %llu ms"</span>, t_0/1000);</span><br><span class="line">    uint64_t t_1 = dispatch_benchmark(iterations, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; self-&gt;_count; i ++) &#123;</span><br><span class="line">            NSUInteger index = iterationArray2.count/2;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; iterationArray2.count) &#123;</span><br><span class="line">                [iterationArray2 removeObjectAtIndex:0];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@<span class="string">"Remove Array From Begining Avg. Runtime: %llu ms"</span>, t_1/1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//调用</span><br><span class="line">&#123;</span><br><span class="line">	_count = 200000;</span><br><span class="line">    _testArray = [NSMutableArray arrayWithCapacity:_count];</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; _count; i ++) &#123;</span><br><span class="line">        [_testArray addObject:@(i)];</span><br><span class="line">    &#125;</span><br><span class="line">    [self benchmark];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码可以看出，初始化了一个数量为200000的可变数组，分别在中间、首尾移除数组元素，执行100次。</p>
<blockquote>
<p>执行结果</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Remove Array At Middle Avg. Runtime: 21851 ms</span><br><span class="line">Remove Array From Begining Avg. Runtime: 1553 ms</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jackthenoob.github.io/2019/05/23/Xcode开发效率-快捷键-代码块/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="垂杨小梳雨">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lyddwn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/23/Xcode开发效率-快捷键-代码块/" itemprop="url">Xcode开发效率-快捷键&代码块</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-23T11:07:06+08:00">
                2019-05-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Xcode/" itemprop="url" rel="index">
                    <span itemprop="name">Xcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>程序员使用最多的还是键盘，我们可以通过快捷键的使用来方便的、快捷的访问Xcode很多功能。从而提高开发效率。</p>
</blockquote>
<h2 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h2><ul>
<li>Shift + Command + O（字母O，而非0）弹出快速查找文件窗口。 </li>
<li>Shift +Commond + 0（数字0，而非字母O）快速打开官方文档。 </li>
<li>Shift + Comand + j 定位到文件所在目录，配合第一条快捷键使用。</li>
<li>Control + Command + 上\下  切换 .m 和.h。</li>
<li>Command + t 新建一个Tab（这个很实用，我平时一般都会建3，4个Tab）。</li>
<li>Command + w 关闭Tab。</li>
<li>Command + ` 切换同一个应用多个窗口。可以用来在多个Xcode窗口中切换。</li>
<li>Control + Command + e 可以批量修改光标所在位置的变量，像这样：</li>
</ul>
<p><img src="/2019/05/23/Xcode开发效率-快捷键-代码块/a001.gif" alt></p>
<ul>
<li>Shift + Command + f 打开全局搜索。(可以加个 Any 正则，就可以搜出如图中的这种)</li>
</ul>
<p><img src="/2019/05/23/Xcode开发效率-快捷键-代码块/a002.jpg" alt></p>
<ul>
<li>Command + f 在类中搜索 （enter 匹配下一个 Shift + enter 匹配上一个）。</li>
<li>Command + 上\下\左\右 光标切换到类首/类尾/行首/行尾。</li>
<li>Shift + Command + 上\下\左\右 从当前光标所在选中到类首/类尾/行首/行尾的文本。</li>
<li>alt + 左\右 光标左右移动一个单词。 </li>
<li>Command + delete 删除光标到行首的内容，同理alt + delete 删除光标前的一个单词，另外可以先切换到到行尾 用Command + delete删除一整行内容。</li>
<li>Control + i 自动缩进代码。</li>
<li>Command + \ 当前行加断点。</li>
<li>alt + Command + \，新建一个symbolic breakpoint。</li>
<li>Command + n新建文件 ，Shift + Command + n 新建工程。</li>
<li>alt + Command + 左\右 折叠\显示当前块。</li>
<li>Shift + alt + Command + 左\右 折叠\显示当前文件中的块。</li>
<li>alt + Command + [ 上移，如果没有选中，默认上移当前行，alt + Command + ] 下移。</li>
<li>Command + ] 向右缩进，支持多行，Command + [ 向左缩进。（类似Tab与shift+tab）。</li>
<li>Shift + Command + k product 清理；Command + r Run；Command + b 编译。</li>
</ul>
<h2 id="Xcode窗口控制"><a href="#Xcode窗口控制" class="headerlink" title="Xcode窗口控制"></a>Xcode窗口控制</h2><ul>
<li>Shift + Command + Y 隐藏\显示 console 区。</li>
<li>Shift + Command + C 显示 console 区，且直接聚焦。</li>
<li>Command + k console清屏。</li>
<li>Control + 1 （没用过&gt;,&lt;）。</li>
</ul>
<p><img src="/2019/05/23/Xcode开发效率-快捷键-代码块/a003.jpg" alt></p>
<ul>
<li>Control + 6 查看当前类的方法列表（可以用 pragma mark 来合理分块，查看更直观）。</li>
<li>Command + （1~9）切换左边窗体.Command + 0 显示 \ 隐藏左边窗体。</li>
<li>alt + Command + 0 显示 \ 隐藏右边窗体，同理alt + Command + 1,2等也可以切换。</li>
<li>Command + , 弹出 Perferences ,可以用 Command + w 隐藏。</li>
<li>Command + +(加号)/-(减号)，放大/缩小整体页面。与Web端一致。</li>
</ul>
<h2 id="Code-Snippet"><a href="#Code-Snippet" class="headerlink" title="Code Snippet"></a>Code Snippet</h2><blockquote>
<p>选中编写好的代码块，右击选择 Create Code Snippet</p>
</blockquote>
<p><img src="/2019/05/23/Xcode开发效率-快捷键-代码块/a004.png" alt></p>
<p><img src="/2019/05/23/Xcode开发效率-快捷键-代码块/a006.png" alt></p>
<h5 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明:"></a>参数说明:</h5><ul>
<li>Title: Code Snippet的名字,将作为主标题显示在列表中。</li>
<li>Summary: 说明,将作为副标题显示在列表中。</li>
<li>Platform: 平台,有All,iOS,watchOS,macOS和tvOS五个选项。</li>
<li>Language: 语言,有Objective-C,Swift等选项。</li>
<li>Completion Shortcut: 快捷键。</li>
<li>Completion Scopes: 匹配范围,比如说OC中一个类的代码块不该在另一个类中匹配出来,这样可以更加精确地匹配,这个选项可以多选。</li>
<li>代码: 这就不用多说,直接在代码模块修改,但是这里相当于纯文本,建议验证后再保存。</li>
</ul>
<blockquote>
<p>Command + shift + L 打开所有代码块。</p>
</blockquote>
<p><img src="/2019/05/23/Xcode开发效率-快捷键-代码块/a005.jpg" alt></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tips: 代码段中可以使用&lt;<span class="comment">#placeHolder#&gt;用于占位</span></span><br></pre></td></tr></table></figure>
<h3 id="补充Code-Snippet示例"><a href="#补充Code-Snippet示例" class="headerlink" title="补充Code Snippet示例"></a>补充Code Snippet示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//property</span><br><span class="line">@property (nonatomic, readwrite, strong) &lt;<span class="comment">#expression#&gt; *&lt;#expression#&gt;;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//UICollectionView </span><br><span class="line"><span class="comment">#pragma mark - UICollectionViewDataSource</span></span><br><span class="line">- (NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView &#123;</span><br><span class="line">    <span class="built_in">return</span> &lt;<span class="comment">#number#&gt;;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section &#123;</span><br><span class="line">    <span class="built_in">return</span> &lt;<span class="comment">#number#&gt;;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    UICollectionViewCell *cell = (UICollectionViewCell *)[collectionView dequeueReusableCellWithReuseIdentifier:@<span class="string">""</span> forIndexPath:indexPath];</span><br><span class="line">    <span class="built_in">return</span> cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">return</span> CGSizeMake(&lt;<span class="comment">#number#&gt;, &lt;#number#&gt;);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIEdgeInsets)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout insetForSectionAtIndex:(NSInteger)section</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">return</span> UIEdgeInsetsMake(&lt;<span class="comment">#number#&gt;, &lt;#number#&gt;, &lt;#number#&gt;, &lt;#number#&gt;);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#pragma mark - UICollectionViewDelegate</span></span><br><span class="line">- (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//attributeLabel</span><br><span class="line">UILabel *attributedLabel =[[UILabel alloc] init];</span><br><span class="line">attributedLabel.numberOfLines = 0;</span><br><span class="line">attributedLabel.preferredMaxLayoutWidth = &lt;<span class="comment">#preferredMaxLayoutWidth#&gt;;</span></span><br><span class="line">attributedLabel.backgroundColor = [UIColor clearColor];</span><br><span class="line">NSString *text = &lt;<span class="comment">#text#&gt;;</span></span><br><span class="line">NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];</span><br><span class="line">style.lineSpacing = &lt;<span class="comment">#lineSpacing#&gt;;</span></span><br><span class="line">NSDictionary *attr = @&#123;</span><br><span class="line">					NSFontAttributeName: [UIFont &lt;<span class="comment">#font#&gt;],</span></span><br><span class="line">                   	NSParagraphStyleAttributeName: style,</span><br><span class="line">                   	NSForegroundColorAttributeName: [UIColor &lt;<span class="comment">#color#&gt;]</span></span><br><span class="line">                   	&#125;;</span><br><span class="line">attributedLabel.attributedText = [[NSAttributedString alloc] initWithString:text attributes:attr];</span><br><span class="line">[&lt;<span class="comment">#view#&gt; addSubview:attributedLabel];</span></span><br></pre></td></tr></table></figure>
<h2 id="Xcode插件"><a href="#Xcode插件" class="headerlink" title="Xcode插件"></a>Xcode插件</h2><p>略（待补充）</p>
<h2 id="Simlulater"><a href="#Simlulater" class="headerlink" title="Simlulater"></a>Simlulater</h2><p>略（待补充）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jackthenoob.github.io/2019/05/23/修改-gitignoe文件后如何生效/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="垂杨小梳雨">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lyddwn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/23/修改-gitignoe文件后如何生效/" itemprop="url">修改.gitignoe文件后如何生效</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-23T11:02:09+08:00">
                2019-05-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/git/" itemprop="url" rel="index">
                    <span itemprop="name">git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached .  <span class="comment">#清除缓存  </span></span><br><span class="line">git add . <span class="comment">#重新trace file  </span></span><br><span class="line">git commit -m <span class="string">"update .gitignore"</span> <span class="comment">#提交和注释</span></span><br></pre></td></tr></table></figure>
<p>总来来说，移除本地缓存，重新添加trace文件。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jackthenoob.github.io/2019/05/22/使用-访问实例对象成员变量Crash问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="垂杨小梳雨">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lyddwn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/22/使用-访问实例对象成员变量Crash问题/" itemprop="url">使用->访问实例对象成员变量Crash问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-22T21:10:05+08:00">
                2019-05-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h6 id="最近线上发生了一个Crash。根据栈信息定位到如下代码"><a href="#最近线上发生了一个Crash。根据栈信息定位到如下代码" class="headerlink" title="最近线上发生了一个Crash。根据栈信息定位到如下代码"></a>最近线上发生了一个Crash。根据栈信息定位到如下代码</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXC_BAD_ACCESS (SIGBUS)</span><br><span class="line">Attempted to dereference garbage pointer 0x10. Originated at or <span class="keyword">in</span> a subcall of WebViewJavascriptBridge_js</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (instance-&gt;ivar) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="就是访问成员变量时Crash。"><a href="#就是访问成员变量时Crash。" class="headerlink" title="就是访问成员变量时Crash。"></a>就是访问成员变量时Crash。</h6><h6 id="难道instance可能为空，但是为空应该也不会Crash吧？因为在我的固有的思维里面，对nil发送消息并不会crash。"><a href="#难道instance可能为空，但是为空应该也不会Crash吧？因为在我的固有的思维里面，对nil发送消息并不会crash。" class="headerlink" title="难道instance可能为空，但是为空应该也不会Crash吧？因为在我的固有的思维里面，对nil发送消息并不会crash。"></a>难道instance可能为空，但是为空应该也不会Crash吧？因为在我的固有的思维里面，对nil发送消息并不会crash。</h6><h5 id="但是又仔细想了想，访问成员变量时，是通过当前类的实例对象偏移量再加上此变量在类中的偏移量获取的。与发送消息无关（不是属性，没有写get方法）。如果当前实例对象如果为空（obj的offet-0），为什么还会继续呢？百思不得解。"><a href="#但是又仔细想了想，访问成员变量时，是通过当前类的实例对象偏移量再加上此变量在类中的偏移量获取的。与发送消息无关（不是属性，没有写get方法）。如果当前实例对象如果为空（obj的offet-0），为什么还会继续呢？百思不得解。" class="headerlink" title="但是又仔细想了想，访问成员变量时，是通过当前类的实例对象偏移量再加上此变量在类中的偏移量获取的。与发送消息无关（不是属性，没有写get方法）。如果当前实例对象如果为空（obj的offet=0），为什么还会继续呢？百思不得解。"></a>但是又仔细想了想，访问成员变量时，是通过当前类的实例对象偏移量再加上此变量在类中的偏移量获取的。与发送消息无关（不是属性，没有写get方法）。如果当前实例对象如果为空（obj的offet=0），为什么还会继续呢？百思不得解。</h5><h5 id="写了一个demo，使用clang命令转换为cpp文件后，才知道缘由。"><a href="#写了一个demo，使用clang命令转换为cpp文件后，才知道缘由。" class="headerlink" title="写了一个demo，使用clang命令转换为cpp文件后，才知道缘由。"></a>写了一个demo，使用clang命令转换为cpp文件后，才知道缘由。</h5><h5 id="大体代码如下："><a href="#大体代码如下：" class="headerlink" title="大体代码如下："></a>大体代码如下：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//MyObject.h</span><br><span class="line">@interface MyObject : NSObject &#123;</span><br><span class="line">    @public</span><br><span class="line">    NSString    *_strObject;</span><br><span class="line">    NSArray     *_arrList;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//Test.h</span><br><span class="line">@implementation Test</span><br><span class="line"></span><br><span class="line">- (void)helloworld &#123;</span><br><span class="line">    MyObject *obj = nil;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        obj = [MyObject new];</span><br><span class="line">    &#125;</span><br><span class="line">    NSString *str = obj-&gt;_strObject;</span><br><span class="line">    NSLog(@<span class="string">"%@"</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc Test.m</span><br></pre></td></tr></table></figure>
<h6 id="通过clang命令获取Test-cpp文件（10万行左右）"><a href="#通过clang命令获取Test-cpp文件（10万行左右）" class="headerlink" title="通过clang命令获取Test.cpp文件（10万行左右）"></a>通过clang命令获取Test.cpp文件（10万行左右）</h6><h6 id="在后面看到如下片段"><a href="#在后面看到如下片段" class="headerlink" title="在后面看到如下片段"></a>在后面看到如下片段</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pragma clang assume_nonnull end</span></span><br><span class="line">// @implementation Test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void _I_Test_helloworld(Test * self, SEL _cmd) &#123;</span><br><span class="line">    MyObject *obj = __null;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        obj = ((MyObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(<span class="string">"MyObject"</span>), sel_registerName(<span class="string">"new"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    NSString *str = (*(NSString **)((char *)obj + OBJC_IVAR_<span class="variable">$_MyObject</span><span class="variable">$_strObject</span>));</span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_hs_pl2pwmlj27g9xt0wlb9mbdbh0000gn_T_Test_2546e4_mi_0, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// @end</span><br></pre></td></tr></table></figure>
<h5 id="主要下这行代码"><a href="#主要下这行代码" class="headerlink" title="主要下这行代码"></a>主要下这行代码</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = (*(NSString **)((char *)obj + OBJC_IVAR_<span class="variable">$_MyObject</span><span class="variable">$_strObject</span>));</span><br></pre></td></tr></table></figure>
<h6 id="这段代码就是获取-strObject偏移量，OBJC-IVAR-MyObject-strObject是一个在编译器已经决定了的固定的偏移量。obj就是实例对象的首地址。通过2个值获取到-strObject地址。如果obj-nil-这个偏移地址就是一个固定的值0，加上变量固定偏移量，值就类似于0x10-这也和crash信息里相匹配-。"><a href="#这段代码就是获取-strObject偏移量，OBJC-IVAR-MyObject-strObject是一个在编译器已经决定了的固定的偏移量。obj就是实例对象的首地址。通过2个值获取到-strObject地址。如果obj-nil-这个偏移地址就是一个固定的值0，加上变量固定偏移量，值就类似于0x10-这也和crash信息里相匹配-。" class="headerlink" title="这段代码就是获取_strObject偏移量，OBJC_IVAR_$_MyObject$_strObject是一个在编译器已经决定了的固定的偏移量。obj就是实例对象的首地址。通过2个值获取到_strObject地址。如果obj==nil;这个偏移地址就是一个固定的值0，加上变量固定偏移量，值就类似于0x10(这也和crash信息里相匹配)。"></a>这段代码就是获取_strObject偏移量，OBJC_IVAR_$_MyObject$_strObject是一个在编译器已经决定了的固定的偏移量。obj就是实例对象的首地址。通过2个值获取到_strObject地址。如果obj==nil;这个偏移地址就是一个固定的值0，加上变量固定偏移量，值就类似于0x10(这也和crash信息里相匹配)。</h6><hr>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><blockquote>
<p>通过-&gt;访问成员变量要判断当前变量是否为空。通过offset寻址成员变量时并不会多一层为空判断逻辑。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jackthenoob.github.io/2019/05/21/Swift学习笔记-一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="垂杨小梳雨">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lyddwn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/21/Swift学习笔记-一/" itemprop="url">Swift学习笔记(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-21T11:21:00+08:00">
                2019-05-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/swift/" itemprop="url" rel="index">
                    <span itemprop="name">swift</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>Swift是一种支持多编程范式、安全、快速和互动的跨平台编译式编程语言。且编译器对性能进行了优化，编程语言对开发进行了优化，两者互不干扰，鱼与熊掌兼得。它支持代码预览（playgrounds），这个革命性的特性可以允许程序员在不编译和运行应用程序的前提下运行 Swift 代码并实时查看结果。</p>
<h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><ul>
<li>2010年7月，苹果开发者工具部门总监克里斯·拉特纳开始着手 Swift 编程语言的设计工作，以一年时间，完成基本架构后，他领导了一个设计团队大力参与其中。</li>
<li>2014年6月发表， Swift大约历经4年的开发期。苹果宣称Swift的特点是：快速、现代、安全、互动，而且明显优于Objective-C语言。Swift以LLVM编译，可以使用现有的Cocoa和Cocoa Touch框架。Xcode Playgrounds功能是Swift为苹果开发工具带来的最大创新，该功能提供强大的互动效果，能让Swift源代码在撰写过程中能即时显示出其运行结果。拉特纳本人强调，Playgrounds很大程度是受到布雷特·维克多理念的启发。</li>
<li>2015年6月8日，苹果于WWDC2015上宣布，Swift将开放源代码，包括编译器和标准库。</li>
<li>2015年12月3日，苹果宣布开源swift，并支持Linux，苹果在新网站swift.org和托管网站Github上开源了swift，但苹果的app store并不支持开源的swift，只支持苹果官方的swift版本，官方版本会在新网站swift.org上定期与开源版本同步。</li>
</ul>
<p><a href="https://swiftgg.gitbook.io/swift/huan-ying-shi-yong-swift/04_revision_history" target="_blank" rel="noopener">Swift历史版本</a></p>
<ul>
<li>2019-01-24 Swift 5.0 更新</li>
<li>2018-09-17 Swift 4.2 更新</li>
<li>2018-03-29 Swift 4.1 更新</li>
<li>2017-12-04 Swift 4.0.3 更新</li>
<li>2017-09-19 Swift 4.0 更新</li>
<li>2017-03-27 Swift 3.1 更新</li>
<li>2016-10-27 Swift 3.0.1 更新</li>
<li>2016-09-13 Swift 3.0 更新</li>
<li>2016-03-21 Swift 2.2 更新</li>
<li>2015-10-20 Swift 2.1 更新</li>
<li>2015-09-16 Swift 2.0 更新</li>
<li>2015-4-8 Swift 1.2 更新</li>
<li>2014-10-16 Swift 1.1 更新</li>
<li>2014-08-18 Swift 1.0 更新 </li>
</ul>
<p>Swift 是一门开发 iOS, macOS, watchOS 和 tvOS 应用的新语言。然而，如果你有 C 或者 Objective-C 开发经验的话，你会发现 Swift 的很多内容都是你熟悉的。</p>
<p>下面通过Swift与Objective-C/C对比来介绍这门语言。</p>
<h2 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h2><h3 id="基本数值类型（numeric-types）"><a href="#基本数值类型（numeric-types）" class="headerlink" title="基本数值类型（numeric types）"></a>基本数值类型（numeric types）</h3><p>Swift 包含了 C 和 Objective-C 上所有基础数据类型</p>
<p>Int 表示整型值； Double 和 Float 表示浮点型值； Bool 是布尔型值；String 是文本型数据。</p>
<p>Swift 还提供了三个基本的集合类型，Array、Set 和 Dictionary。类似OC中NSArray、NSMutableArray、NSSet、NSMutableSet、NSDictionary、NSMutableDictionary。</p>
<blockquote>
<p>值类型(Value Type)&amp;引用类型(Reference Type)  </p>
<p>内存（RAM）中有两个区域，栈区（stack）和堆区（heap）。在 Swift 中，值类型，存放在栈区；引用类型，存放在堆区。  </p>
<p> 在 Swift 中，典型的有 struct，enum，以及 tuples(元组) 都是值类型。而平时使用的 Int， Double，Float，String，Array，Dictionary，Set 其实都是用结构体实现的，也是值类型。详见下面代码</p>
<p>在 Swift 中，class 和闭包是引用类型。  </p>
<p>而在Objective-C中，除了基本数据类型、结构体等，其他都是引用类型。</p>
</blockquote>
<p>*</p>
<blockquote>
<p>注意<br><br>标准库定义的集合，例如数组，字典和字符串，都对复制进行了优化以降低性能成本。新集合不会立即复制，而是跟原集合共享同一份内存，共享同样的元素。在集合的某个副本要被修改前，才会复制它的元素。而你在代码中看起来就像是立即发生了复制。即Copy On Write。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public struct Int : FixedWidthInteger, SignedInteger &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="元组-tuples"><a href="#元组-tuples" class="headerlink" title="元组(tuples)"></a>元组(tuples)</h3><p>元组（tuples）把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。这在Objective-C中是没有的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> http404Error = (404, <span class="string">"Not Found"</span>)</span><br><span class="line">// http404Error 的类型是 (Int, String)，值是 (404, <span class="string">"Not Found"</span>)</span><br><span class="line"><span class="built_in">let</span> (statusCode, statusMessage) = http404Error</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The status code is \(statusCode)"</span>)</span><br><span class="line">// 输出“The status code is 404”</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The status message is \(statusMessage)"</span>)</span><br><span class="line">// 输出“The status message is Not Found”</span><br></pre></td></tr></table></figure>
<p>(404, “Not Found”) 元组把一个 Int 值和一个 String 值组合起来表示 HTTP 状态码的两个部分：一个数字和一个人类可读的描述。这个元组可以被描述为“一个类型为 (Int, String) 的元组”。 如果函数需要返回多个值，是一个不错的应用场景。</p>
<h3 id="类型安全"><a href="#类型安全" class="headerlink" title="类型安全"></a>类型安全</h3><p>Swift 是一门类型安全的语言，这意味着 Swift 可以让你清楚地知道值的类型。如果你的代码需要一个 String ，类型安全会阻止你不小心传入一个 Int 。而在OC中则不然。</p>
<h3 id="常量-amp-变量"><a href="#常量-amp-变量" class="headerlink" title="常量&amp;变量"></a>常量&amp;变量</h3><blockquote>
<p>   var - 声明变量。<br>   let - 声明变量。  </p>
</blockquote>
<h3 id="类型标注"><a href="#类型标注" class="headerlink" title="类型标注"></a>类型标注</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var welcomeMessage: String = <span class="string">"hello world!"</span>;</span><br><span class="line">var welcomeMessage = <span class="string">"hello world!"</span>;</span><br></pre></td></tr></table></figure>
<p>声明一个类型为 String ，名字为 welcomeMessage 的变量。</p>
<blockquote>
<p>如果你在声明常量或者变量的时候赋了一个初始值，Swift 可以推断出这个常量或者变量的类型。  </p>
</blockquote>
<h3 id="常量和变量的命名"><a href="#常量和变量的命名" class="headerlink" title="常量和变量的命名"></a>常量和变量的命名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var x = 0.0, y = 0.0;</span><br><span class="line"><span class="built_in">let</span> z = 0.0;</span><br><span class="line"><span class="built_in">let</span> 你好 = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">let</span> 🐶🐮 = <span class="string">"emoj-dog&amp;cat"</span>;</span><br></pre></td></tr></table></figure>
<p>上面例子可以看出，常量和变量名可以包含任何字符，包括 Unicode 字符。</p>
<h3 id="输出常量和变量"><a href="#输出常量和变量" class="headerlink" title="输出常量和变量"></a>输出常量和变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//swift</span><br><span class="line">// 输出“The current value of friendlyWelcome is hello world!”</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The current value of welcomeMessage is \(welcomeMessage)"</span>)</span><br><span class="line">//iOS</span><br><span class="line">NSLog(<span class="string">"%@"</span>, welcomeMessage);</span><br></pre></td></tr></table></figure>
<h3 id="可选类型-nil-强制解析"><a href="#可选类型-nil-强制解析" class="headerlink" title="可选类型 | nil | 强制解析"></a>可选类型 | nil | 强制解析</h3><p>使用可选类型（optionals）来处理值可能缺失的情况。可选类型表示两种可能： 或者有值， 你可以解析可选类型访问这个值， 或者根本没有值。</p>
<blockquote>
<p>注意  </p>
<p>C 和 Objective-C 中并没有可选类型这个概念。最接近的是 Objective-C 中的一个特性，一个方法要不返回一个对象要不返回 nil，nil 表示“缺少一个合法的对象”。然而，这只对对象起作用——对于结构体，基本的 C 类型或者枚举类型不起作用。对于这些类型，Objective-C 方法一般会返回一个特殊值（比如 NSNotFound）来暗示值缺失。这种方法假设方法的调用者知道并记得对特殊值进行判断。然而，Swift 的可选类型可以让你暗示任意类型的值缺失，并不需要一个特殊值。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> possibleNumber = <span class="string">"123"</span></span><br><span class="line"><span class="built_in">let</span> convertedNumber = Int(possibleNumber)</span><br><span class="line">// convertedNumber 被推测为类型 <span class="string">"Int?"</span>， 或者类型 <span class="string">"optional Int"</span></span><br></pre></td></tr></table></figure>
<p>因为该构造器可能会失败，所以它返回一个可选类型（optional）Int，而不是一个 Int。</p>
<p>nil：你可以给可选变量赋值为 nil 来表示它没有值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var serverResponseCode: Int? = 404</span><br><span class="line">// serverResponseCode 包含一个可选的 Int 值 404</span><br><span class="line">serverResponseCode = nil</span><br><span class="line">// serverResponseCode 现在不包含值</span><br><span class="line">var surveyAnswer: String?</span><br><span class="line">// surveyAnswer 被自动设置为 nil</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意  </p>
<p>nil 不能用于非可选的常量和变量。如果你的代码中有常量或者变量需要处理值缺失的情况，请把它们声明成对应的可选类型。</p>
<p>Swift 的 nil 和 Objective-C 中的 nil 并不一样。在 Objective-C 中，nil 是一个指向不存在对象的指针。在 Swift 中，nil 不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为 nil，不只是对象类型。</p>
</blockquote>
<p><img src="/2019/05/21/Swift学习笔记-一/nonoptionalvalueError.jpg" alt></p>
<h4 id="可选绑定"><a href="#可选绑定" class="headerlink" title="可选绑定"></a>可选绑定</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//如果 Int(possibleNumber) 返回的可选 Int 包含一个值，创建一个叫做 actualNumber 的新常量并将可选包含的值赋给它。</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">let</span> actualNumber = Int(possibleNumber) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\'\(possibleNumber)\' has an integer value of \(actualNumber)"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\'\(possibleNumber)\' could not be converted to an integer"</span>)</span><br><span class="line">&#125;</span><br><span class="line">// 输出“<span class="string">'123'</span> has an <span class="built_in">integer</span> value of 123”</span><br></pre></td></tr></table></figure>
<h4 id="强制解析"><a href="#强制解析" class="headerlink" title="强制解析"></a>强制解析</h4><p>有时候在程序架构中，第一次被赋值之后，可以确定一个可选类型总会有值。在这种情况下，每次都要判断和解析可选值是非常低效的，因为可以确定它总会有值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> possibleString: String? = <span class="string">"An optional string."</span></span><br><span class="line"><span class="built_in">let</span> forcedString: String = possibleString! // 需要感叹号来获取值</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> assumedString: String! = <span class="string">"An implicitly unwrapped optional string."</span></span><br><span class="line"><span class="built_in">let</span> implicitString: String = assumedString  // 不需要感叹号</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意  </p>
<p>如果你在隐式解析可选类型没有值的时候尝试取值，会触发运行时错误。和你在没有值的普通可选类型后面加一个惊叹号一样。</p>
</blockquote>
<hr>
<h2 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h2><blockquote>
<p>这里只介绍OC中没有的运算符</p>
</blockquote>
<h3 id="区间运算符"><a href="#区间运算符" class="headerlink" title="区间运算符"></a>区间运算符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//[a,b] a&lt; b</span><br><span class="line">(a...b)</span><br><span class="line">//[a,b) a&lt;b</span><br><span class="line">(a..&lt;b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> 1...5 &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(index) * 5 = \(index * 5)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运算符重载（略）"><a href="#运算符重载（略）" class="headerlink" title="运算符重载（略）"></a>运算符重载（略）</h3><h3 id="字符串和字符"><a href="#字符串和字符" class="headerlink" title="字符串和字符"></a>字符串和字符</h3><blockquote>
<p>Swift 的 String 类型与 Foundation NSString 类进行了无缝桥接。Foundation 还对 String 进行扩展使其可以访问 NSString 类型中定义的方法。这意味着调用那些 NSString 的方法，你无需进行任何类型转换。</p>
</blockquote>
<h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>增删改、下标访问等</p>
<h4 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h4><p>Objective-C（NSString）</p>
<p>NSString对象是用 UTF-16 编码的码元组成的数组。相应地，length 方法的返回值也是字符串包含的码元个数（而不是字符个数）。</p>
<h4 id="Swift（String）"><a href="#Swift（String）" class="headerlink" title="Swift（String）"></a>Swift（String）</h4><p>每一个字符串都是由编码无关的 Unicode 字符组成。Swift 中通过多种 “View” 来区分处理字符串的方式，UTF8View 让你以 UTF-8 编码的方式来处理字符串，而 CharacterView 则让你以字符为单位处理字符串而不必考虑编码的问题。</p>
<p><img src="/2019/05/21/Swift学习笔记-一/uft-8_print.jpg" alt></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> codeUnit <span class="keyword">in</span> dogString.utf8 &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(codeUnit) "</span>, terminator: <span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">""</span>)</span><br><span class="line">// 68 111 103 226 128 188 240 159 144 182</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/21/Swift学习笔记-一/uft-16_print.jpg" alt></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> codeUnit <span class="keyword">in</span> dogString.utf16 &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(codeUnit) "</span>, terminator: <span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">""</span>)</span><br><span class="line">// 68 111 103 8252 55357 56374</span><br></pre></td></tr></table></figure>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>Swift 语言中的 Arrays、Sets 和 Dictionaries 中存储的数据值类型必须明确，即被现实为泛型集合。而Objective-C没有这样的要求（只要求存储的为对象）。</p>
<h3 id="数组-Arrays"><a href="#数组-Arrays" class="headerlink" title="数组(Arrays)"></a>数组(Arrays)</h3><h4 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//swift </span><br><span class="line">var shoppingList = [String]()</span><br><span class="line">var shoppingList: [String] = [<span class="string">"Eggs"</span>, <span class="string">"Milk"</span>]</span><br><span class="line">//...其他方法</span><br><span class="line">//OC 类似泛型的功能</span><br><span class="line">NSMutableArray &lt;NSString *&gt; *shoppingList = [NSMutableArray arrayWithArray:@[@<span class="string">"Eggs"</span>, @<span class="string">"Milk"</span>]];</span><br></pre></td></tr></table></figure>
<h4 id="修改数组"><a href="#修改数组" class="headerlink" title="修改数组"></a>修改数组</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//添加元素</span><br><span class="line">//swift</span><br><span class="line">shoppingList.insert(<span class="string">"Maple Syrup"</span>, at: 0)</span><br><span class="line">shoppingList.append(<span class="string">"Flour"</span>)</span><br><span class="line">//OC</span><br><span class="line">[shoppingList addObject:@<span class="string">"Flour"</span>];</span><br><span class="line">[shoppingList addObject:@<span class="string">"Flour"</span> atIndex:0];</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//添加数组</span><br><span class="line">//swift</span><br><span class="line">shoppingList += [<span class="string">"Chocolate Spread"</span>, <span class="string">"Cheese"</span>, <span class="string">"Butter"</span>];</span><br><span class="line">//OC</span><br><span class="line">[shoppingList addObjectFromArray:[<span class="string">"Chocolate Spread"</span>, <span class="string">"Cheese"</span>, <span class="string">"Butter"</span>]];</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//修改数组</span><br><span class="line">//swift</span><br><span class="line">shoppingList[0] = <span class="string">"Six eggs"</span></span><br><span class="line">shoppingList[4...6] = [<span class="string">"Bananas"</span>, <span class="string">"Apples"</span>]</span><br><span class="line">//OC</span><br><span class="line">shoppingList[0] = @<span class="string">"Six eggs"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//移除元素</span><br><span class="line">//swift</span><br><span class="line">shoppingList.remove(at:0);</span><br><span class="line">//OC</span><br><span class="line">[shoppingList removeObjectAtIndex:0];</span><br></pre></td></tr></table></figure>
<h4 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h4><p>如果我们同时需要每个数据项的值和索引值，可以使用 enumerated() 方法来进行数组遍历。enumerated() 返回一个由每一个数据项索引值和数据值组成的元组。我们可以把这个元组分解成临时常量或者变量来进行遍历：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (index, value) <span class="keyword">in</span> shoppingList.<span class="function"><span class="title">enumerated</span></span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Item \(String(index + 1)): \(value)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="集合-Sets"><a href="#集合-Sets" class="headerlink" title="集合(Sets)"></a>集合(Sets)</h3><blockquote>
<p>   Q:集合和数组的区别？</p>
</blockquote>
<p>集合（Set）用来存储相同类型并且没有确定顺序的值。当集合元素顺序不重要时或者希望确保每个元素只出现一次时可以使用集合而不是数组。</p>
<p>存储在集合中的类型，必须是可哈希化的。遵循协议Hashable。</p>
<h4 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h4><p><img src="/2019/05/21/Swift学习笔记-一/set_operation.png" alt></p>
<blockquote>
<p>使用 intersection(<em>:) 方法根据两个集合中都包含的值创建的一个新的集合。<br>使用 symmetricDifference(</em>:) 方法根据在一个集合中但不在两个集合中的值创建一个新的集合。<br>使用 union(<em>:) 方法根据两个集合的值创建一个新的集合。<br>使用 subtracting(</em>:) 方法根据不在该集合中的值创建一个新的集合。</p>
</blockquote>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>Swift 的字典使用 Dictionary&lt;Key, Value&gt; 定义，其中 Key 是字典中键的数据类型，Value 是字典中对应于这些键所存储值的数据类型。</p>
<blockquote>
<p>一个字典的 Key 类型必须遵循 Hashable 协议，就像 Set 的值类型。</p>
<p>Objective-C中NSDictionary的key必须是字符串。<br>Objective-C中NSDictionary对存储的Value类型一致性没有要求。但只能存储对象。</p>
</blockquote>
<h4 id="字典创建"><a href="#字典创建" class="headerlink" title="字典创建"></a>字典创建</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//swift</span><br><span class="line">var namesOfIntegers = [Int: String]()</span><br><span class="line">// namesOfIntegers 是一个空的 [Int: String] 字典</span><br><span class="line">//OC</span><br><span class="line">NSDictionary  *namesOfIntegers = [NSDictionary dictionary];</span><br></pre></td></tr></table></figure>
<h4 id="访问-amp-修改字典"><a href="#访问-amp-修改字典" class="headerlink" title="访问&amp;修改字典"></a>访问&amp;修改字典</h4><p>基本一致</p>
<h4 id="字典遍历"><a href="#字典遍历" class="headerlink" title="字典遍历"></a>字典遍历</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//swift</span><br><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> namesOfIntegers &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(key): \(value)"</span>)</span><br><span class="line">&#125;</span><br><span class="line">//OC</span><br><span class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> namesOfIntegers.allKeys) &#123;</span><br><span class="line">	//key is NSString object</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (value <span class="keyword">in</span> namesOfIntegers.allValues) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="for-int"><a href="#for-int" class="headerlink" title="for-int"></a>for-int</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> names = [<span class="string">"Anna"</span>, <span class="string">"Alex"</span>, <span class="string">"Brian"</span>, <span class="string">"Jack"</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello, \(name)!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">// Hello, Anna!</span><br><span class="line">// Hello, Alex!</span><br><span class="line">// Hello, Brian!</span><br><span class="line">// Hello, Jack!</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> 1...5 &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(index) times 5 is \(index * 5)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//忽略变量值</span><br><span class="line"><span class="built_in">let</span> base = 3</span><br><span class="line"><span class="built_in">let</span> power = 10</span><br><span class="line">var answer = 1</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> 1...power &#123;</span><br><span class="line">    answer *= base</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(base) to the power of \(power) is \(answer)"</span>)</span><br><span class="line">// 输出“3 to the power of 10 is 59049”</span><br></pre></td></tr></table></figure>
<h3 id="While"><a href="#While" class="headerlink" title="While"></a>While</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Repeat-While"><a href="#Repeat-While" class="headerlink" title="Repeat-While"></a>Repeat-While</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">repeat &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; <span class="keyword">while</span> condition</span><br></pre></td></tr></table></figure>
<h3 id="if条件语句"><a href="#if条件语句" class="headerlink" title="if条件语句"></a>if条件语句</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition &lt;= 0 &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It's very cold. Consider wearing a scarf."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It's not that cold. Wear a t-shirt."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">switch some value to consider &#123;</span><br><span class="line"><span class="keyword">case</span> value 1:</span><br><span class="line">    respond to value 1</span><br><span class="line"><span class="keyword">case</span> value 2,</span><br><span class="line">    value 3:</span><br><span class="line">    respond to value 2 or 3</span><br><span class="line">default:</span><br><span class="line">    otherwise, <span class="keyword">do</span> something <span class="keyword">else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="不存在隐式的贯穿"><a href="#不存在隐式的贯穿" class="headerlink" title="不存在隐式的贯穿"></a>不存在隐式的贯穿</h4><p>与 C 和 Objective-C 中的 switch 语句不同，在 Swift 中，当匹配的 case 分支中的代码执行完毕后，程序会终止 switch 语句，而不会继续执行下一个 case 分支。这也就是说，不需要在 case 分支中显式地使用 break 语句。这使得 switch 语句更安全、更易用，也避免了漏写 break 语句导致多个语言被执行的错误。</p>
<blockquote>
<p>注意 : 如果想要显式贯穿 case 分支，请使用 fallthrough 语句。</p>
</blockquote>
<h4 id="区间匹配"><a href="#区间匹配" class="headerlink" title="区间匹配"></a>区间匹配</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> approximateCount = 62</span><br><span class="line"><span class="built_in">let</span> countedThings = <span class="string">"moons orbiting Saturn"</span></span><br><span class="line"><span class="built_in">let</span> naturalCount: String</span><br><span class="line">switch approximateCount &#123;</span><br><span class="line"><span class="keyword">case</span> 0:</span><br><span class="line">    naturalCount = <span class="string">"no"</span></span><br><span class="line"><span class="keyword">case</span> 1..&lt;5:</span><br><span class="line">    naturalCount = <span class="string">"a few"</span></span><br><span class="line"><span class="keyword">case</span> 5..&lt;12:</span><br><span class="line">    naturalCount = <span class="string">"several"</span></span><br><span class="line"><span class="keyword">case</span> 12..&lt;100:</span><br><span class="line">    naturalCount = <span class="string">"dozens of"</span></span><br><span class="line"><span class="keyword">case</span> 100..&lt;1000:</span><br><span class="line">    naturalCount = <span class="string">"hundreds of"</span></span><br><span class="line">default:</span><br><span class="line">    naturalCount = <span class="string">"many"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"There are \(naturalCount) \(countedThings)."</span>)</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><blockquote>
<p>Swift拥有比Objective-C更强大的函数功能。</p>
</blockquote>
<ul>
<li>多重返回值</li>
<li>默认参数值</li>
<li>可变参数</li>
<li>使用函数作为参数</li>
<li>使用函数作为返回类型</li>
</ul>
<h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func greet(person: String) -&gt; String &#123;</span><br><span class="line">    <span class="built_in">let</span> greeting = <span class="string">"Hello, "</span> + person + <span class="string">"!"</span></span><br><span class="line">    <span class="built_in">return</span> greeting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数调用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> greeting = greet(person: <span class="string">"Anna"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="多重返回值-amp-amp-可选返回类型"><a href="#多重返回值-amp-amp-可选返回类型" class="headerlink" title="多重返回值 &amp;&amp; 可选返回类型"></a>多重返回值 &amp;&amp; 可选返回类型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func minMax(array: [Int]) -&gt; (min: Int, max: Int)? &#123;</span><br><span class="line">    <span class="keyword">if</span> array.isEmpty &#123; <span class="built_in">return</span> nil &#125;</span><br><span class="line">    var currentMin = array[0]</span><br><span class="line">    var currentMax = array[0]</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> array[1..&lt;array.count] &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; currentMin &#123;</span><br><span class="line">            currentMin = value</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; currentMax &#123;</span><br><span class="line">            currentMax = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> (currentMin, currentMax)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>OC 可以通过字典返、结构体、Model回多重值。</p>
</blockquote>
<p>*</p>
<blockquote>
<p>函数返回一个包含两个 Int 值的元组，这些值被标记为 min 和 max ，以便查询函数的返回值时可以通过名字访问它们。</p>
</blockquote>
<h3 id="指定-忽略参数标签"><a href="#指定-忽略参数标签" class="headerlink" title="指定/忽略参数标签"></a>指定/忽略参数标签</h3><blockquote>
<p>可以在参数名称前指定它的参数标签，中间以空格分隔：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func someFunction(argumentLabel parameterName: Int) &#123;</span><br><span class="line">    // 在函数体内，parameterName 代表参数值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func greet(person: String, from hometown: String) -&gt; String &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">"Hello \(person)!  Glad you could visit from \(hometown)."</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(greet(person: <span class="string">"Bill"</span>, from: <span class="string">"Cupertino"</span>))</span><br><span class="line">// 打印“Hello Bill!  Glad you could visit from Cupertino.”</span><br></pre></td></tr></table></figure>
<blockquote>
<p>OC 没有可比性</p>
</blockquote>
<p>如果你不希望为某个参数添加一个标签，可以使用一个下划线（_）来代替一个明确的参数标签。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func someFunction(_ firstParameterName: Int, secondParameterName: Int) &#123;</span><br><span class="line">     // 在函数体内，firstParameterName 和 secondParameterName 代表参数中的第一个和第二个参数值</span><br><span class="line">&#125;</span><br><span class="line">someFunction(1, secondParameterName: 2)</span><br></pre></td></tr></table></figure>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>你可以在函数体中通过给参数赋值来为任意一个参数定义默认值（Deafult Value）。当默认值被定义后，调用这个函数时可以忽略这个参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func someFunction(parameterWithoutDefault: Int, parameterWithDefault: Int = 12) &#123;</span><br><span class="line">    // 如果你在调用时候不传第二个参数，parameterWithDefault 会值为 12 传入到函数体中。</span><br><span class="line">&#125;</span><br><span class="line">someFunction(parameterWithoutDefault: 3, parameterWithDefault: 6) // parameterWithDefault = 6</span><br><span class="line">someFunction(parameterWithoutDefault: 4) // parameterWithDefault = 12</span><br></pre></td></tr></table></figure>
<blockquote>
<p>OC 不支持</p>
</blockquote>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>一个可变参数（variadic parameter）可以接受零个或多个值。函数调用时，你可以用可变参数来指定函数参数可以被传入不确定数量的输入值。通过在变量类型名后面加入（…）的方式来定义可变参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func arithmeticMean(_ numbers: Double...) -&gt; Double &#123;</span><br><span class="line">    var total: Double = 0</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        total += number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> total / Double(numbers.count)</span><br><span class="line">&#125;</span><br><span class="line">arithmeticMean(1, 2, 3, 4, 5)</span><br><span class="line">// 返回 3.0, 是这 5 个数的平均数。</span><br><span class="line">arithmeticMean(3, 8.25, 18.75)</span><br><span class="line">// 返回 10.0, 是这 3 个数的平均数。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>OC 通过数组实现</p>
</blockquote>
<h3 id="函数类型作为参数类型"><a href="#函数类型作为参数类型" class="headerlink" title="函数类型作为参数类型"></a>函数类型作为参数类型</h3><p>你可以用 (Int, Int) -&gt; Int 这样的函数类型作为另一个函数的参数类型。这样你可以将函数的一部分实现留给函数的调用者来提供。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func printMathResult(_ mathFunction: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Result: \(mathFunction(a, b))"</span>)</span><br><span class="line">&#125;</span><br><span class="line">printMathResult(addTwoInts, 3, 5)</span><br><span class="line">// 打印“Result: 8”</span><br></pre></td></tr></table></figure>
<h3 id="函数类型作为返回类型"><a href="#函数类型作为返回类型" class="headerlink" title="函数类型作为返回类型"></a>函数类型作为返回类型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func stepForward(_ input: Int) -&gt; Int &#123;</span><br><span class="line">    <span class="built_in">return</span> input + 1</span><br><span class="line">&#125;</span><br><span class="line">func stepBackward(_ input: Int) -&gt; Int &#123;</span><br><span class="line">    <span class="built_in">return</span> input - 1</span><br><span class="line">&#125;</span><br><span class="line">func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int &#123;</span><br><span class="line">    <span class="built_in">return</span> backward ? stepBackward : stepForward</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var currentValue = 3</span><br><span class="line"><span class="built_in">let</span> moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)</span><br><span class="line">// moveNearerToZero 现在指向 stepBackward() 函数。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数功能和其他函数式编程差不多，比如JS。</p>
</blockquote>
<h3 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int &#123;</span><br><span class="line">    func stepForward(input: Int) -&gt; Int &#123; <span class="built_in">return</span> input + 1 &#125;</span><br><span class="line">    func stepBackward(input: Int) -&gt; Int &#123; <span class="built_in">return</span> input - 1 &#125;</span><br><span class="line">    <span class="built_in">return</span> backward ? stepBackward : stepForward</span><br><span class="line">&#125;</span><br><span class="line">var currentValue = -4</span><br><span class="line"><span class="built_in">let</span> moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)</span><br><span class="line">// moveNearerToZero now refers to the nested stepForward() <span class="keyword">function</span></span><br><span class="line"><span class="keyword">while</span> currentValue != 0 &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(currentValue)... "</span>)</span><br><span class="line">    currentValue = moveNearerToZero(currentValue)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"zero!"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h2 id="类和结构体"><a href="#类和结构体" class="headerlink" title="类和结构体"></a>类和结构体</h2><p>与其他编程语言所不同的是，Swift 并不要求你为自定义的结构体和类的接口与实现代码分别创建文件。</p>
<p>在iOS开发中，类和结构体差距还是蛮大的，我们经常使用结构体来封装一些属性来组成新的类型，简化运算。</p>
<p>而在Swift中，结构体(值类型)和类（引用类型）有很多共同点。</p>
<ul>
<li>定义属性用于存储值</li>
<li>定义方法用于提供功能</li>
<li>定义下标操作用于通过下标语法访问它们的值</li>
<li>定义构造器用于设置初始值</li>
<li>通过扩展以增加默认实现之外的功能</li>
<li>遵循协议以提供某种标准功能</li>
</ul>
<p>与结构体相比，类还有如下的附加功能：</p>
<ul>
<li>继承允许一个类继承另一个类的特征</li>
<li>类型转换允许在运行时检查和解释一个类实例的类型</li>
<li>析构器允许一个类实例释放任何其所被分配的资源</li>
<li>引用计数允许对一个类的多次引用</li>
</ul>
<h3 id="定义语法"><a href="#定义语法" class="headerlink" title="定义语法"></a>定义语法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct SomeStructure &#123;</span><br><span class="line">    // 在这里定义结构体</span><br><span class="line">&#125;</span><br><span class="line">class SomeClass &#123;</span><br><span class="line">    // 在这里定义类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Swift命名注意  </p>
<p>每当你定义一个新的结构体或者类时，你都是定义了一个新的 Swift 类型。请使用 UpperCamelCase 这种方式来命名类型（如这里的 SomeClass 和 SomeStructure），以便符合标准 Swift 类型的大写命名风格（如 String，Int 和 Bool）。请使用 lowerCamelCase 这种方式来命名属性和方法（如 framerate 和 incrementCount），以便和类型名区分。</p>
</blockquote>
<h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> someClass = SomeClass()</span><br><span class="line"><span class="built_in">let</span> someStructure = SomeStructure()</span><br></pre></td></tr></table></figure>
<h3 id="属性访问"><a href="#属性访问" class="headerlink" title="属性访问"></a>属性访问</h3><p>你可以通过使用点语法访问实例的属性。其语法规则是，实例名后面紧跟属性名，两者以点号（.）分隔，不带空格，与iOS一致。</p>
<h3 id="恒等运算符"><a href="#恒等运算符" class="headerlink" title="恒等运算符"></a>恒等运算符</h3><p>判定两个常量或者变量是否引用同一个类实例有时很有用。为了达到这个目的，Swift 提供了两个恒等运算符：</p>
<ul>
<li>相同（===）</li>
<li>不相同（!==）</li>
</ul>
<blockquote>
<p>“==”表示两个实例的值“相等”或“等价”，判定时要遵照设计者定义的评判标准。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extension Vector2D: Equatable &#123;</span><br><span class="line">    static func == (left: Vector2D, right: Vector2D) -&gt; Bool &#123;</span><br><span class="line">        <span class="built_in">return</span> (left.x == right.x) &amp;&amp; (left.y == right.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h3><p>一个存储属性就是存储在特定类或结构体实例里的一个常量或变量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct FixedLengthRange &#123;</span><br><span class="line">    var firstValue: Int</span><br><span class="line">    <span class="built_in">let</span> length: Int</span><br><span class="line">&#125;</span><br><span class="line">var rangeOfThreeItems = FixedLengthRange(firstValue: 0, length: 3)</span><br><span class="line">// 该区间表示整数 0，1，2</span><br><span class="line">rangeOfThreeItems.firstValue = 6</span><br><span class="line">// 该区间现在表示整数 6，7，8</span><br></pre></td></tr></table></figure>
<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>除存储属性外，类、结构体和枚举可以定义计算属性。计算属性不直接存储值，而是提供一个 getter 和一个可选的 setter，来间接获取和设置其他属性或变量的值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0.0, y = 0.0</span><br><span class="line">&#125;</span><br><span class="line">struct Size &#123;</span><br><span class="line">    var width = 0.0, height = 0.0</span><br><span class="line">&#125;</span><br><span class="line">struct Rect &#123;</span><br><span class="line">    var origin = Point()</span><br><span class="line">    var size = Size()</span><br><span class="line">    var center: Point &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            <span class="built_in">let</span> centerX = origin.x + (size.width / 2)</span><br><span class="line">            <span class="built_in">let</span> centerY = origin.y + (size.height / 2)</span><br><span class="line">            <span class="built_in">return</span> Point(x: centerX, y: centerY)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">set</span>(newCenter) &#123;</span><br><span class="line">            origin.x = newCenter.x - (size.width / 2)</span><br><span class="line">            origin.y = newCenter.y - (size.height / 2)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var square = Rect(origin: Point(x: 0.0, y: 0.0),</span><br><span class="line">    size: Size(width: 10.0, height: 10.0))</span><br><span class="line"><span class="built_in">let</span> initialSquareCenter = square.center</span><br><span class="line">square.center = Point(x: 15.0, y: 15.0)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"square.origin is now at (\(square.origin.x), \(square.origin.y))"</span>)</span><br><span class="line">// 打印“square.origin is now at (10.0, 10.0)”</span><br></pre></td></tr></table></figure>
<h3 id="只读计算属性"><a href="#只读计算属性" class="headerlink" title="只读计算属性"></a>只读计算属性</h3><p>只有 getter 没有 setter 的计算属性叫只读计算属性。只读计算属性总是返回一个值，可以通过点运算符访问，但不能设置新的值。 </p>
<p>iOS中通过readOnly修饰@property，来实现只读属性。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, <span class="built_in">readonly</span>) NSString *varString;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>必须使用 var 关键字定义计算属性，包括只读计算属性，因为它们的值不是固定的。let 关键字只用来声明常量属性，表示初始化后再也无法修改的值。</p>
</blockquote>
<h3 id="属性观察器"><a href="#属性观察器" class="headerlink" title="属性观察器"></a>属性观察器</h3><p>属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器，即使新值和当前值相同的时候也不例外。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class StepCounter &#123;</span><br><span class="line">    var totalSteps: Int = 0 &#123;</span><br><span class="line">        willSet(newTotalSteps) &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"将 totalSteps 的值设置为 \(newTotalSteps)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            <span class="keyword">if</span> totalSteps &gt; oldValue  &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"增加了 \(totalSteps - oldValue) 步"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> stepCounter = StepCounter()</span><br><span class="line">stepCounter.totalSteps = 200</span><br><span class="line">// 将 totalSteps 的值设置为 200</span><br><span class="line">// 增加了 200 步</span><br><span class="line">stepCounter.totalSteps = 360</span><br><span class="line">// 将 totalSteps 的值设置为 360</span><br><span class="line">// 增加了 160 步</span><br><span class="line">stepCounter.totalSteps = 896</span><br><span class="line">// 将 totalSteps 的值设置为 896</span><br><span class="line">// 增加了 536 步</span><br></pre></td></tr></table></figure>
<p>iOS通过KVO来实现属性观察。</p>
<h3 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h3><p>实例属性属于一个特定类型的实例，每创建一个实例，实例都拥有属于自己的一套属性值，实例之间的属性相互独立。</p>
<p>你也可以为类型本身定义属性，无论创建了多少个该类型的实例，这些属性都只有唯一一份。这种属性就是类型属性。</p>
<p>使用关键字 static 来定义类型属性。在为类定义计算型类型属性时，可以改用关键字 class 来支持子类对父类的实现进行重写。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct SomeStructure &#123;</span><br><span class="line">    static var storedTypeProperty = <span class="string">"Some value."</span></span><br><span class="line">    static var computedTypeProperty: Int &#123;</span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">enum SomeEnumeration &#123;</span><br><span class="line">    static var storedTypeProperty = <span class="string">"Some value."</span></span><br><span class="line">    static var computedTypeProperty: Int &#123;</span><br><span class="line">        <span class="built_in">return</span> 6</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class SomeClass &#123;</span><br><span class="line">    static var storedTypeProperty = <span class="string">"Some value."</span></span><br><span class="line">    static var computedTypeProperty: Int &#123;</span><br><span class="line">        <span class="built_in">return</span> 27</span><br><span class="line">    &#125;</span><br><span class="line">    class var overrideableComputedTypeProperty: Int &#123;</span><br><span class="line">        <span class="built_in">return</span> 107</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>iOS中通过 class来修饰property。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, class) NSString *classString;</span><br></pre></td></tr></table></figure>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="实例方法（Instance-Methods）"><a href="#实例方法（Instance-Methods）" class="headerlink" title="实例方法（Instance Methods）"></a>实例方法（Instance Methods）</h3><p>实例方法是属于某个特定类、结构体或者枚举类型实例的方法。实例方法提供访问和修改实例属性的方法或提供与实例目的相关的功能，并以此来支撑实例的功能。</p>
<h4 id="实例方法中修改值类型"><a href="#实例方法中修改值类型" class="headerlink" title="实例方法中修改值类型"></a>实例方法中修改值类型</h4><p>结构体和枚举是值类型。默认情况下，值类型的属性不能在它的实例方法中被修改。</p>
<p>但是，如果你确实需要在某个特定的方法中修改结构体或者枚举的属性，你可以为这个方法选择 可变（mutating）行为，然后就可以从其方法内部改变它的属性；并且这个方法做的任何改变都会在方法执行结束时写回到原始结构中。方法还可以给它隐含的 self 属性赋予一个全新的实例，这个新实例在方法结束时会替换现存实例。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0.0, y = 0.0</span><br><span class="line">    mutating func moveBy(x deltaX: Double, y deltaY: Double) &#123;</span><br><span class="line">        x += deltaX</span><br><span class="line">        y += deltaY</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var somePoint = Point(x: 1.0, y: 1.0)</span><br><span class="line">somePoint.moveBy(x: 2.0, y: 3.0)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The point is now at (\(somePoint.x), \(somePoint.y))"</span>)</span><br><span class="line">// 打印“The point is now at (3.0, 4.0)”</span><br></pre></td></tr></table></figure>
<h3 id="类型方法"><a href="#类型方法" class="headerlink" title="类型方法"></a>类型方法</h3><p>实例方法是被某个类型的实例调用的方法。你也可以定义在类型本身上调用的方法，这种方法就叫做类型方法。在方法的 func 关键字之前加上关键字 static，来指定类型方法。类还可以用关键字 class 来允许子类重写父类的方法实现。</p>
<blockquote>
<p>注意</p>
<p>在 Objective-C 中，你只能为 Objective-C 的类类型（classes）定义类型方法（type-level methods）。在 Swift 中，你可以为所有的类、结构体和枚举定义类型方法。每一个类型方法都被它所支持的类型显式包含。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class SomeClass &#123;</span><br><span class="line">    class func <span class="function"><span class="title">someTypeMethod</span></span>() &#123;</span><br><span class="line">        // 在这里实现类型方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">SomeClass.someTypeMethod()</span><br></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>为了指明某个类的超类，将超类名写在子类名的后面，用冒号分隔：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class SomeClass: SomeSuperclass &#123;</span><br><span class="line">    // 这里是子类的定义</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>子类可以为继承来的实例方法，类方法，实例属性，类属性，或下标提供自己定制的实现。我们把这种行为叫重写。</p>
<p>如果要重写某个特性，你需要在重写定义的前面加上 override 关键字。</p>
<h4 id="重写方法"><a href="#重写方法" class="headerlink" title="重写方法"></a>重写方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Train: Vehicle &#123;</span><br><span class="line">    override func <span class="function"><span class="title">makeNoise</span></span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Choo Choo"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重写属性"><a href="#重写属性" class="headerlink" title="重写属性"></a>重写属性</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Car: Vehicle &#123;</span><br><span class="line">    var gear = 1</span><br><span class="line">    override var description: String &#123;</span><br><span class="line">        <span class="built_in">return</span> super.description + <span class="string">" in gear \(gear)"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重写属性观察器"><a href="#重写属性观察器" class="headerlink" title="重写属性观察器"></a>重写属性观察器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class AutomaticCar: Car &#123;</span><br><span class="line">    override var currentSpeed: Double &#123;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            gear = Int(currentSpeed / 10.0) + 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="防止重写-继承"><a href="#防止重写-继承" class="headerlink" title="防止重写/继承"></a>防止重写/继承</h4><p>你可以通过把方法，属性或下标标记为 final 来防止它们被重写，只需要在声明关键字前加上 final 修饰符即可（例如：final var、final func、final class func 以及 final subscript）。</p>
<p>任何试图对带有 final 标记的方法、属性或下标进行重写的代码，都会在编译时会报错。在类扩展中的方法，属性或下标也可以在扩展的定义里标记为 final。</p>
<p>可以通过在关键字 class 前添加 final 修饰符（final class）来将整个类标记为 final 。这样的类是不可被继承的，试图继承这样的类会导致编译报错。</p>
<h2 id="Extension"><a href="#Extension" class="headerlink" title="Extension"></a>Extension</h2><p>扩展可以给一个现有的类，结构体，枚举，还有协议添加新的功能。它还拥有不需要访问被扩展类型源代码就能完成扩展的能力（即逆向建模）。扩展和 Objective-C 的分类很相似。</p>
<p>Swift 中的扩展可以：</p>
<ul>
<li>添加计算型实例属性和计算型类属性</li>
<li>定义实例方法和类方法</li>
<li>提供新的构造器</li>
<li>定义下标</li>
<li>定义和使用新的嵌套类型</li>
<li>使已经存在的类型遵循（conform）一个协议</li>
</ul>
<blockquote>
<p>注意</p>
<p>扩展可以给一个类型添加新的功能，但是不能重写已经存在的功能(与OC不同)。</p>
</blockquote>
<h3 id="extension语法"><a href="#extension语法" class="headerlink" title="extension语法"></a>extension语法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extension SomeType &#123;</span><br><span class="line">  // 在这里给 SomeType 添加新的功能</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="计算型属性"><a href="#计算型属性" class="headerlink" title="计算型属性"></a>计算型属性</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">extension Double &#123;</span><br><span class="line">    var km: Double &#123; <span class="built_in">return</span> self * 1_000.0 &#125;</span><br><span class="line">    var m: Double &#123; <span class="built_in">return</span> self &#125;</span><br><span class="line">    var cm: Double &#123; <span class="built_in">return</span> self / 100.0 &#125;</span><br><span class="line">    var mm: Double &#123; <span class="built_in">return</span> self / 1_000.0 &#125;</span><br><span class="line">    var ft: Double &#123; <span class="built_in">return</span> self / 3.28084 &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> oneInch = 25.4.mm</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"One inch is \(oneInch) meters"</span>)</span><br><span class="line">// 打印“One inch is 0.0254 meters”</span><br><span class="line"><span class="built_in">let</span> threeFeet = 3.ft</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Three feet is \(threeFeet) meters"</span>)</span><br><span class="line">// 打印“Three feet is 0.914399970739201 meters”</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>扩展可以添加新的计算属性，但是它们不能添加存储属性，或向现有的属性添加属性观察者。</p>
</blockquote>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>扩展可以给现有的类型添加新的构造器。它使你可以把自定义类型作为参数来供其他类型的构造器使用，或者在类型的原始实现上添加额外的构造选项。</p>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><p>扩展可以给现有类型添加新的实例方法和类方法。</p>
<p>在下面的例子中，给 Int 类型添加了一个新的实例方法叫做 repetitions：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extension Int &#123;</span><br><span class="line">    func repetitions(task: () -&gt; Void) &#123;</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> 0..&lt;self &#123;</span><br><span class="line">            task()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3.repetitions &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">// Hello!</span><br><span class="line">// Hello!</span><br><span class="line">// Hello!</span><br></pre></td></tr></table></figure>
<h3 id="可变实例方法"><a href="#可变实例方法" class="headerlink" title="可变实例方法"></a>可变实例方法</h3><p>通过扩展添加的实例方法同样也可以修改（或 mutating（改变））实例本身。结构体和枚举的方法，若是可以修改 self 或者它自己的属性，则必须将这个实例方法标记为 mutating，就像是改变了方法的原始实现。</p>
<h3 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h3><p>扩展可以给现有的类型添加新的下标。下面的例子中，对 Swift 的 Int 类型添加了一个整数类型的下标。下标 [n] 从数字右侧开始，返回小数点后的第 n 位：</p>
<blockquote>
<p>123456789[0] 返回 9</p>
<p>123456789[1] 返回 8</p>
</blockquote>
<p>……以此类推：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">extension Int &#123;</span><br><span class="line">    subscript(digitIndex: Int) -&gt; Int &#123;</span><br><span class="line">        var decimalBase = 1</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> 0..&lt;digitIndex &#123;</span><br><span class="line">            decimalBase *= 10</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> (self / decimalBase) % 10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">746381295[0]</span><br><span class="line">// 返回 5</span><br><span class="line">746381295[1]</span><br><span class="line">// 返回 9</span><br><span class="line">746381295[2]</span><br><span class="line">// 返回 2</span><br><span class="line">746381295[8]</span><br><span class="line">// 返回 7</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">垂杨小梳雨</p>
              <p class="site-description motion-element" itemprop="description">None</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">35</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">垂杨小梳雨</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
