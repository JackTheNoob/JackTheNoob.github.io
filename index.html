<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="None">
<meta name="keywords" content="iOS,swift,react-native,javascript,微信开发,微信小程序,C,C语言,程序猿,博客,Lyddwn,码农">
<meta property="og:type" content="website">
<meta property="og:title" content="Lyddwn">
<meta property="og:url" content="http://jackthenoob.github.io/index.html">
<meta property="og:site_name" content="Lyddwn">
<meta property="og:description" content="None">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lyddwn">
<meta name="twitter:description" content="None">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://jackthenoob.github.io/">





  <title>Lyddwn</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Lyddwn</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">生活不只是代码</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            Commonweal 404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jackthenoob.github.io/2019/05/23/iOS测试代码运行效率-diapatch-benchmark/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="垂杨小梳雨">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lyddwn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/23/iOS测试代码运行效率-diapatch-benchmark/" itemprop="url">iOS测试代码运行效率-diapatch_benchmark</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-23T13:57:02+08:00">
                2019-05-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在日常开发过程中，我们经常会遇到这样的疑问：</p>
<blockquote>
<p>这段代码相对效率是多少？方法A与方法B哪个更快？</p>
</blockquote>
<h4 id="打时间戳"><a href="#打时间戳" class="headerlink" title="打时间戳"></a>打时间戳</h4><p>逻辑很简单：代码运行前记录一次时间，运行后记录一次，然后比较时间差即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CFTimeInterval startTime = CACurrentMediaTime();</span><br><span class="line"></span><br><span class="line">//your code here</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">CFTimeInterval endTime = CACurrentMediaTime();</span><br><span class="line">NSLog(@<span class="string">"Total Runtime: %g s"</span>, endTime - startTime);</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="comment">#### diapatch_benchmark</span></span><br><span class="line">dispatch_benchmark 是 libdispatch (Grand Central Dispatch) 的一部分。但这个方法并没有被公开声明，所以你必须要自己声明：</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">extern uint64_t dispatch_benchmark(size_t count, void (^block)(void));</span><br></pre></td></tr></table></figure>
<p>因为没有公开的函数定义， dispatch_benchmark 在 Xcode 中也没有公开的文档。但幸运的是有 man 页面</p>
<p>dispatch_benchmark(3)</p>
<blockquote>
<p>The dispatch_benchmark function executes the given block multiple times according to the count variable and then returns the average number of nanoseconds per execution. This function is for debugging and performance analysis work. For the best results, pass a high count value to dispatch_benchmark.<br>Please look for inflection points with various data sets and keep the following facts in mind:</p>
<ul>
<li>Code bound by computational bandwidth may be inferred by proportional changes in performance as concurrency is increased.</li>
<li>Code bound by memory bandwidth may be inferred by negligible changes in performance as concurrency is increased.</li>
<li>Code bound by critical sections may be inferred by retrograde changes in performance as concurrency is increased.<ul>
<li>Intentional: locks, mutexes, and condition variables.</li>
<li>Accidental: unrelated and frequently modified data on the same cache-line.</li>
</ul>
</li>
</ul>
</blockquote>
<h6 id="dispatch-benchmark是一个根据传入的count参数多次执行给定block然后返回平均执行时间（纳秒）的方法。这个方法用于调试和测试分析代码性能。为了获取跟好的效果，传入的一个较大的count值"><a href="#dispatch-benchmark是一个根据传入的count参数多次执行给定block然后返回平均执行时间（纳秒）的方法。这个方法用于调试和测试分析代码性能。为了获取跟好的效果，传入的一个较大的count值" class="headerlink" title="dispatch_benchmark是一个根据传入的count参数多次执行给定block然后返回平均执行时间（纳秒）的方法。这个方法用于调试和测试分析代码性能。为了获取跟好的效果，传入的一个较大的count值"></a>dispatch_benchmark是一个根据传入的count参数多次执行给定block然后返回平均执行时间（纳秒）的方法。这个方法用于调试和测试分析代码性能。为了获取跟好的效果，传入的一个较大的count值</h6><h5 id="使用Sample"><a href="#使用Sample" class="headerlink" title="使用Sample"></a>使用Sample</h5><p>对于iOS中NSMutableArray，它对首尾插入/删除有较高的效率，近乎常数。</p>
<p>下面我们对比下，首尾删除与在中间删除有多少差距。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//测试函数</span><br><span class="line">- (void)benchmark &#123;</span><br><span class="line">    </span><br><span class="line">    NSUInteger iterations = 100;</span><br><span class="line">    NSMutableArray *iterationArray = [NSMutableArray arrayWithArray:_testArray];</span><br><span class="line">    NSMutableArray *iterationArray2 = [NSMutableArray arrayWithArray:_testArray];;</span><br><span class="line">    </span><br><span class="line">    uint64_t t_0 = dispatch_benchmark(iterations, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; self-&gt;_count; i ++) &#123;</span><br><span class="line">            NSUInteger index = iterationArray.count/2;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; iterationArray.count) &#123;</span><br><span class="line">                [iterationArray removeObjectAtIndex:index];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@<span class="string">"Remove Array At Middle Avg. Runtime: %llu ms"</span>, t_0/1000);</span><br><span class="line">    uint64_t t_1 = dispatch_benchmark(iterations, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; self-&gt;_count; i ++) &#123;</span><br><span class="line">            NSUInteger index = iterationArray2.count/2;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; iterationArray2.count) &#123;</span><br><span class="line">                [iterationArray2 removeObjectAtIndex:0];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@<span class="string">"Remove Array From Begining Avg. Runtime: %llu ms"</span>, t_1/1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//调用</span><br><span class="line">&#123;</span><br><span class="line">	_count = 200000;</span><br><span class="line">    _testArray = [NSMutableArray arrayWithCapacity:_count];</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; _count; i ++) &#123;</span><br><span class="line">        [_testArray addObject:@(i)];</span><br><span class="line">    &#125;</span><br><span class="line">    [self benchmark];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码可以看出，初始化了一个数量为200000的可变数组，分别在中间、首尾移除数组元素，执行100次。</p>
<blockquote>
<p>执行结果</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Remove Array At Middle Avg. Runtime: 21851 ms</span><br><span class="line">Remove Array From Begining Avg. Runtime: 1553 ms</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jackthenoob.github.io/2019/05/23/Xcode开发效率-快捷键-代码块/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="垂杨小梳雨">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lyddwn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/23/Xcode开发效率-快捷键-代码块/" itemprop="url">Xcode开发效率-快捷键&代码块</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-23T11:07:06+08:00">
                2019-05-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Xcode/" itemprop="url" rel="index">
                    <span itemprop="name">Xcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>程序员使用最多的还是键盘，我们可以通过快捷键的使用来方便的、快捷的访问Xcode很多功能。从而提高开发效率。</p>
</blockquote>
<h2 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h2><ul>
<li>Shift + Command + O（字母O，而非0）弹出快速查找文件窗口。 </li>
<li>Shift +Commond + 0（数字0，而非字母O）快速打开官方文档。 </li>
<li>Shift + Comand + j 定位到文件所在目录，配合第一条快捷键使用。</li>
<li>Control + Command + 上\下  切换 .m 和.h。</li>
<li>Command + t 新建一个Tab（这个很实用，我平时一般都会建3，4个Tab）。</li>
<li>Command + w 关闭Tab。</li>
<li>Command + ` 切换同一个应用多个窗口。可以用来在多个Xcode窗口中切换。</li>
<li>Control + Command + e 可以批量修改光标所在位置的变量，像这样：</li>
</ul>
<p><img src="/2019/05/23/Xcode开发效率-快捷键-代码块/a001.gif" alt></p>
<ul>
<li>Shift + Command + f 打开全局搜索。(可以加个 Any 正则，就可以搜出如图中的这种)</li>
</ul>
<p><img src="/2019/05/23/Xcode开发效率-快捷键-代码块/a002.jpg" alt></p>
<ul>
<li>Command + f 在类中搜索 （enter 匹配下一个 Shift + enter 匹配上一个）。</li>
<li>Command + 上\下\左\右 光标切换到类首/类尾/行首/行尾。</li>
<li>Shift + Command + 上\下\左\右 从当前光标所在选中到类首/类尾/行首/行尾的文本。</li>
<li>alt + 左\右 光标左右移动一个单词。 </li>
<li>Command + delete 删除光标到行首的内容，同理alt + delete 删除光标前的一个单词，另外可以先切换到到行尾 用Command + delete删除一整行内容。</li>
<li>Control + i 自动缩进代码。</li>
<li>Command + \ 当前行加断点。</li>
<li>alt + Command + \，新建一个symbolic breakpoint。</li>
<li>Command + n新建文件 ，Shift + Command + n 新建工程。</li>
<li>alt + Command + 左\右 折叠\显示当前块。</li>
<li>Shift + alt + Command + 左\右 折叠\显示当前文件中的块。</li>
<li>alt + Command + [ 上移，如果没有选中，默认上移当前行，alt + Command + ] 下移。</li>
<li>Command + ] 向右缩进，支持多行，Command + [ 向左缩进。（类似Tab与shift+tab）。</li>
<li>Shift + Command + k product 清理；Command + r Run；Command + b 编译。</li>
</ul>
<h2 id="Xcode窗口控制"><a href="#Xcode窗口控制" class="headerlink" title="Xcode窗口控制"></a>Xcode窗口控制</h2><ul>
<li>Shift + Command + Y 隐藏\显示 console 区。</li>
<li>Shift + Command + C 显示 console 区，且直接聚焦。</li>
<li>Command + k console清屏。</li>
<li>Control + 1 （没用过&gt;,&lt;）。</li>
</ul>
<p><img src="/2019/05/23/Xcode开发效率-快捷键-代码块/a003.jpg" alt></p>
<ul>
<li>Control + 6 查看当前类的方法列表（可以用 pragma mark 来合理分块，查看更直观）。</li>
<li>Command + （1~9）切换左边窗体.Command + 0 显示 \ 隐藏左边窗体。</li>
<li>alt + Command + 0 显示 \ 隐藏右边窗体，同理alt + Command + 1,2等也可以切换。</li>
<li>Command + , 弹出 Perferences ,可以用 Command + w 隐藏。</li>
<li>Command + +(加号)/-(减号)，放大/缩小整体页面。与Web端一致。</li>
</ul>
<h2 id="Code-Snippet"><a href="#Code-Snippet" class="headerlink" title="Code Snippet"></a>Code Snippet</h2><blockquote>
<p>选中编写好的代码块，右击选择 Create Code Snippet</p>
</blockquote>
<p><img src="/2019/05/23/Xcode开发效率-快捷键-代码块/a004.png" alt></p>
<p><img src="/2019/05/23/Xcode开发效率-快捷键-代码块/a006.png" alt></p>
<h5 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明:"></a>参数说明:</h5><ul>
<li>Title: Code Snippet的名字,将作为主标题显示在列表中。</li>
<li>Summary: 说明,将作为副标题显示在列表中。</li>
<li>Platform: 平台,有All,iOS,watchOS,macOS和tvOS五个选项。</li>
<li>Language: 语言,有Objective-C,Swift等选项。</li>
<li>Completion Shortcut: 快捷键。</li>
<li>Completion Scopes: 匹配范围,比如说OC中一个类的代码块不该在另一个类中匹配出来,这样可以更加精确地匹配,这个选项可以多选。</li>
<li>代码: 这就不用多说,直接在代码模块修改,但是这里相当于纯文本,建议验证后再保存。</li>
</ul>
<blockquote>
<p>Command + shift + L 打开所有代码块。</p>
</blockquote>
<p><img src="/2019/05/23/Xcode开发效率-快捷键-代码块/a005.jpg" alt></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tips: 代码段中可以使用&lt;<span class="comment">#placeHolder#&gt;用于占位</span></span><br></pre></td></tr></table></figure>
<h3 id="补充Code-Snippet示例"><a href="#补充Code-Snippet示例" class="headerlink" title="补充Code Snippet示例"></a>补充Code Snippet示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//property</span><br><span class="line">@property (nonatomic, readwrite, strong) &lt;<span class="comment">#expression#&gt; *&lt;#expression#&gt;;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//UICollectionView </span><br><span class="line"><span class="comment">#pragma mark - UICollectionViewDataSource</span></span><br><span class="line">- (NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView &#123;</span><br><span class="line">    <span class="built_in">return</span> &lt;<span class="comment">#number#&gt;;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section &#123;</span><br><span class="line">    <span class="built_in">return</span> &lt;<span class="comment">#number#&gt;;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    UICollectionViewCell *cell = (UICollectionViewCell *)[collectionView dequeueReusableCellWithReuseIdentifier:@<span class="string">""</span> forIndexPath:indexPath];</span><br><span class="line">    <span class="built_in">return</span> cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">return</span> CGSizeMake(&lt;<span class="comment">#number#&gt;, &lt;#number#&gt;);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIEdgeInsets)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout insetForSectionAtIndex:(NSInteger)section</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">return</span> UIEdgeInsetsMake(&lt;<span class="comment">#number#&gt;, &lt;#number#&gt;, &lt;#number#&gt;, &lt;#number#&gt;);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#pragma mark - UICollectionViewDelegate</span></span><br><span class="line">- (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//attributeLabel</span><br><span class="line">UILabel *attributedLabel =[[UILabel alloc] init];</span><br><span class="line">attributedLabel.numberOfLines = 0;</span><br><span class="line">attributedLabel.preferredMaxLayoutWidth = &lt;<span class="comment">#preferredMaxLayoutWidth#&gt;;</span></span><br><span class="line">attributedLabel.backgroundColor = [UIColor clearColor];</span><br><span class="line">NSString *text = &lt;<span class="comment">#text#&gt;;</span></span><br><span class="line">NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];</span><br><span class="line">style.lineSpacing = &lt;<span class="comment">#lineSpacing#&gt;;</span></span><br><span class="line">NSDictionary *attr = @&#123;</span><br><span class="line">					NSFontAttributeName: [UIFont &lt;<span class="comment">#font#&gt;],</span></span><br><span class="line">                   	NSParagraphStyleAttributeName: style,</span><br><span class="line">                   	NSForegroundColorAttributeName: [UIColor &lt;<span class="comment">#color#&gt;]</span></span><br><span class="line">                   	&#125;;</span><br><span class="line">attributedLabel.attributedText = [[NSAttributedString alloc] initWithString:text attributes:attr];</span><br><span class="line">[&lt;<span class="comment">#view#&gt; addSubview:attributedLabel];</span></span><br></pre></td></tr></table></figure>
<h2 id="Xcode插件"><a href="#Xcode插件" class="headerlink" title="Xcode插件"></a>Xcode插件</h2><p>略（待补充）</p>
<h2 id="Simlulater"><a href="#Simlulater" class="headerlink" title="Simlulater"></a>Simlulater</h2><p>略（待补充）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jackthenoob.github.io/2019/05/23/修改-gitignoe文件后如何生效/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="垂杨小梳雨">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lyddwn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/23/修改-gitignoe文件后如何生效/" itemprop="url">修改.gitignoe文件后如何生效</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-23T11:02:09+08:00">
                2019-05-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/git/" itemprop="url" rel="index">
                    <span itemprop="name">git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached .  <span class="comment">#清除缓存  </span></span><br><span class="line">git add . <span class="comment">#重新trace file  </span></span><br><span class="line">git commit -m <span class="string">"update .gitignore"</span> <span class="comment">#提交和注释</span></span><br></pre></td></tr></table></figure>
<p>总来来说，移除本地缓存，重新添加trace文件。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jackthenoob.github.io/2019/05/22/使用-访问实例对象成员变量Crash问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="垂杨小梳雨">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lyddwn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/22/使用-访问实例对象成员变量Crash问题/" itemprop="url">使用->访问实例对象成员变量Crash问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-22T21:10:05+08:00">
                2019-05-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h6 id="最近线上发生了一个Crash。根据栈信息定位到如下代码"><a href="#最近线上发生了一个Crash。根据栈信息定位到如下代码" class="headerlink" title="最近线上发生了一个Crash。根据栈信息定位到如下代码"></a>最近线上发生了一个Crash。根据栈信息定位到如下代码</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXC_BAD_ACCESS (SIGBUS)</span><br><span class="line">Attempted to dereference garbage pointer 0x10. Originated at or <span class="keyword">in</span> a subcall of WebViewJavascriptBridge_js</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (instance-&gt;ivar) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="就是访问成员变量时Crash。"><a href="#就是访问成员变量时Crash。" class="headerlink" title="就是访问成员变量时Crash。"></a>就是访问成员变量时Crash。</h6><h6 id="难道instance可能为空，但是为空应该也不会Crash吧？因为在我的固有的思维里面，对nil发送消息并不会crash。"><a href="#难道instance可能为空，但是为空应该也不会Crash吧？因为在我的固有的思维里面，对nil发送消息并不会crash。" class="headerlink" title="难道instance可能为空，但是为空应该也不会Crash吧？因为在我的固有的思维里面，对nil发送消息并不会crash。"></a>难道instance可能为空，但是为空应该也不会Crash吧？因为在我的固有的思维里面，对nil发送消息并不会crash。</h6><h5 id="但是又仔细想了想，访问成员变量时，是通过当前类的实例对象偏移量再加上此变量在类中的偏移量获取的。与发送消息无关（不是属性，没有写get方法）。如果当前实例对象如果为空（obj的offet-0），为什么还会继续呢？百思不得解。"><a href="#但是又仔细想了想，访问成员变量时，是通过当前类的实例对象偏移量再加上此变量在类中的偏移量获取的。与发送消息无关（不是属性，没有写get方法）。如果当前实例对象如果为空（obj的offet-0），为什么还会继续呢？百思不得解。" class="headerlink" title="但是又仔细想了想，访问成员变量时，是通过当前类的实例对象偏移量再加上此变量在类中的偏移量获取的。与发送消息无关（不是属性，没有写get方法）。如果当前实例对象如果为空（obj的offet=0），为什么还会继续呢？百思不得解。"></a>但是又仔细想了想，访问成员变量时，是通过当前类的实例对象偏移量再加上此变量在类中的偏移量获取的。与发送消息无关（不是属性，没有写get方法）。如果当前实例对象如果为空（obj的offet=0），为什么还会继续呢？百思不得解。</h5><h5 id="写了一个demo，使用clang命令转换为cpp文件后，才知道缘由。"><a href="#写了一个demo，使用clang命令转换为cpp文件后，才知道缘由。" class="headerlink" title="写了一个demo，使用clang命令转换为cpp文件后，才知道缘由。"></a>写了一个demo，使用clang命令转换为cpp文件后，才知道缘由。</h5><h5 id="大体代码如下："><a href="#大体代码如下：" class="headerlink" title="大体代码如下："></a>大体代码如下：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//MyObject.h</span><br><span class="line">@interface MyObject : NSObject &#123;</span><br><span class="line">    @public</span><br><span class="line">    NSString    *_strObject;</span><br><span class="line">    NSArray     *_arrList;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//Test.h</span><br><span class="line">@implementation Test</span><br><span class="line"></span><br><span class="line">- (void)helloworld &#123;</span><br><span class="line">    MyObject *obj = nil;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        obj = [MyObject new];</span><br><span class="line">    &#125;</span><br><span class="line">    NSString *str = obj-&gt;_strObject;</span><br><span class="line">    NSLog(@<span class="string">"%@"</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc Test.m</span><br></pre></td></tr></table></figure>
<h6 id="通过clang命令获取Test-cpp文件（10万行左右）"><a href="#通过clang命令获取Test-cpp文件（10万行左右）" class="headerlink" title="通过clang命令获取Test.cpp文件（10万行左右）"></a>通过clang命令获取Test.cpp文件（10万行左右）</h6><h6 id="在后面看到如下片段"><a href="#在后面看到如下片段" class="headerlink" title="在后面看到如下片段"></a>在后面看到如下片段</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pragma clang assume_nonnull end</span></span><br><span class="line">// @implementation Test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void _I_Test_helloworld(Test * self, SEL _cmd) &#123;</span><br><span class="line">    MyObject *obj = __null;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        obj = ((MyObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(<span class="string">"MyObject"</span>), sel_registerName(<span class="string">"new"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    NSString *str = (*(NSString **)((char *)obj + OBJC_IVAR_<span class="variable">$_MyObject</span><span class="variable">$_strObject</span>));</span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_hs_pl2pwmlj27g9xt0wlb9mbdbh0000gn_T_Test_2546e4_mi_0, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// @end</span><br></pre></td></tr></table></figure>
<h5 id="主要下这行代码"><a href="#主要下这行代码" class="headerlink" title="主要下这行代码"></a>主要下这行代码</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = (*(NSString **)((char *)obj + OBJC_IVAR_<span class="variable">$_MyObject</span><span class="variable">$_strObject</span>));</span><br></pre></td></tr></table></figure>
<h6 id="这段代码就是获取-strObject偏移量，OBJC-IVAR-MyObject-strObject是一个在编译器已经决定了的固定的偏移量。obj就是实例对象的首地址。通过2个值获取到-strObject地址。如果obj-nil-这个偏移地址就是一个固定的值0，加上变量固定偏移量，值就类似于0x10-这也和crash信息里相匹配-。"><a href="#这段代码就是获取-strObject偏移量，OBJC-IVAR-MyObject-strObject是一个在编译器已经决定了的固定的偏移量。obj就是实例对象的首地址。通过2个值获取到-strObject地址。如果obj-nil-这个偏移地址就是一个固定的值0，加上变量固定偏移量，值就类似于0x10-这也和crash信息里相匹配-。" class="headerlink" title="这段代码就是获取_strObject偏移量，OBJC_IVAR_$_MyObject$_strObject是一个在编译器已经决定了的固定的偏移量。obj就是实例对象的首地址。通过2个值获取到_strObject地址。如果obj==nil;这个偏移地址就是一个固定的值0，加上变量固定偏移量，值就类似于0x10(这也和crash信息里相匹配)。"></a>这段代码就是获取_strObject偏移量，OBJC_IVAR_$_MyObject$_strObject是一个在编译器已经决定了的固定的偏移量。obj就是实例对象的首地址。通过2个值获取到_strObject地址。如果obj==nil;这个偏移地址就是一个固定的值0，加上变量固定偏移量，值就类似于0x10(这也和crash信息里相匹配)。</h6><hr>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><blockquote>
<p>通过-&gt;访问成员变量要判断当前变量是否为空。通过offset寻址成员变量时并不会多一层为空判断逻辑。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jackthenoob.github.io/2019/05/21/Swift学习笔记-一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="垂杨小梳雨">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lyddwn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/21/Swift学习笔记-一/" itemprop="url">Swift学习笔记(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-21T11:21:00+08:00">
                2019-05-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/swift/" itemprop="url" rel="index">
                    <span itemprop="name">swift</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><h5 id="Swift是一种支持多编程范式、安全、快速和互动的跨平台编译式编程语言。且编译器对性能进行了优化，编程语言对开发进行了优化，两者互不干扰，鱼与熊掌兼得。它支持代码预览（playgrounds），这个革命性的特性可以允许程序员在不编译和运行应用程序的前提下运行-Swift-代码并实时查看结果。"><a href="#Swift是一种支持多编程范式、安全、快速和互动的跨平台编译式编程语言。且编译器对性能进行了优化，编程语言对开发进行了优化，两者互不干扰，鱼与熊掌兼得。它支持代码预览（playgrounds），这个革命性的特性可以允许程序员在不编译和运行应用程序的前提下运行-Swift-代码并实时查看结果。" class="headerlink" title="Swift是一种支持多编程范式、安全、快速和互动的跨平台编译式编程语言。且编译器对性能进行了优化，编程语言对开发进行了优化，两者互不干扰，鱼与熊掌兼得。它支持代码预览（playgrounds），这个革命性的特性可以允许程序员在不编译和运行应用程序的前提下运行 Swift 代码并实时查看结果。"></a>Swift是一种支持多编程范式、安全、快速和互动的跨平台编译式编程语言。且编译器对性能进行了优化，编程语言对开发进行了优化，两者互不干扰，鱼与熊掌兼得。它支持代码预览（playgrounds），这个革命性的特性可以允许程序员在不编译和运行应用程序的前提下运行 Swift 代码并实时查看结果。</h5><h4 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h4><ul>
<li>2010年7月，苹果开发者工具部门总监克里斯·拉特纳开始着手 Swift 编程语言的设计工作，以一年时间，完成基本架构后，他领导了一个设计团队大力参与其中。</li>
<li>2014年6月发表， Swift大约历经4年的开发期。苹果宣称Swift的特点是：快速、现代、安全、互动，而且明显优于Objective-C语言。Swift以LLVM编译，可以使用现有的Cocoa和Cocoa Touch框架。Xcode Playgrounds功能是Swift为苹果开发工具带来的最大创新，该功能提供强大的互动效果，能让Swift源代码在撰写过程中能即时显示出其运行结果。拉特纳本人强调，Playgrounds很大程度是受到布雷特·维克多理念的启发。</li>
<li>2015年6月8日，苹果于WWDC2015上宣布，Swift将开放源代码，包括编译器和标准库。</li>
<li>2015年12月3日，苹果宣布开源swift，并支持Linux，苹果在新网站swift.org和托管网站Github上开源了swift，但苹果的app store并不支持开源的swift，只支持苹果官方的swift版本，官方版本会在新网站swift.org上定期与开源版本同步。</li>
</ul>
<p><a href="https://swiftgg.gitbook.io/swift/huan-ying-shi-yong-swift/04_revision_history" target="_blank" rel="noopener">Swift历史版本</a></p>
<ul>
<li>2019-01-24 Swift 5.0 更新</li>
<li>2018-09-17 Swift 4.2 更新</li>
<li>2018-03-29 Swift 4.1 更新</li>
<li>2017-12-04 Swift 4.0.3 更新</li>
<li>2017-09-19 Swift 4.0 更新</li>
<li>2017-03-27 Swift 3.1 更新</li>
<li>2016-10-27 Swift 3.0.1 更新</li>
<li>2016-09-13 Swift 3.0 更新</li>
<li>2016-03-21 Swift 2.2 更新</li>
<li>2015-10-20 Swift 2.1 更新</li>
<li>2015-09-16 Swift 2.0 更新</li>
<li>2015-4-8 Swift 1.2 更新</li>
<li>2014-10-16 Swift 1.1 更新</li>
<li>2014-08-18 Swift 1.0 更新 </li>
</ul>
<h2 id="Swift-是一门开发-iOS-macOS-watchOS-和-tvOS-应用的新语言。然而，如果你有-C-或者-Objective-C-开发经验的话，你会发现-Swift-的很多内容都是你熟悉的。"><a href="#Swift-是一门开发-iOS-macOS-watchOS-和-tvOS-应用的新语言。然而，如果你有-C-或者-Objective-C-开发经验的话，你会发现-Swift-的很多内容都是你熟悉的。" class="headerlink" title="Swift 是一门开发 iOS, macOS, watchOS 和 tvOS 应用的新语言。然而，如果你有 C 或者 Objective-C 开发经验的话，你会发现 Swift 的很多内容都是你熟悉的。"></a>Swift 是一门开发 iOS, macOS, watchOS 和 tvOS 应用的新语言。然而，如果你有 C 或者 Objective-C 开发经验的话，你会发现 Swift 的很多内容都是你熟悉的。</h2><h3 id="下面通过Swift与Objective-C-C对比来介绍这门语言"><a href="#下面通过Swift与Objective-C-C对比来介绍这门语言" class="headerlink" title="下面通过Swift与Objective-C/C对比来介绍这门语言"></a>下面通过Swift与Objective-C/C对比来介绍这门语言</h3><h2 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h2><h4 id="基本数值类型（numeric-types）"><a href="#基本数值类型（numeric-types）" class="headerlink" title="基本数值类型（numeric types）"></a>基本数值类型（numeric types）</h4><h6 id="Swift-包含了-C-和-Objective-C-上所有基础数据类型，Int-表示整型值；-Double-和-Float-表示浮点型值；-Bool-是布尔型值；String-是文本型数据。-Swift-还提供了三个基本的集合类型，Array、Set-和-Dictionary。类似OC中NSArray、NSMutableArray、NSSet、NSMutableSet、NSDictionary、NSMutableDictionary。"><a href="#Swift-包含了-C-和-Objective-C-上所有基础数据类型，Int-表示整型值；-Double-和-Float-表示浮点型值；-Bool-是布尔型值；String-是文本型数据。-Swift-还提供了三个基本的集合类型，Array、Set-和-Dictionary。类似OC中NSArray、NSMutableArray、NSSet、NSMutableSet、NSDictionary、NSMutableDictionary。" class="headerlink" title="Swift 包含了 C 和 Objective-C 上所有基础数据类型，Int 表示整型值； Double 和 Float 表示浮点型值； Bool 是布尔型值；String 是文本型数据。 Swift 还提供了三个基本的集合类型，Array、Set 和 Dictionary。类似OC中NSArray、NSMutableArray、NSSet、NSMutableSet、NSDictionary、NSMutableDictionary。"></a>Swift 包含了 C 和 Objective-C 上所有基础数据类型，Int 表示整型值； Double 和 Float 表示浮点型值； Bool 是布尔型值；String 是文本型数据。 Swift 还提供了三个基本的集合类型，Array、Set 和 Dictionary。类似OC中NSArray、NSMutableArray、NSSet、NSMutableSet、NSDictionary、NSMutableDictionary。</h6><blockquote>
<p>值类型(Value Type)&amp;引用类型(Reference Type)  </p>
<p>内存（RAM）中有两个区域，栈区（stack）和堆区（heap）。在 Swift 中，值类型，存放在栈区；引用类型，存放在堆区。  </p>
<p> 在 Swift 中，典型的有 struct，enum，以及 tuples(元组) 都是值类型。而平时使用的 Int， Double，Float，String，Array，Dictionary，Set 其实都是用结构体实现的，也是值类型。详见下面代码</p>
<p>在 Swift 中，class 和闭包是引用类型。  </p>
<p>而在Objective-C中，除了基本数据类型、结构体等，其他都是引用类型。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public struct Int : FixedWidthInteger, SignedInteger &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="元组-tuples"><a href="#元组-tuples" class="headerlink" title="元组(tuples)"></a>元组(tuples)</h4><h6 id="元组（tuples）把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。这在Objective-C中是没有的。"><a href="#元组（tuples）把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。这在Objective-C中是没有的。" class="headerlink" title="元组（tuples）把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。这在Objective-C中是没有的。"></a>元组（tuples）把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。这在Objective-C中是没有的。</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> http404Error = (404, <span class="string">"Not Found"</span>)</span><br><span class="line">// http404Error 的类型是 (Int, String)，值是 (404, <span class="string">"Not Found"</span>)</span><br><span class="line"><span class="built_in">let</span> (statusCode, statusMessage) = http404Error</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The status code is \(statusCode)"</span>)</span><br><span class="line">// 输出“The status code is 404”</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The status message is \(statusMessage)"</span>)</span><br><span class="line">// 输出“The status message is Not Found”</span><br></pre></td></tr></table></figure>
<h6 id="404-“Not-Found”-元组把一个-Int-值和一个-String-值组合起来表示-HTTP-状态码的两个部分：一个数字和一个人类可读的描述。这个元组可以被描述为“一个类型为-Int-String-的元组”。-如果函数需要返回多个值，是一个不错的应用场景。"><a href="#404-“Not-Found”-元组把一个-Int-值和一个-String-值组合起来表示-HTTP-状态码的两个部分：一个数字和一个人类可读的描述。这个元组可以被描述为“一个类型为-Int-String-的元组”。-如果函数需要返回多个值，是一个不错的应用场景。" class="headerlink" title="(404, “Not Found”) 元组把一个 Int 值和一个 String 值组合起来表示 HTTP 状态码的两个部分：一个数字和一个人类可读的描述。这个元组可以被描述为“一个类型为 (Int, String) 的元组”。 如果函数需要返回多个值，是一个不错的应用场景。"></a>(404, “Not Found”) 元组把一个 Int 值和一个 String 值组合起来表示 HTTP 状态码的两个部分：一个数字和一个人类可读的描述。这个元组可以被描述为“一个类型为 (Int, String) 的元组”。 如果函数需要返回多个值，是一个不错的应用场景。</h6><h4 id="类型安全"><a href="#类型安全" class="headerlink" title="类型安全"></a>类型安全</h4><h6 id="Swift-是一门类型安全的语言，这意味着-Swift-可以让你清楚地知道值的类型。如果你的代码需要一个-String-，类型安全会阻止你不小心传入一个-Int-。而在OC中则不然。"><a href="#Swift-是一门类型安全的语言，这意味着-Swift-可以让你清楚地知道值的类型。如果你的代码需要一个-String-，类型安全会阻止你不小心传入一个-Int-。而在OC中则不然。" class="headerlink" title="Swift 是一门类型安全的语言，这意味着 Swift 可以让你清楚地知道值的类型。如果你的代码需要一个 String ，类型安全会阻止你不小心传入一个 Int 。而在OC中则不然。"></a>Swift 是一门类型安全的语言，这意味着 Swift 可以让你清楚地知道值的类型。如果你的代码需要一个 String ，类型安全会阻止你不小心传入一个 Int 。而在OC中则不然。</h6><h4 id="常量-amp-变量"><a href="#常量-amp-变量" class="headerlink" title="常量&amp;变量"></a>常量&amp;变量</h4><blockquote>
<p>   var - 声明变量。<br>   let - 声明变量。  </p>
</blockquote>
<h4 id="类型标注"><a href="#类型标注" class="headerlink" title="类型标注"></a>类型标注</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var welcomeMessage: String = <span class="string">"hello world!"</span>;</span><br><span class="line">var welcomeMessage = <span class="string">"hello world!"</span>;</span><br></pre></td></tr></table></figure>
<h6 id="声明一个类型为-String-，名字为-welcomeMessage-的变量。"><a href="#声明一个类型为-String-，名字为-welcomeMessage-的变量。" class="headerlink" title="声明一个类型为 String ，名字为 welcomeMessage 的变量。"></a>声明一个类型为 String ，名字为 welcomeMessage 的变量。</h6><blockquote>
<p>如果你在声明常量或者变量的时候赋了一个初始值，Swift 可以推断出这个常量或者变量的类型。  </p>
</blockquote>
<h4 id="常量和变量的命名"><a href="#常量和变量的命名" class="headerlink" title="常量和变量的命名"></a>常量和变量的命名</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var x = 0.0, y = 0.0;</span><br><span class="line"><span class="built_in">let</span> z = 0.0;</span><br><span class="line"><span class="built_in">let</span> 你好 = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">let</span> 🐶🐮 = <span class="string">"emoj-dog&amp;cat"</span>;</span><br></pre></td></tr></table></figure>
<h6 id="上面例子可以看出，常量和变量名可以包含任何字符，包括-Unicode-字符。"><a href="#上面例子可以看出，常量和变量名可以包含任何字符，包括-Unicode-字符。" class="headerlink" title="上面例子可以看出，常量和变量名可以包含任何字符，包括 Unicode 字符。"></a>上面例子可以看出，常量和变量名可以包含任何字符，包括 Unicode 字符。</h6><h4 id="输出常量和变量"><a href="#输出常量和变量" class="headerlink" title="输出常量和变量"></a>输出常量和变量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//swift</span><br><span class="line">// 输出“The current value of friendlyWelcome is hello world!”</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The current value of welcomeMessage is \(welcomeMessage)"</span>)</span><br><span class="line">//iOS</span><br><span class="line">NSLog(<span class="string">"%@"</span>, welcomeMessage);</span><br></pre></td></tr></table></figure>
<h4 id="可选类型-nil-强制解析"><a href="#可选类型-nil-强制解析" class="headerlink" title="可选类型 | nil | 强制解析"></a>可选类型 | nil | 强制解析</h4><h5 id="使用可选类型（optionals）来处理值可能缺失的情况。可选类型表示两种可能：-或者有值，-你可以解析可选类型访问这个值，-或者根本没有值。"><a href="#使用可选类型（optionals）来处理值可能缺失的情况。可选类型表示两种可能：-或者有值，-你可以解析可选类型访问这个值，-或者根本没有值。" class="headerlink" title="使用可选类型（optionals）来处理值可能缺失的情况。可选类型表示两种可能： 或者有值， 你可以解析可选类型访问这个值， 或者根本没有值。"></a>使用可选类型（optionals）来处理值可能缺失的情况。可选类型表示两种可能： 或者有值， 你可以解析可选类型访问这个值， 或者根本没有值。</h5><blockquote>
<p>注意  </p>
<p>C 和 Objective-C 中并没有可选类型这个概念。最接近的是 Objective-C 中的一个特性，一个方法要不返回一个对象要不返回 nil，nil 表示“缺少一个合法的对象”。然而，这只对对象起作用——对于结构体，基本的 C 类型或者枚举类型不起作用。对于这些类型，Objective-C 方法一般会返回一个特殊值（比如 NSNotFound）来暗示值缺失。这种方法假设方法的调用者知道并记得对特殊值进行判断。然而，Swift 的可选类型可以让你暗示任意类型的值缺失，并不需要一个特殊值。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> possibleNumber = <span class="string">"123"</span></span><br><span class="line"><span class="built_in">let</span> convertedNumber = Int(possibleNumber)</span><br><span class="line">// convertedNumber 被推测为类型 <span class="string">"Int?"</span>， 或者类型 <span class="string">"optional Int"</span></span><br></pre></td></tr></table></figure>
<h6 id="因为该构造器可能会失败，所以它返回一个可选类型（optional）Int，而不是一个-Int。"><a href="#因为该构造器可能会失败，所以它返回一个可选类型（optional）Int，而不是一个-Int。" class="headerlink" title="因为该构造器可能会失败，所以它返回一个可选类型（optional）Int，而不是一个 Int。"></a>因为该构造器可能会失败，所以它返回一个可选类型（optional）Int，而不是一个 Int。</h6><h5 id="nil：你可以给可选变量赋值为-nil-来表示它没有值："><a href="#nil：你可以给可选变量赋值为-nil-来表示它没有值：" class="headerlink" title="nil：你可以给可选变量赋值为 nil 来表示它没有值："></a>nil：你可以给可选变量赋值为 nil 来表示它没有值：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var serverResponseCode: Int? = 404</span><br><span class="line">// serverResponseCode 包含一个可选的 Int 值 404</span><br><span class="line">serverResponseCode = nil</span><br><span class="line">// serverResponseCode 现在不包含值</span><br><span class="line">var surveyAnswer: String?</span><br><span class="line">// surveyAnswer 被自动设置为 nil</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意  </p>
<p>nil 不能用于非可选的常量和变量。如果你的代码中有常量或者变量需要处理值缺失的情况，请把它们声明成对应的可选类型。</p>
<p>Swift 的 nil 和 Objective-C 中的 nil 并不一样。在 Objective-C 中，nil 是一个指向不存在对象的指针。在 Swift 中，nil 不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为 nil，不只是对象类型。</p>
</blockquote>
<p><img src="/2019/05/21/Swift学习笔记-一/nonoptionalvalueError.jpg" alt></p>
<h5 id="可选绑定"><a href="#可选绑定" class="headerlink" title="可选绑定"></a>可选绑定</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//如果 Int(possibleNumber) 返回的可选 Int 包含一个值，创建一个叫做 actualNumber 的新常量并将可选包含的值赋给它。</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">let</span> actualNumber = Int(possibleNumber) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\'\(possibleNumber)\' has an integer value of \(actualNumber)"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\'\(possibleNumber)\' could not be converted to an integer"</span>)</span><br><span class="line">&#125;</span><br><span class="line">// 输出“<span class="string">'123'</span> has an <span class="built_in">integer</span> value of 123”</span><br></pre></td></tr></table></figure>
<h5 id="强制解析"><a href="#强制解析" class="headerlink" title="强制解析"></a>强制解析</h5><h6 id="有时候在程序架构中，第一次被赋值之后，可以确定一个可选类型总会有值。在这种情况下，每次都要判断和解析可选值是非常低效的，因为可以确定它总会有值。"><a href="#有时候在程序架构中，第一次被赋值之后，可以确定一个可选类型总会有值。在这种情况下，每次都要判断和解析可选值是非常低效的，因为可以确定它总会有值。" class="headerlink" title="有时候在程序架构中，第一次被赋值之后，可以确定一个可选类型总会有值。在这种情况下，每次都要判断和解析可选值是非常低效的，因为可以确定它总会有值。"></a>有时候在程序架构中，第一次被赋值之后，可以确定一个可选类型总会有值。在这种情况下，每次都要判断和解析可选值是非常低效的，因为可以确定它总会有值。</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> possibleString: String? = <span class="string">"An optional string."</span></span><br><span class="line"><span class="built_in">let</span> forcedString: String = possibleString! // 需要感叹号来获取值</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> assumedString: String! = <span class="string">"An implicitly unwrapped optional string."</span></span><br><span class="line"><span class="built_in">let</span> implicitString: String = assumedString  // 不需要感叹号</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意  </p>
<p>如果你在隐式解析可选类型没有值的时候尝试取值，会触发运行时错误。和你在没有值的普通可选类型后面加一个惊叹号一样。</p>
</blockquote>
<hr>
<h2 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h2><blockquote>
<p>这里只介绍OC中没有的运算符</p>
</blockquote>
<h4 id="区间运算符"><a href="#区间运算符" class="headerlink" title="区间运算符"></a>区间运算符</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//[a,b] a&lt; b</span><br><span class="line">(a...b)</span><br><span class="line">//[a,b) a&lt;b</span><br><span class="line">(a..&lt;b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> 1...5 &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(index) * 5 = \(index * 5)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="运算符重载（略）"><a href="#运算符重载（略）" class="headerlink" title="运算符重载（略）"></a>运算符重载（略）</h4><h2 id="字符串和字符"><a href="#字符串和字符" class="headerlink" title="字符串和字符"></a>字符串和字符</h2><blockquote>
<p>Swift 的 String 类型与 Foundation NSString 类进行了无缝桥接。Foundation 还对 String 进行扩展使其可以访问 NSString 类型中定义的方法。这意味着调用那些 NSString 的方法，你无需进行任何类型转换。</p>
</blockquote>
<h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><h6 id="增删改、下标访问等"><a href="#增删改、下标访问等" class="headerlink" title="增删改、下标访问等"></a>增删改、下标访问等</h6><h4 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h4><h5 id="Objective-C（NSString）"><a href="#Objective-C（NSString）" class="headerlink" title="Objective-C（NSString）"></a>Objective-C（NSString）</h5><h6 id="NSString对象是用-UTF-16-编码的码元组成的数组。相应地，length-方法的返回值也是字符串包含的码元个数（而不是字符个数）。"><a href="#NSString对象是用-UTF-16-编码的码元组成的数组。相应地，length-方法的返回值也是字符串包含的码元个数（而不是字符个数）。" class="headerlink" title="NSString对象是用 UTF-16 编码的码元组成的数组。相应地，length 方法的返回值也是字符串包含的码元个数（而不是字符个数）。"></a>NSString对象是用 UTF-16 编码的码元组成的数组。相应地，length 方法的返回值也是字符串包含的码元个数（而不是字符个数）。</h6><h5 id="Swift（String）"><a href="#Swift（String）" class="headerlink" title="Swift（String）"></a>Swift（String）</h5><h6 id="每一个字符串都是由编码无关的-Unicode-字符组成。Swift-中通过多种-“View”-来区分处理字符串的方式，UTF8View-让你以-UTF-8-编码的方式来处理字符串，而-CharacterView-则让你以字符为单位处理字符串而不必考虑编码的问题。"><a href="#每一个字符串都是由编码无关的-Unicode-字符组成。Swift-中通过多种-“View”-来区分处理字符串的方式，UTF8View-让你以-UTF-8-编码的方式来处理字符串，而-CharacterView-则让你以字符为单位处理字符串而不必考虑编码的问题。" class="headerlink" title="每一个字符串都是由编码无关的 Unicode 字符组成。Swift 中通过多种 “View” 来区分处理字符串的方式，UTF8View 让你以 UTF-8 编码的方式来处理字符串，而 CharacterView 则让你以字符为单位处理字符串而不必考虑编码的问题。"></a>每一个字符串都是由编码无关的 Unicode 字符组成。Swift 中通过多种 “View” 来区分处理字符串的方式，UTF8View 让你以 UTF-8 编码的方式来处理字符串，而 CharacterView 则让你以字符为单位处理字符串而不必考虑编码的问题。</h6><p><img src="/2019/05/21/Swift学习笔记-一/uft-8_print.jpg" alt></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> codeUnit <span class="keyword">in</span> dogString.utf8 &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(codeUnit) "</span>, terminator: <span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">""</span>)</span><br><span class="line">// 68 111 103 226 128 188 240 159 144 182</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/21/Swift学习笔记-一/uft-16_print.jpg" alt></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> codeUnit <span class="keyword">in</span> dogString.utf16 &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(codeUnit) "</span>, terminator: <span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">""</span>)</span><br><span class="line">// 68 111 103 8252 55357 56374</span><br></pre></td></tr></table></figure>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h4 id="Swift-语言中的-Arrays、Sets-和-Dictionaries-中存储的数据值类型必须明确，即被现实为泛型集合。而Objective-C没有这样的要求（只要求存储的为对象）。"><a href="#Swift-语言中的-Arrays、Sets-和-Dictionaries-中存储的数据值类型必须明确，即被现实为泛型集合。而Objective-C没有这样的要求（只要求存储的为对象）。" class="headerlink" title="Swift 语言中的 Arrays、Sets 和 Dictionaries 中存储的数据值类型必须明确，即被现实为泛型集合。而Objective-C没有这样的要求（只要求存储的为对象）。"></a>Swift 语言中的 Arrays、Sets 和 Dictionaries 中存储的数据值类型必须明确，即被现实为泛型集合。而Objective-C没有这样的要求（只要求存储的为对象）。</h4><h3 id="数组-Arrays"><a href="#数组-Arrays" class="headerlink" title="数组(Arrays)"></a>数组(Arrays)</h3><h5 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//swift </span><br><span class="line">var shoppingList = [String]()</span><br><span class="line">var shoppingList: [String] = [<span class="string">"Eggs"</span>, <span class="string">"Milk"</span>]</span><br><span class="line">//...其他方法</span><br><span class="line">//OC 类似泛型的功能</span><br><span class="line">NSMutableArray &lt;NSString *&gt; *shoppingList = [NSMutableArray arrayWithArray:@[@<span class="string">"Eggs"</span>, @<span class="string">"Milk"</span>]];</span><br></pre></td></tr></table></figure>
<h5 id="修改数组"><a href="#修改数组" class="headerlink" title="修改数组"></a>修改数组</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//添加元素</span><br><span class="line">//swift</span><br><span class="line">shoppingList.insert(<span class="string">"Maple Syrup"</span>, at: 0)</span><br><span class="line">shoppingList.append(<span class="string">"Flour"</span>)</span><br><span class="line">//OC</span><br><span class="line">[shoppingList addObject:@<span class="string">"Flour"</span>];</span><br><span class="line">[shoppingList addObject:@<span class="string">"Flour"</span> atIndex:0];</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//添加数组</span><br><span class="line">//swift</span><br><span class="line">shoppingList += [<span class="string">"Chocolate Spread"</span>, <span class="string">"Cheese"</span>, <span class="string">"Butter"</span>];</span><br><span class="line">//OC</span><br><span class="line">[shoppingList addObjectFromArray:[<span class="string">"Chocolate Spread"</span>, <span class="string">"Cheese"</span>, <span class="string">"Butter"</span>]];</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//修改数组</span><br><span class="line">//swift</span><br><span class="line">shoppingList[0] = <span class="string">"Six eggs"</span></span><br><span class="line">shoppingList[4...6] = [<span class="string">"Bananas"</span>, <span class="string">"Apples"</span>]</span><br><span class="line">//OC</span><br><span class="line">shoppingList[0] = @<span class="string">"Six eggs"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//移除元素</span><br><span class="line">//swift</span><br><span class="line">shoppingList.remove(at:0);</span><br><span class="line">//OC</span><br><span class="line">[shoppingList removeObjectAtIndex:0];</span><br></pre></td></tr></table></figure>
<h5 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h5><h6 id="如果我们同时需要每个数据项的值和索引值，可以使用-enumerated-方法来进行数组遍历。enumerated-返回一个由每一个数据项索引值和数据值组成的元组。我们可以把这个元组分解成临时常量或者变量来进行遍历："><a href="#如果我们同时需要每个数据项的值和索引值，可以使用-enumerated-方法来进行数组遍历。enumerated-返回一个由每一个数据项索引值和数据值组成的元组。我们可以把这个元组分解成临时常量或者变量来进行遍历：" class="headerlink" title="如果我们同时需要每个数据项的值和索引值，可以使用 enumerated() 方法来进行数组遍历。enumerated() 返回一个由每一个数据项索引值和数据值组成的元组。我们可以把这个元组分解成临时常量或者变量来进行遍历："></a>如果我们同时需要每个数据项的值和索引值，可以使用 enumerated() 方法来进行数组遍历。enumerated() 返回一个由每一个数据项索引值和数据值组成的元组。我们可以把这个元组分解成临时常量或者变量来进行遍历：</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (index, value) <span class="keyword">in</span> shoppingList.<span class="function"><span class="title">enumerated</span></span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Item \(String(index + 1)): \(value)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="集合-Sets"><a href="#集合-Sets" class="headerlink" title="集合(Sets)"></a>集合(Sets)</h3><blockquote>
<p>   Q:集合和数组的区别？</p>
</blockquote>
<h5 id="集合（Set）用来存储相同类型并且没有确定顺序的值。当集合元素顺序不重要时或者希望确保每个元素只出现一次时可以使用集合而不是数组。"><a href="#集合（Set）用来存储相同类型并且没有确定顺序的值。当集合元素顺序不重要时或者希望确保每个元素只出现一次时可以使用集合而不是数组。" class="headerlink" title="集合（Set）用来存储相同类型并且没有确定顺序的值。当集合元素顺序不重要时或者希望确保每个元素只出现一次时可以使用集合而不是数组。"></a>集合（Set）用来存储相同类型并且没有确定顺序的值。当集合元素顺序不重要时或者希望确保每个元素只出现一次时可以使用集合而不是数组。</h5><h5 id="存储在集合中的类型，必须是可哈希化的。遵循协议Hashable。"><a href="#存储在集合中的类型，必须是可哈希化的。遵循协议Hashable。" class="headerlink" title="存储在集合中的类型，必须是可哈希化的。遵循协议Hashable。"></a>存储在集合中的类型，必须是可哈希化的。遵循协议Hashable。</h5><h5 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h5><p><img src="/2019/05/21/Swift学习笔记-一/set_operation.png" alt></p>
<blockquote>
<p>使用 intersection(<em>:) 方法根据两个集合中都包含的值创建的一个新的集合。<br>使用 symmetricDifference(</em>:) 方法根据在一个集合中但不在两个集合中的值创建一个新的集合。<br>使用 union(<em>:) 方法根据两个集合的值创建一个新的集合。<br>使用 subtracting(</em>:) 方法根据不在该集合中的值创建一个新的集合。</p>
</blockquote>
<h5 id="集合成员关系和相等"><a href="#集合成员关系和相等" class="headerlink" title="集合成员关系和相等"></a>集合成员关系和相等</h5><p>略</p>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><h5 id="Swift-的字典使用-Dictionary-lt-Key-Value-gt-定义，其中-Key-是字典中键的数据类型，Value-是字典中对应于这些键所存储值的数据类型。"><a href="#Swift-的字典使用-Dictionary-lt-Key-Value-gt-定义，其中-Key-是字典中键的数据类型，Value-是字典中对应于这些键所存储值的数据类型。" class="headerlink" title="Swift 的字典使用 Dictionary&lt;Key, Value&gt; 定义，其中 Key 是字典中键的数据类型，Value 是字典中对应于这些键所存储值的数据类型。"></a>Swift 的字典使用 Dictionary&lt;Key, Value&gt; 定义，其中 Key 是字典中键的数据类型，Value 是字典中对应于这些键所存储值的数据类型。</h5><blockquote>
<p>一个字典的 Key 类型必须遵循 Hashable 协议，就像 Set 的值类型。</p>
<p>Objective-C中NSDictionary的key必须是字符串。<br>Objective-C中NSDictionary对存储的Value类型一致性没有要求。但只能存储对象。</p>
</blockquote>
<h5 id="字典创建"><a href="#字典创建" class="headerlink" title="字典创建"></a>字典创建</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//swift</span><br><span class="line">var namesOfIntegers = [Int: String]()</span><br><span class="line">// namesOfIntegers 是一个空的 [Int: String] 字典</span><br><span class="line">//OC</span><br><span class="line">NSDictionary  *namesOfIntegers = [NSDictionary dictionary];</span><br></pre></td></tr></table></figure>
<h5 id="访问-amp-修改字典"><a href="#访问-amp-修改字典" class="headerlink" title="访问&amp;修改字典"></a>访问&amp;修改字典</h5><h6 id="基本一致"><a href="#基本一致" class="headerlink" title="基本一致"></a>基本一致</h6><h5 id="字典遍历"><a href="#字典遍历" class="headerlink" title="字典遍历"></a>字典遍历</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//swift</span><br><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> namesOfIntegers &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(key): \(value)"</span>)</span><br><span class="line">&#125;</span><br><span class="line">//OC</span><br><span class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> namesOfIntegers.allKeys) &#123;</span><br><span class="line">	//key is NSString object</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (value <span class="keyword">in</span> namesOfIntegers.allValues) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jackthenoob.github.io/2019/05/21/iOS内存管理-AutoreleasePool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="垂杨小梳雨">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lyddwn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/21/iOS内存管理-AutoreleasePool/" itemprop="url">iOS内存管理-AutoreleasePool</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-21T11:15:26+08:00">
                2019-05-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="待编写"><a href="#待编写" class="headerlink" title="待编写"></a>待编写</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jackthenoob.github.io/2019/05/21/Lighter-your-ViewController-打造轻量化ViewController/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="垂杨小梳雨">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lyddwn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/21/Lighter-your-ViewController-打造轻量化ViewController/" itemprop="url">Lighter your ViewController-打造轻量化ViewController</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-21T10:18:23+08:00">
                2019-05-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h5 id="随着业务的不断迭代，一些较大的业务模块的ViewController变得极为臃肿，越来越难以维护。为ViewController瘦身变成的越来越迫切。"><a href="#随着业务的不断迭代，一些较大的业务模块的ViewController变得极为臃肿，越来越难以维护。为ViewController瘦身变成的越来越迫切。" class="headerlink" title="随着业务的不断迭代，一些较大的业务模块的ViewController变得极为臃肿，越来越难以维护。为ViewController瘦身变成的越来越迫切。"></a>随着业务的不断迭代，一些较大的业务模块的ViewController变得极为臃肿，越来越难以维护。为ViewController瘦身变成的越来越迫切。</h5><h5 id="提供一些思路供大家参考。"><a href="#提供一些思路供大家参考。" class="headerlink" title="提供一些思路供大家参考。"></a>提供一些思路供大家参考。</h5><h2 id="1-Separate-out-UITableViewDataSource-and-UITableViewDelegate"><a href="#1-Separate-out-UITableViewDataSource-and-UITableViewDelegate" class="headerlink" title="1.Separate out UITableViewDataSource and UITableViewDelegate"></a>1.Separate out UITableViewDataSource and UITableViewDelegate</h2><h5 id="剥离DataSource和其他Protocols"><a href="#剥离DataSource和其他Protocols" class="headerlink" title="剥离DataSource和其他Protocols"></a>剥离DataSource和其他Protocols</h5><h5 id="这个方法最早见于objc-io上。将UITableViewDatasource相关的代码从ViewController中抽取并封装到其他类中。也相对提高重用性。"><a href="#这个方法最早见于objc-io上。将UITableViewDatasource相关的代码从ViewController中抽取并封装到其他类中。也相对提高重用性。" class="headerlink" title="这个方法最早见于objc.io上。将UITableViewDatasource相关的代码从ViewController中抽取并封装到其他类中。也相对提高重用性。"></a>这个方法最早见于objc.io上。将UITableViewDatasource相关的代码从ViewController中抽取并封装到其他类中。也相对提高重用性。</h5><h5 id="然后我在一个较大的业务中尝试使用了。感觉效果一般。"><a href="#然后我在一个较大的业务中尝试使用了。感觉效果一般。" class="headerlink" title="然后我在一个较大的业务中尝试使用了。感觉效果一般。"></a>然后我在一个较大的业务中尝试使用了。感觉效果一般。</h5><h5 id="示例工程中，有一个类PhotosViewController，里面原本有如下3个方法："><a href="#示例工程中，有一个类PhotosViewController，里面原本有如下3个方法：" class="headerlink" title="示例工程中，有一个类PhotosViewController，里面原本有如下3个方法："></a>示例工程中，有一个类PhotosViewController，里面原本有如下3个方法：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pragma mark Pragma </span></span><br><span class="line">  </span><br><span class="line">- (Photo*)photoAtIndexPath:(NSIndexPath*)indexPath &#123; </span><br><span class="line">	<span class="built_in">return</span> photos[(NSUInteger)indexPath.row]; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line">- (NSInteger)tableView:(UITableView*)tableView </span><br><span class="line">numberOfRowsInSection:(NSInteger)section &#123; </span><br><span class="line">	<span class="built_in">return</span> photos.count; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line">- (UITableViewCell*)tableView:(UITableView*)tableView </span><br><span class="line">cellForRowAtIndexPath:(NSIndexPath*)indexPath &#123; </span><br><span class="line">	PhotoCell* cell = [tableView dequeueReusableCellWithIdentifier:PhotoCellIdentifier forIndexPath:indexPath]; </span><br><span class="line">	Photo* photo = [self photoAtIndexPath:indexPath]; </span><br><span class="line">	cell.label.text = photo.name; </span><br><span class="line">	<span class="built_in">return</span> cell; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="如下代码所示，这里通过一个block来配置UITableViewCell，当然，也可以使用delegate对UITableViewCell进行配置，这主要取决于开发者。"><a href="#如下代码所示，这里通过一个block来配置UITableViewCell，当然，也可以使用delegate对UITableViewCell进行配置，这主要取决于开发者。" class="headerlink" title="如下代码所示，这里通过一个block来配置UITableViewCell，当然，也可以使用delegate对UITableViewCell进行配置，这主要取决于开发者。"></a>如下代码所示，这里通过一个block来配置UITableViewCell，当然，也可以使用delegate对UITableViewCell进行配置，这主要取决于开发者。</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@implementation ArrayDataSource </span><br><span class="line">  </span><br><span class="line">- (id)itemAtIndexPath:(NSIndexPath*)indexPath &#123; </span><br><span class="line">	<span class="built_in">return</span> items[(NSUInteger)indexPath.row]; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line">- (NSInteger)tableView:(UITableView*)tableView </span><br><span class="line">numberOfRowsInSection:(NSInteger)section &#123; </span><br><span class="line">	<span class="built_in">return</span> items.count; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line">- (UITableViewCell*)tableView:(UITableView*)tableView </span><br><span class="line">cellForRowAtIndexPath:(NSIndexPath*)indexPath &#123; </span><br><span class="line">	id cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier forIndexPath:indexPath]; </span><br><span class="line">	id item = [self itemAtIndexPath:indexPath]; </span><br><span class="line">	configureCellBlock(cell,item); </span><br><span class="line">	<span class="built_in">return</span> cell; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h5 id="可以把ViewController中的那3个方法移除掉，并创建自定义类的一个示例对象，然后将其设置为table-view的data-source，如下代码所示。"><a href="#可以把ViewController中的那3个方法移除掉，并创建自定义类的一个示例对象，然后将其设置为table-view的data-source，如下代码所示。" class="headerlink" title="可以把ViewController中的那3个方法移除掉，并创建自定义类的一个示例对象，然后将其设置为table view的data source，如下代码所示。"></a>可以把ViewController中的那3个方法移除掉，并创建自定义类的一个示例对象，然后将其设置为table view的data source，如下代码所示。</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">	void (^configureCell)(PhotoCell*, Photo*) = ^(PhotoCell* cell, Photo* photo) &#123; </span><br><span class="line">		cell.label.text = photo.name; </span><br><span class="line">	&#125;; </span><br><span class="line">	photosArrayDataSource = [[ArrayDataSource alloc] initWithItems:photos </span><br><span class="line">	cellIdentifier:PhotoCellIdentifier </span><br><span class="line">	configureCellBlock:configureCell]; </span><br><span class="line">	self.tableView.dataSource = photosArrayDataSource; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-Category"><a href="#2-Category" class="headerlink" title="2.Category"></a>2.Category</h2><h5 id="大体思路：根据当前业务，将业务拆分为多个小模块。创建多个Category，每个Category处理自己业务模块逻辑。"><a href="#大体思路：根据当前业务，将业务拆分为多个小模块。创建多个Category，每个Category处理自己业务模块逻辑。" class="headerlink" title="大体思路：根据当前业务，将业务拆分为多个小模块。创建多个Category，每个Category处理自己业务模块逻辑。"></a>大体思路：根据当前业务，将业务拆分为多个小模块。创建多个Category，每个Category处理自己业务模块逻辑。</h5><h5 id="目录结构如下："><a href="#目录结构如下：" class="headerlink" title="目录结构如下："></a>目录结构如下：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">OrderViewController.h</span><br><span class="line">OrderViewController.m</span><br><span class="line">OrderViewController+NetRequest.h</span><br><span class="line">OrderViewController+NetRequest.m</span><br><span class="line">OrderViewController+DataReport.h</span><br><span class="line">OrderViewController+DataReport.m</span><br><span class="line">OrderViewController+Address.h</span><br><span class="line">OrderViewController+Address.m</span><br><span class="line">OrderViewController+Shipping.h</span><br><span class="line">OrderViewController+Shipping.m</span><br><span class="line">OrderViewController+Invoice.h</span><br><span class="line">OrderViewController+Invoice.m</span><br><span class="line">OrderViewController+Wallet.h</span><br><span class="line">OrderViewController+Wallet.m</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h5 id="上面目录结构是电商的订单提交页面，主体功能可以分为订单地址、配送信息、发票、钱包等业务场景，再将网络请求、数据上报等功能抽离到相应Category，实现代码分离。减少主ViewController大小。"><a href="#上面目录结构是电商的订单提交页面，主体功能可以分为订单地址、配送信息、发票、钱包等业务场景，再将网络请求、数据上报等功能抽离到相应Category，实现代码分离。减少主ViewController大小。" class="headerlink" title="上面目录结构是电商的订单提交页面，主体功能可以分为订单地址、配送信息、发票、钱包等业务场景，再将网络请求、数据上报等功能抽离到相应Category，实现代码分离。减少主ViewController大小。"></a>上面目录结构是电商的订单提交页面，主体功能可以分为订单地址、配送信息、发票、钱包等业务场景，再将网络请求、数据上报等功能抽离到相应Category，实现代码分离。减少主ViewController大小。</h5><h5 id="其实还是比较简单有效的方法。如果要说弊端，那最多可能稍微拖慢App加载速度吧。"><a href="#其实还是比较简单有效的方法。如果要说弊端，那最多可能稍微拖慢App加载速度吧。" class="headerlink" title="其实还是比较简单有效的方法。如果要说弊端，那最多可能稍微拖慢App加载速度吧。"></a>其实还是比较简单有效的方法。如果要说弊端，那最多可能稍微拖慢App加载速度吧。</h5><h2 id="3-模块化调用"><a href="#3-模块化调用" class="headerlink" title="3.模块化调用"></a>3.模块化调用</h2><h5 id="将一些业务逻辑处理封装到其他类中，由ViewController去调用这些类。即：不要在ViewController中做一些复杂的逻辑处理，由其他类代理处理"><a href="#将一些业务逻辑处理封装到其他类中，由ViewController去调用这些类。即：不要在ViewController中做一些复杂的逻辑处理，由其他类代理处理" class="headerlink" title="将一些业务逻辑处理封装到其他类中，由ViewController去调用这些类。即：不要在ViewController中做一些复杂的逻辑处理，由其他类代理处理"></a>将一些业务逻辑处理封装到其他类中，由ViewController去调用这些类。即：不要在ViewController中做一些复杂的逻辑处理，由其他类代理处理</h5><h4 id="比如："><a href="#比如：" class="headerlink" title="比如："></a>比如：</h4><ul>
<li>业务Model自己逻辑自己处理。VC只负责调用。</li>
<li>网络请求、数据处理服务创建相应Manager类处理。</li>
<li>复杂的View结构通过添加子ViewController实现。</li>
<li>使用KVO。比如你创建一个列表，数据需要通过网络请求刷新[webservice fetchNewData],通过KVO可以实现多个网络请求的自动刷新。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h5 id="这些只是可供大家参考的方法，目的是为了编写方便维护的、可读性高的代码。"><a href="#这些只是可供大家参考的方法，目的是为了编写方便维护的、可读性高的代码。" class="headerlink" title="这些只是可供大家参考的方法，目的是为了编写方便维护的、可读性高的代码。"></a>这些只是可供大家参考的方法，目的是为了编写方便维护的、可读性高的代码。</h5><h5 id="写于2015-01-19"><a href="#写于2015-01-19" class="headerlink" title="写于2015-01-19"></a>写于2015-01-19</h5>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jackthenoob.github.io/2019/05/20/iOS内存管理-ARC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="垂杨小梳雨">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lyddwn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/20/iOS内存管理-ARC/" itemprop="url">iOS内存管理-ARC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-20T18:25:19+08:00">
                2019-05-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是ARC"><a href="#什么是ARC" class="headerlink" title="什么是ARC"></a>什么是ARC</h2><h5 id="ARC（Automatic-Reference-Counting）是在iOS5-0推出的新功能，是新LLVM-3-0编译器的特性。简单地说，就是代码中自动加入了retain-release，原先需要手动添加的用来处理内存管理的引用计数的代码可以自动地由编译器完成了。"><a href="#ARC（Automatic-Reference-Counting）是在iOS5-0推出的新功能，是新LLVM-3-0编译器的特性。简单地说，就是代码中自动加入了retain-release，原先需要手动添加的用来处理内存管理的引用计数的代码可以自动地由编译器完成了。" class="headerlink" title="ARC（Automatic Reference Counting）是在iOS5.0推出的新功能，是新LLVM 3.0编译器的特性。简单地说，就是代码中自动加入了retain/release，原先需要手动添加的用来处理内存管理的引用计数的代码可以自动地由编译器完成了。"></a>ARC（Automatic Reference Counting）是在iOS5.0推出的新功能，是新LLVM 3.0编译器的特性。简单地说，就是代码中自动加入了retain/release，原先需要手动添加的用来处理内存管理的引用计数的代码可以自动地由编译器完成了。</h5><h5 id="ARC是编译器特性，而不是iOS运行时特性（除了weak指针系统-它会在所指向的内存释放的时候自动将自身置为nil，后面文章会专门说下），它也不是其它语言中的垃圾收集器。因此ARC和手动内存管理性能是一样的，有些时候还能更加快速，因为编译器还可以执行某些优化。"><a href="#ARC是编译器特性，而不是iOS运行时特性（除了weak指针系统-它会在所指向的内存释放的时候自动将自身置为nil，后面文章会专门说下），它也不是其它语言中的垃圾收集器。因此ARC和手动内存管理性能是一样的，有些时候还能更加快速，因为编译器还可以执行某些优化。" class="headerlink" title="ARC是编译器特性，而不是iOS运行时特性（除了weak指针系统,它会在所指向的内存释放的时候自动将自身置为nil，后面文章会专门说下），它也不是其它语言中的垃圾收集器。因此ARC和手动内存管理性能是一样的，有些时候还能更加快速，因为编译器还可以执行某些优化。"></a>ARC是编译器特性，而不是iOS运行时特性（除了weak指针系统,它会在所指向的内存释放的时候自动将自身置为nil，后面文章会专门说下），它也不是其它语言中的垃圾收集器。因此ARC和手动内存管理性能是一样的，有些时候还能更加快速，因为编译器还可以执行某些优化。</h5><h2 id="ARC使用规则"><a href="#ARC使用规则" class="headerlink" title="ARC使用规则"></a>ARC使用规则</h2><h5 id="ARC下，指针保持对象的生命。只有还有一个变量（strong）指向对象，对象就会保持在内存中。"><a href="#ARC下，指针保持对象的生命。只有还有一个变量（strong）指向对象，对象就会保持在内存中。" class="headerlink" title="ARC下，指针保持对象的生命。只有还有一个变量（strong）指向对象，对象就会保持在内存中。"></a>ARC下，指针保持对象的生命。只有还有一个变量（strong）指向对象，对象就会保持在内存中。</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *firstName = self.textField.text;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/20/iOS内存管理-ARC/a001.png" alt></p>
<h5 id="上图中，firstName现在指向NSString对象，这时这个对象（textField的内容字符串）将被hold住。比如用字符串-“Ray”作为例子（字符串的retainCount规则和普通的对象不一样，这边就把它当作一个普通的对象来看吧…），这个时候firstName持有了-”Ray”。retainCount-＝-1。"><a href="#上图中，firstName现在指向NSString对象，这时这个对象（textField的内容字符串）将被hold住。比如用字符串-“Ray”作为例子（字符串的retainCount规则和普通的对象不一样，这边就把它当作一个普通的对象来看吧…），这个时候firstName持有了-”Ray”。retainCount-＝-1。" class="headerlink" title="上图中，firstName现在指向NSString对象，这时这个对象（textField的内容字符串）将被hold住。比如用字符串@“Ray”作为例子（字符串的retainCount规则和普通的对象不一样，这边就把它当作一个普通的对象来看吧…），这个时候firstName持有了@”Ray”。retainCount ＝ 1。"></a>上图中，firstName现在指向NSString对象，这时这个对象（textField的内容字符串）将被hold住。比如用字符串@“Ray”作为例子（字符串的retainCount规则和普通的对象不一样，这边就把它当作一个普通的对象来看吧…），这个时候firstName持有了@”Ray”。retainCount ＝ 1。</h5><p><img src="/2019/05/20/iOS内存管理-ARC/a002.png" alt></p>
<h5 id="一个对象可以有多个拥有者-如上图：retainCount-2。"><a href="#一个对象可以有多个拥有者-如上图：retainCount-2。" class="headerlink" title="一个对象可以有多个拥有者,如上图：retainCount=2。"></a>一个对象可以有多个拥有者,如上图：retainCount=2。</h5><h5 id="当用户修改了文本框的text后，此时text属性会指向新的对象。原来的对象仍有firstName指向"><a href="#当用户修改了文本框的text后，此时text属性会指向新的对象。原来的对象仍有firstName指向" class="headerlink" title="当用户修改了文本框的text后，此时text属性会指向新的对象。原来的对象仍有firstName指向"></a>当用户修改了文本框的text后，此时text属性会指向新的对象。原来的对象仍有firstName指向</h5><p><img src="/2019/05/20/iOS内存管理-ARC/a003.png" alt></p>
<h5 id="而当firstName指向另外一个对象时，或者超出作用域范围时，-“Ray”这个字符串对象不在有任何所有者，retainCount-＝-0，将会被释放。"><a href="#而当firstName指向另外一个对象时，或者超出作用域范围时，-“Ray”这个字符串对象不在有任何所有者，retainCount-＝-0，将会被释放。" class="headerlink" title="而当firstName指向另外一个对象时，或者超出作用域范围时，@“Ray”这个字符串对象不在有任何所有者，retainCount ＝ 0，将会被释放。"></a>而当firstName指向另外一个对象时，或者超出作用域范围时，@“Ray”这个字符串对象不在有任何所有者，retainCount ＝ 0，将会被释放。</h5><p><img src="/2019/05/20/iOS内存管理-ARC/a004.png" alt></p>
<h5 id="WARNING-上面我们所说的firstName、text这些指针都是“Strong”，能够保持对象的生命。默认的实例、本地变量都是Strong类型。"><a href="#WARNING-上面我们所说的firstName、text这些指针都是“Strong”，能够保持对象的生命。默认的实例、本地变量都是Strong类型。" class="headerlink" title="WARNING:上面我们所说的firstName、text这些指针都是“Strong”，能够保持对象的生命。默认的实例、本地变量都是Strong类型。"></a>WARNING:上面我们所说的firstName、text这些指针都是“Strong”，能够保持对象的生命。默认的实例、本地变量都是Strong类型。</h5><h5 id="这边再提下刚刚我们说到的ARC的一个基本规则。"><a href="#这边再提下刚刚我们说到的ARC的一个基本规则。" class="headerlink" title="这边再提下刚刚我们说到的ARC的一个基本规则。"></a>这边再提下刚刚我们说到的ARC的一个基本规则。</h5><font color="#e4393c" size="3">只要某个对象被任一strong指针指向，那么它将不会被销毁。如果对象没有被任何strong指针指向，那么就将被销毁。</font>

<h4 id="weak指针"><a href="#weak指针" class="headerlink" title="weak指针"></a>weak指针</h4><h5 id="weak变量仍然指向一个对象，但不是对象的拥有者："><a href="#weak变量仍然指向一个对象，但不是对象的拥有者：" class="headerlink" title="weak变量仍然指向一个对象，但不是对象的拥有者："></a>weak变量仍然指向一个对象，但不是对象的拥有者：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__weak NSString *weakName = self.textField.text;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/20/iOS内存管理-ARC/a005.png" alt></p>
<h5 id="当self-textField-text指向其他对象，-此时weakName会自动变成nil，称为“zeroing”-weak-pointer："><a href="#当self-textField-text指向其他对象，-此时weakName会自动变成nil，称为“zeroing”-weak-pointer：" class="headerlink" title="当self.textField.text指向其他对象， 此时weakName会自动变成nil，称为“zeroing” weak pointer："></a>当self.textField.text指向其他对象， 此时weakName会自动变成nil，称为“zeroing” weak pointer：</h5><p><img src="/2019/05/20/iOS内存管理-ARC/a006.png" alt></p>
<h5 id="它解决了MRC下assign指针指向已经释放的对象（我们常说的野指针），对它发送消息Crash的问题。"><a href="#它解决了MRC下assign指针指向已经释放的对象（我们常说的野指针），对它发送消息Crash的问题。" class="headerlink" title="它解决了MRC下assign指针指向已经释放的对象（我们常说的野指针），对它发送消息Crash的问题。"></a>它解决了MRC下assign指针指向已经释放的对象（我们常说的野指针），对它发送消息Crash的问题。</h5><p><img src="/2019/05/20/iOS内存管理-ARC/a007.png" alt></p>
<hr>
<h5 id="ARC可以节省代码（MRC下属性赋值），我们不需要关心什么时候retain、release。但是不意味着我们不需要考虑内存管理"><a href="#ARC可以节省代码（MRC下属性赋值），我们不需要关心什么时候retain、release。但是不意味着我们不需要考虑内存管理" class="headerlink" title="ARC可以节省代码（MRC下属性赋值），我们不需要关心什么时候retain、release。但是不意味着我们不需要考虑内存管理"></a>ARC可以节省代码（MRC下属性赋值），我们不需要关心什么时候retain、release。但是不意味着我们不需要考虑内存管理</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id obj = [array objectAtIndex:0];</span><br><span class="line">[array removeObjectAtIndex:0];</span><br><span class="line">NSLog(@<span class="string">"%@"</span>, obj);</span><br></pre></td></tr></table></figure>
<p>上面代码在MRC下是错误的。从Array中移除一个对象会使对象不可用，对象不属于Array时会立即被释放。随后NSLog()打印该对象就会导致应用崩溃。 </p>
<p>而在ARC中这段代码是完全合法的。因为obj变量是一个strong指针，它成为了对象的拥有者，从Array中移除该对象也不会导致对象被释放。 </p>
<h5 id="内存管理其他注意点："><a href="#内存管理其他注意点：" class="headerlink" title="内存管理其他注意点："></a>内存管理其他注意点：</h5><ul>
<li>通知、KVO需要释放。（可在dealloc中）</li>
<li>NSTimer（rep=true）会强引用传入的target。</li>
<li>Block</li>
</ul>
<h5 id="ARC限制：-用于NSObject对象。"><a href="#ARC限制：-用于NSObject对象。" class="headerlink" title="ARC限制： 用于NSObject对象。"></a>ARC限制： 用于NSObject对象。</h5><h5 id="如果应用使用了Core-Foundation或malloc-free-，此时需要你来管理内存（这个我们下面再说）"><a href="#如果应用使用了Core-Foundation或malloc-free-，此时需要你来管理内存（这个我们下面再说）" class="headerlink" title="如果应用使用了Core Foundation或malloc()/free()，此时需要你来管理内存（这个我们下面再说）"></a>如果应用使用了Core Foundation或malloc()/free()，此时需要你来管理内存（这个我们下面再说）</h5><hr>
<h2 id="Xcode的ARC自动迁移"><a href="#Xcode的ARC自动迁移" class="headerlink" title="Xcode的ARC自动迁移"></a>Xcode的ARC自动迁移</h2><h5 id="要启用一个项目的ARC，你有以下几种选择："><a href="#要启用一个项目的ARC，你有以下几种选择：" class="headerlink" title="要启用一个项目的ARC，你有以下几种选择："></a>要启用一个项目的ARC，你有以下几种选择：</h5><ul>
<li>Xcode带了一个自动转换工具，可以迁移源代码至ARC</li>
<li>你可以手动转换源文件</li>
<li>你可以在Xcode中禁用某些文件使用ARC，这点对于第三方库非常有用。</li>
</ul>
<h5 id="这边说下测试提出的需要将IBOutlet改为Strong的事情。"><a href="#这边说下测试提出的需要将IBOutlet改为Strong的事情。" class="headerlink" title="这边说下测试提出的需要将IBOutlet改为Strong的事情。"></a>这边说下测试提出的需要将IBOutlet改为Strong的事情。</h5><h5 id="在ARC中，所有outlet属性都推荐使用weak，这些view对象已经属于View-Controller的view-hierarchy，不需要再次定义为strong（ARC中效果等同于retain）。唯一应该使用strong的outlet是File’s-Owner，连接到nib的顶层对象。"><a href="#在ARC中，所有outlet属性都推荐使用weak，这些view对象已经属于View-Controller的view-hierarchy，不需要再次定义为strong（ARC中效果等同于retain）。唯一应该使用strong的outlet是File’s-Owner，连接到nib的顶层对象。" class="headerlink" title="在ARC中，所有outlet属性都推荐使用weak，这些view对象已经属于View Controller的view hierarchy，不需要再次定义为strong（ARC中效果等同于retain）。唯一应该使用strong的outlet是File’s Owner，连接到nib的顶层对象。"></a>在ARC中，所有<em>outlet</em>属性都推荐使用weak，这些view对象已经属于View Controller的view hierarchy，不需要再次定义为strong（ARC中效果等同于retain）。唯一应该使用strong的outlet是File’s Owner，连接到nib的顶层对象。</h5><hr>
<h2 id="ARC中dealloc与autorelease"><a href="#ARC中dealloc与autorelease" class="headerlink" title="ARC中dealloc与autorelease"></a>ARC中dealloc与autorelease</h2><h3 id="dealloc"><a href="#dealloc" class="headerlink" title="dealloc"></a>dealloc</h3><h5 id="在ARC下我们一般不需要写dealloc函数。因为我们不需要调用-super-dealloc-也不需要release属性。而Strong属性出了作用域（这个class）会被置为nil，对象相应的会被释放销毁。（内存从创建到如何销毁下面文章会写到）"><a href="#在ARC下我们一般不需要写dealloc函数。因为我们不需要调用-super-dealloc-也不需要release属性。而Strong属性出了作用域（这个class）会被置为nil，对象相应的会被释放销毁。（内存从创建到如何销毁下面文章会写到）" class="headerlink" title="在ARC下我们一般不需要写dealloc函数。因为我们不需要调用[super dealloc],也不需要release属性。而Strong属性出了作用域（这个class）会被置为nil，对象相应的会被释放销毁。（内存从创建到如何销毁下面文章会写到）"></a>在ARC下我们一般不需要写dealloc函数。因为我们不需要调用[super dealloc],也不需要release属性。而Strong属性出了作用域（这个class）会被置为nil，对象相应的会被释放销毁。（内存从创建到如何销毁下面文章会写到）</h5><h5 id="而dealloc函数还是会被调用执行的，在这个函数里面，我们有时候需要释放CoreFoundation对象、remove-observer、remove-KVO以及一些其他资源（-AudioServicesDisposeSystemSoundID-soundID-）"><a href="#而dealloc函数还是会被调用执行的，在这个函数里面，我们有时候需要释放CoreFoundation对象、remove-observer、remove-KVO以及一些其他资源（-AudioServicesDisposeSystemSoundID-soundID-）" class="headerlink" title="而dealloc函数还是会被调用执行的，在这个函数里面，我们有时候需要释放CoreFoundation对象、remove observer、remove KVO以及一些其他资源（ AudioServicesDisposeSystemSoundID(soundID); ）"></a>而dealloc函数还是会被调用执行的，在这个函数里面，我们有时候需要释放CoreFoundation对象、remove observer、remove KVO以及一些其他资源（ AudioServicesDisposeSystemSoundID(soundID); ）</h5><h5 id="这里要注意的是：不要在dealloc函数中释放Timer。NSTimer会保持一份target强引用，导致这个Class永远不会被释放。所以需要在对象Class销毁前做处理"><a href="#这里要注意的是：不要在dealloc函数中释放Timer。NSTimer会保持一份target强引用，导致这个Class永远不会被释放。所以需要在对象Class销毁前做处理" class="headerlink" title="这里要注意的是：不要在dealloc函数中释放Timer。NSTimer会保持一份target强引用，导致这个Class永远不会被释放。所以需要在对象Class销毁前做处理"></a>这里要注意的是：不要在dealloc函数中释放Timer。NSTimer会保持一份target强引用，导致这个Class永远不会被释放。所以需要在对象Class销毁前做处理</h5><h5 id="在Github上有个开源项目MSWeakTimer。"><a href="#在Github上有个开源项目MSWeakTimer。" class="headerlink" title="在Github上有个开源项目MSWeakTimer。"></a>在Github上有个开源项目<a href="https://github.com/mindsnacks/MSWeakTimer" target="_blank" rel="noopener">MSWeakTimer</a>。</h5><h3 id="autoreleasepool"><a href="#autoreleasepool" class="headerlink" title="autoreleasepool"></a>autoreleasepool</h3><h5 id="ARC仍然保留了AutoreleasePool，但是采用了新的Block语法，于是我们的main函数会如下修改："><a href="#ARC仍然保留了AutoreleasePool，但是采用了新的Block语法，于是我们的main函数会如下修改：" class="headerlink" title="ARC仍然保留了AutoreleasePool，但是采用了新的Block语法，于是我们的main函数会如下修改："></a>ARC仍然保留了AutoreleasePool，但是采用了新的Block语法，于是我们的main函数会如下修改：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];</span><br><span class="line">int retVal = UIApplicationMain(argc, argv, nil,</span><br><span class="line">NSStringFromClass([AppDelegate class]));</span><br><span class="line">[pool release];</span><br><span class="line"><span class="built_in">return</span> retVal;</span><br></pre></td></tr></table></figure>
<h5 id="修改为："><a href="#修改为：" class="headerlink" title="修改为："></a>修改为：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">	int retVal = UIApplicationMain(argc, argv, nil,</span><br><span class="line">	NSStringFromClass([AppDelegate class]));</span><br><span class="line">	<span class="built_in">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Core-Foundation的内存管理-Toll-Free-Bridge"><a href="#Core-Foundation的内存管理-Toll-Free-Bridge" class="headerlink" title="Core Foundation的内存管理-Toll-Free Bridge"></a>Core Foundation的内存管理-Toll-Free Bridge</h2><h5 id="在ARC下，objective-c对象与Core-Foundation对象相互转换时，需要用到briage-cast。"><a href="#在ARC下，objective-c对象与Core-Foundation对象相互转换时，需要用到briage-cast。" class="headerlink" title="在ARC下，objective-c对象与Core Foundation对象相互转换时，需要用到briage cast。"></a>在ARC下，objective-c对象与Core Foundation对象相互转换时，需要用到briage cast。</h5><h5 id="举个栗子：NSString和CFStringRef就可以同等对待，在任何地方都可以互换使用，背后的设计就是toll-free-bridging。"><a href="#举个栗子：NSString和CFStringRef就可以同等对待，在任何地方都可以互换使用，背后的设计就是toll-free-bridging。" class="headerlink" title="举个栗子：NSString和CFStringRef就可以同等对待，在任何地方都可以互换使用，背后的设计就是toll-free bridging。"></a>举个栗子：NSString和CFStringRef就可以同等对待，在任何地方都可以互换使用，背后的设计就是toll-free bridging。</h5><p>在ARC之前，我们时这么处理的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFStringRef s1 = (CFStringRef) [[NSString alloc] initWithFormat:@<span class="string">"Hello, %@!"</span>, name];</span><br></pre></td></tr></table></figure></p>
<h5 id="当然，alloc分配了NSString对象，你需要在使用完之后进行释放，注意是释放转换后的CFStringRef对象："><a href="#当然，alloc分配了NSString对象，你需要在使用完之后进行释放，注意是释放转换后的CFStringRef对象：" class="headerlink" title="当然，alloc分配了NSString对象，你需要在使用完之后进行释放，注意是释放转换后的CFStringRef对象："></a>当然，alloc分配了NSString对象，你需要在使用完之后进行释放，注意是释放转换后的CFStringRef对象：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFRelease(s1);</span><br></pre></td></tr></table></figure>
<h5 id="反过来，从Core-Foundation到Objective-C的方向也类似："><a href="#反过来，从Core-Foundation到Objective-C的方向也类似：" class="headerlink" title="反过来，从Core Foundation到Objective-C的方向也类似："></a>反过来，从Core Foundation到Objective-C的方向也类似：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CFStringRef s2 = CFStringCreateWithCString(kCFAllocatorDefault, bytes, kCFStringEncodingMacRoman);</span><br><span class="line">NSString *s3 = (NSString *)s2;</span><br><span class="line">// release the object when you<span class="string">'re done</span></span><br><span class="line"><span class="string">[s3 release];</span></span><br></pre></td></tr></table></figure>
<h5 id="在ARC下，情况变得不一样！以下代码在手动内存管理中是完全合法的，但在ARC中却存在问题："><a href="#在ARC下，情况变得不一样！以下代码在手动内存管理中是完全合法的，但在ARC中却存在问题：" class="headerlink" title="在ARC下，情况变得不一样！以下代码在手动内存管理中是完全合法的，但在ARC中却存在问题："></a>在ARC下，情况变得不一样！以下代码在手动内存管理中是完全合法的，但在ARC中却存在问题：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)escape:(NSString *)text</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">return</span> [(NSString *)CFURLCreateStringByAddingPercentEscapes(</span><br><span class="line">							NULL,</span><br><span class="line">							(CFStringRef)text,</span><br><span class="line">							NULL,</span><br><span class="line">							(CFStringRef)@<span class="string">"!*'();:@&amp;=+$,/?%#[]"</span>, // 这里不需要bridging casts，因为这是一个常量，不需要释放！</span><br><span class="line"> 							CFStringConvertNSStringEncodingToEncoding(NSUTF8StringEncoding)) autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="#e4393c" size="4">在ARC下编译器必须知道由谁来负责释放转换后的对象</font>

<h5 id="如果你把一个NSObject当作Core-Foundation对象来使用，则ARC将不再负责释放该对象。但你必须明确地告诉ARC你的这个意图，编译器没办法自己做主。"><a href="#如果你把一个NSObject当作Core-Foundation对象来使用，则ARC将不再负责释放该对象。但你必须明确地告诉ARC你的这个意图，编译器没办法自己做主。" class="headerlink" title="如果你把一个NSObject当作Core Foundation对象来使用，则ARC将不再负责释放该对象。但你必须明确地告诉ARC你的这个意图，编译器没办法自己做主。"></a>如果你把一个NSObject当作Core Foundation对象来使用，则ARC将不再负责释放该对象。但你必须明确地告诉ARC你的这个意图，编译器没办法自己做主。</h5><h5 id="同样如果你创建一个Core-Foundation对象并把它转换为NSObject对象，你也必须告诉ARC占据对象的所有权，并在适当的时候释放该对象。这就是所谓的bridging-casts。"><a href="#同样如果你创建一个Core-Foundation对象并把它转换为NSObject对象，你也必须告诉ARC占据对象的所有权，并在适当的时候释放该对象。这就是所谓的bridging-casts。" class="headerlink" title="同样如果你创建一个Core Foundation对象并把它转换为NSObject对象，你也必须告诉ARC占据对象的所有权，并在适当的时候释放该对象。这就是所谓的bridging casts。"></a>同样如果你创建一个Core Foundation对象并把它转换为NSObject对象，你也必须告诉ARC占据对象的所有权，并在适当的时候释放该对象。这就是所谓的bridging casts。</h5><h5 id="上面代码中，CFURLCreateStringByAddingPercentEscapes-函数的参数需要两个CFStringRef对象，其中常量NSString可以直接转换，因为不需要进行对象释放；但是-text-参数不一样，它是传递进来的一个NSString对象。而函数参数和局部变量一样，都是strong指针，这种对象在函数入口处会被retain，并且对象会持续存在直到指针被销毁（这里也就是函数返回时）。"><a href="#上面代码中，CFURLCreateStringByAddingPercentEscapes-函数的参数需要两个CFStringRef对象，其中常量NSString可以直接转换，因为不需要进行对象释放；但是-text-参数不一样，它是传递进来的一个NSString对象。而函数参数和局部变量一样，都是strong指针，这种对象在函数入口处会被retain，并且对象会持续存在直到指针被销毁（这里也就是函数返回时）。" class="headerlink" title="上面代码中，CFURLCreateStringByAddingPercentEscapes()函数的参数需要两个CFStringRef对象，其中常量NSString可以直接转换，因为不需要进行对象释放；但是 text 参数不一样，它是传递进来的一个NSString对象。而函数参数和局部变量一样，都是strong指针，这种对象在函数入口处会被retain，并且对象会持续存在直到指针被销毁（这里也就是函数返回时）。"></a>上面代码中，CFURLCreateStringByAddingPercentEscapes()函数的参数需要两个CFStringRef对象，其中常量NSString可以直接转换，因为不需要进行对象释放；但是 text 参数不一样，它是传递进来的一个NSString对象。而函数参数和局部变量一样，都是strong指针，这种对象在函数入口处会被retain，并且对象会持续存在直到指针被销毁（这里也就是函数返回时）。</h5><h5 id="对于text参数，我们希望ARC保持这个变量的所有权，同时又希望临时将它当作CFStringRef对象来使用。这种情况下可以使用-bridge说明符，它告诉ARC不要更改对象的所有权，按普通规则释放该对象即可。"><a href="#对于text参数，我们希望ARC保持这个变量的所有权，同时又希望临时将它当作CFStringRef对象来使用。这种情况下可以使用-bridge说明符，它告诉ARC不要更改对象的所有权，按普通规则释放该对象即可。" class="headerlink" title="对于text参数，我们希望ARC保持这个变量的所有权，同时又希望临时将它当作CFStringRef对象来使用。这种情况下可以使用__bridge说明符，它告诉ARC不要更改对象的所有权，按普通规则释放该对象即可。"></a>对于text参数，我们希望ARC保持这个变量的所有权，同时又希望临时将它当作CFStringRef对象来使用。这种情况下可以使用__bridge说明符，它告诉ARC不要更改对象的所有权，按普通规则释放该对象即可。</h5><h5 id="多数情况下，Objective-C对象和Core-Foundation对象之间互相转换时，我们都应该使用-bridge。"><a href="#多数情况下，Objective-C对象和Core-Foundation对象之间互相转换时，我们都应该使用-bridge。" class="headerlink" title="多数情况下，Objective-C对象和Core Foundation对象之间互相转换时，我们都应该使用__bridge。"></a>多数情况下，Objective-C对象和Core Foundation对象之间互相转换时，我们都应该使用__bridge。</h5><h4 id="但是-它lei来了"><a href="#但是-它lei来了" class="headerlink" title="但是~它lei来了"></a>但是~它lei来了</h4><h5 id="但是有时候我们确实需要给予ARC某个对象的所有权，或者解除ARC对某个对象的所有权。这种情况下我们就需要使用另外两种bridging-casts："><a href="#但是有时候我们确实需要给予ARC某个对象的所有权，或者解除ARC对某个对象的所有权。这种情况下我们就需要使用另外两种bridging-casts：" class="headerlink" title="但是有时候我们确实需要给予ARC某个对象的所有权，或者解除ARC对某个对象的所有权。这种情况下我们就需要使用另外两种bridging casts："></a>但是有时候我们确实需要给予ARC某个对象的所有权，或者解除ARC对某个对象的所有权。这种情况下我们就需要使用另外两种bridging casts：</h5><ul>
<li>__bridge_transfer：给予ARC所有权</li>
<li>__bridge_retained：解除ARC所有权</li>
</ul>
<h5 id="因为-CFURLCreateStringByAddingPercentEscapes-函数创建了一个新的CFStringRef对象-而我们要的是NSString对象，因此我们要强制转换。"><a href="#因为-CFURLCreateStringByAddingPercentEscapes-函数创建了一个新的CFStringRef对象-而我们要的是NSString对象，因此我们要强制转换。" class="headerlink" title="因为 CFURLCreateStringByAddingPercentEscapes() 函数创建了一个新的CFStringRef对象,而我们要的是NSString对象，因此我们要强制转换。"></a>因为 CFURLCreateStringByAddingPercentEscapes() 函数创建了一个新的CFStringRef对象,而我们要的是NSString对象，因此我们要强制转换。</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CFStringRef result = CFURLCreateStringByAddingPercentEscapes(. . .);</span><br><span class="line">NSString *s = (NSString *)result;</span><br><span class="line"><span class="built_in">return</span> s;</span><br></pre></td></tr></table></figure>
<h5 id="当我们不需要强制转换为NSObject对象时，我们只需要调用CFRelease方法即可"><a href="#当我们不需要强制转换为NSObject对象时，我们只需要调用CFRelease方法即可" class="headerlink" title="当我们不需要强制转换为NSObject对象时，我们只需要调用CFRelease方法即可"></a>当我们不需要强制转换为NSObject对象时，我们只需要调用CFRelease方法即可</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">do</span> something with the result </span><br><span class="line">CGRelease(result)</span><br></pre></td></tr></table></figure>
<font color="#e4393c" size="4">ARC只能作业于Objective-c对象。那么问题来了 既然我们创建了一个Core Foundation对象 谁来负责释放它？</font>

<h4 id="这里需要我们使用-bridge-transfer"><a href="#这里需要我们使用-bridge-transfer" class="headerlink" title="这里需要我们使用  __bridge_transfer "></a>这里需要我们使用 <font color="#e4393c" size="4"> __bridge_transfer </font></h4><h5 id="bridge-transfer-会告诉ARC：”Hi，ARC同学，好久不见。我这里有个货是一个CFStringRef对象，但是有人把它搞成了NSString对象了，我希望你来管-销毁-它，我这里就撒手不管了-调用CFRelease-”。"><a href="#bridge-transfer-会告诉ARC：”Hi，ARC同学，好久不见。我这里有个货是一个CFStringRef对象，但是有人把它搞成了NSString对象了，我希望你来管-销毁-它，我这里就撒手不管了-调用CFRelease-”。" class="headerlink" title=" __bridge_transfer 会告诉ARC：”Hi，ARC同学，好久不见。我这里有个货是一个CFStringRef对象，但是有人把它搞成了NSString对象了，我希望你来管(销毁)它，我这里就撒手不管了(调用CFRelease())”。"></a><font color="#e4393c" size="3"> __bridge_transfer </font>会告诉ARC：”Hi，ARC同学，好久不见。我这里有个货是一个CFStringRef对象，但是有人把它搞成了NSString对象了，我希望你来管(销毁)它，我这里就撒手不管了(调用CFRelease())”。</h5><h5 id="如果我们使用-bridge，就会导致内存泄漏。ARC并不知道自己应该在使用完对象之后释放该对象，也没有人调用CFRelease-。结果这个对象就会永远保留在内存中。因此选择正确的-bridge-说明符是至关重要的。"><a href="#如果我们使用-bridge，就会导致内存泄漏。ARC并不知道自己应该在使用完对象之后释放该对象，也没有人调用CFRelease-。结果这个对象就会永远保留在内存中。因此选择正确的-bridge-说明符是至关重要的。" class="headerlink" title="如果我们使用 __bridge，就会导致内存泄漏。ARC并不知道自己应该在使用完对象之后释放该对象，也没有人调用CFRelease()。结果这个对象就会永远保留在内存中。因此选择正确的 bridge 说明符是至关重要的。"></a>如果我们使用 __bridge，就会导致内存泄漏。ARC并不知道自己应该在使用完对象之后释放该对象，也没有人调用CFRelease()。结果这个对象就会永远保留在内存中。因此选择正确的 bridge 说明符是至关重要的。</h5><h5 id="为了代码更加可读和容易理解，iOS还提供了一个辅助函数：CFBridgingRelease-。函数所做事情和-bridge-transfer-强制转换完全一样，但更加简洁和清晰。CFBridgingRelease-函数定义为内联函数，因此不会导致额外的开销。函数之所以命名为CFBridgingRelease-，是因为一般你会在需要使用CFRelease-释放对象的地方，调用CFBridgingRelease-来传递对象的所有权。"><a href="#为了代码更加可读和容易理解，iOS还提供了一个辅助函数：CFBridgingRelease-。函数所做事情和-bridge-transfer-强制转换完全一样，但更加简洁和清晰。CFBridgingRelease-函数定义为内联函数，因此不会导致额外的开销。函数之所以命名为CFBridgingRelease-，是因为一般你会在需要使用CFRelease-释放对象的地方，调用CFBridgingRelease-来传递对象的所有权。" class="headerlink" title="为了代码更加可读和容易理解，iOS还提供了一个辅助函数：CFBridgingRelease()。函数所做事情和 __bridge_transfer 强制转换完全一样，但更加简洁和清晰。CFBridgingRelease() 函数定义为内联函数，因此不会导致额外的开销。函数之所以命名为CFBridgingRelease()，是因为一般你会在需要使用CFRelease()释放对象的地方，调用CFBridgingRelease()来传递对象的所有权。"></a>为了代码更加可读和容易理解，iOS还提供了一个辅助函数：CFBridgingRelease()。函数所做事情和 __bridge_transfer 强制转换完全一样，但更加简洁和清晰。CFBridgingRelease() 函数定义为内联函数，因此不会导致额外的开销。函数之所以命名为CFBridgingRelease()，是因为一般你会在需要使用CFRelease()释放对象的地方，调用CFBridgingRelease()来传递对象的所有权。</h5><h4 id="清晰明了"><a href="#清晰明了" class="headerlink" title="清晰明了"></a>清晰明了</h4><h5 id="因此最后我们的代码如下："><a href="#因此最后我们的代码如下：" class="headerlink" title="因此最后我们的代码如下："></a>因此最后我们的代码如下：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> - (NSString *)escape:(NSString *)text</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">return</span> CFBridgingRelease(CFURLCreateStringByAddingPercentEscapes(</span><br><span class="line">						NULL,</span><br><span class="line">						(__bridge CFStringRef)text,</span><br><span class="line">						NULL,</span><br><span class="line">						CFSTR(<span class="string">"!*'();:@&amp;=+$,/?%#[]"</span>),</span><br><span class="line">						CFStringConvertNSStringEncodingToEncoding(NSUTF8StringEncoding)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="另一个常见的需要CFBridgingRelease的情况是AddressBook-framework："><a href="#另一个常见的需要CFBridgingRelease的情况是AddressBook-framework：" class="headerlink" title="另一个常见的需要CFBridgingRelease的情况是AddressBook framework："></a>另一个常见的需要CFBridgingRelease的情况是AddressBook framework：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)firstName</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">return</span> CFBridgingRelease(ABRecordCopyCompositeName(...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-只要你调用命名为Create-Copy-Retain的Core-Foundation函数，你都需要使用-CFBridgingRelease-安全地将值传递给ARC。"><a href="#总结-只要你调用命名为Create-Copy-Retain的Core-Foundation函数，你都需要使用-CFBridgingRelease-安全地将值传递给ARC。" class="headerlink" title="总结:只要你调用命名为Create, Copy, Retain的Core Foundation函数，你都需要使用 CFBridgingRelease() 安全地将值传递给ARC。"></a>总结:只要你调用命名为Create, Copy, Retain的Core Foundation函数，你都需要使用 CFBridgingRelease() 安全地将值传递给ARC。</h3><h5 id="bridge-retained-则正好相反，假设你有一个NSString对象，并且要将它传递给某个Core-Foundation-API，该函数希望接收这个string对象的所有权。这时候你就不希望ARC也去释放该对象，否则就会对同一对象释放两次，而且必将导致应用崩溃！换句话说，使用-bridge-retained-将对象的所有权给予-Core-Foundation，而ARC不再负责释放该对象。"><a href="#bridge-retained-则正好相反，假设你有一个NSString对象，并且要将它传递给某个Core-Foundation-API，该函数希望接收这个string对象的所有权。这时候你就不希望ARC也去释放该对象，否则就会对同一对象释放两次，而且必将导致应用崩溃！换句话说，使用-bridge-retained-将对象的所有权给予-Core-Foundation，而ARC不再负责释放该对象。" class="headerlink" title=" bridge_retained  则正好相反，假设你有一个NSString对象，并且要将它传递给某个Core Foundation API，该函数希望接收这个string对象的所有权。这时候你就不希望ARC也去释放该对象，否则就会对同一对象释放两次，而且必将导致应用崩溃！换句话说，使用 bridge_retained 将对象的所有权给予 Core Foundation，而ARC不再负责释放该对象。"></a><font color="#e4393c" size="4"> <strong>bridge_retained </strong></font> 则正好相反，假设你有一个NSString对象，并且要将它传递给某个Core Foundation API，该函数希望接收这个string对象的所有权。这时候你就不希望ARC也去释放该对象，否则就会对同一对象释放两次，而且必将导致应用崩溃！换句话说，使用 bridge_retained 将对象的所有权给予 Core Foundation，而ARC不再负责释放该对象。</h5><h5 id="如下面例子所示："><a href="#如下面例子所示：" class="headerlink" title="如下面例子所示："></a>如下面例子所示：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSString *s1 = [[NSString alloc] initWithFormat:@<span class="string">"Hello, %@!"</span>, name];</span><br><span class="line">CFStringRef s2 = (__bridge_retained CFStringRef)s1;</span><br><span class="line">// <span class="keyword">do</span> something with s2</span><br><span class="line">// . . .</span><br><span class="line">CFRelease(s2);</span><br></pre></td></tr></table></figure>
<h5 id="一旦-bridge-retained-CFStringRef-转换完成，ARC就不再负责释放该对象。如果你在这里使用-bridge，应用就很可能会崩溃。ARC可能在Core-Foundation正在使用该对象时，释放掉它。"><a href="#一旦-bridge-retained-CFStringRef-转换完成，ARC就不再负责释放该对象。如果你在这里使用-bridge，应用就很可能会崩溃。ARC可能在Core-Foundation正在使用该对象时，释放掉它。" class="headerlink" title="一旦 (bridge_retained CFStringRef) 转换完成，ARC就不再负责释放该对象。如果你在这里使用 bridge，应用就很可能会崩溃。ARC可能在Core Foundation正在使用该对象时，释放掉它。"></a>一旦 (<strong>bridge_retained CFStringRef) 转换完成，ARC就不再负责释放该对象。如果你在这里使用 </strong>bridge，应用就很可能会崩溃。ARC可能在Core Foundation正在使用该对象时，释放掉它。</h5><h5 id="同样-bridge-retained-也有一个辅助函数：CFBridgingRetain-。从名字就可以看出，这个函数会让Core-Foundation执行retain，实际如下："><a href="#同样-bridge-retained-也有一个辅助函数：CFBridgingRetain-。从名字就可以看出，这个函数会让Core-Foundation执行retain，实际如下：" class="headerlink" title="同样 __bridge_retained  也有一个辅助函数：CFBridgingRetain()。从名字就可以看出，这个函数会让Core Foundation执行retain，实际如下："></a>同样<font color="#e4393c" size="4"> __bridge_retained </font> 也有一个辅助函数：CFBridgingRetain()。从名字就可以看出，这个函数会让Core Foundation执行retain，实际如下：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CFStringRef s2 = CFBridgingRetain(s1);</span><br><span class="line">// . . .</span><br><span class="line">CFRelease(s2);</span><br></pre></td></tr></table></figure>
<h5 id="现在你应该明白了，上面例子的CFRelease-是和CFBridgingRetain-对应的。"><a href="#现在你应该明白了，上面例子的CFRelease-是和CFBridgingRetain-对应的。" class="headerlink" title="现在你应该明白了，上面例子的CFRelease()是和CFBridgingRetain()对应的。"></a>现在你应该明白了，上面例子的CFRelease()是和CFBridgingRetain()对应的。</h5><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li>使用<font color="#e4393c" size="4">  CFBridgingRelease()</font>，从Core Foundation传递所有权给Objective-C；</li>
<li>使用<font color="#e4393c" size="4"> CFBridgingRetain() </font>，从Objective-C传递所有权给Core Foundation；</li>
<li>使用__brideg，表示临时使用某种类型，不改变对象的所有权。</li>
</ul>
<hr>
<h2 id="Delegate和Weak-Property"><a href="#Delegate和Weak-Property" class="headerlink" title="Delegate和Weak Property"></a>Delegate和Weak Property</h2><h5 id="使用Delegate模式时，通常我们会使用weak-property来引用delegate，这样可以避免所有权回环。"><a href="#使用Delegate模式时，通常我们会使用weak-property来引用delegate，这样可以避免所有权回环。" class="headerlink" title="使用Delegate模式时，通常我们会使用weak property来引用delegate，这样可以避免所有权回环。"></a>使用Delegate模式时，通常我们会使用weak property来引用delegate，这样可以避免所有权回环。</h5><p><img src="/2019/05/20/iOS内存管理-ARC/a007.png" alt></p>
<h5 id="retain循环引用的概念，两个对象互相retain时，会导致两个对象都无法被释放，这也是内存泄漏的常见原因之一。因此需要你使用weak指针来避免。"><a href="#retain循环引用的概念，两个对象互相retain时，会导致两个对象都无法被释放，这也是内存泄漏的常见原因之一。因此需要你使用weak指针来避免。" class="headerlink" title="retain循环引用的概念，两个对象互相retain时，会导致两个对象都无法被释放，这也是内存泄漏的常见原因之一。因此需要你使用weak指针来避免。"></a>retain循环引用的概念，两个对象互相retain时，会导致两个对象都无法被释放，这也是内存泄漏的常见原因之一。因此需要你使用weak指针来避免。</h5><h5 id="还有Block使用不当导致的循环引用，下面会提到"><a href="#还有Block使用不当导致的循环引用，下面会提到" class="headerlink" title="还有Block使用不当导致的循环引用，下面会提到"></a>还有Block使用不当导致的循环引用，下面会提到</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DetailViewController *controller = [[DetailViewController alloc] initWithNibName:@<span class="string">"DetailViewController"</span> bundle:nil];</span><br><span class="line">controller.delegate = self;</span><br><span class="line">[self presentViewController:controller animated:YES completion:nil];</span><br></pre></td></tr></table></figure>
<h5 id="在上面代码中，MainViewController创建一个DetailViewController，并调用presentViewController将view呈现出来，从而拥有了一个strong指针指向创建的DetailViewController对象。反过来，DetailViewController也通过delegate拥有了一个指向MainViewController的weak指针。"><a href="#在上面代码中，MainViewController创建一个DetailViewController，并调用presentViewController将view呈现出来，从而拥有了一个strong指针指向创建的DetailViewController对象。反过来，DetailViewController也通过delegate拥有了一个指向MainViewController的weak指针。" class="headerlink" title="在上面代码中，MainViewController创建一个DetailViewController，并调用presentViewController将view呈现出来，从而拥有了一个strong指针指向创建的DetailViewController对象。反过来，DetailViewController也通过delegate拥有了一个指向MainViewController的weak指针。"></a>在上面代码中，MainViewController创建一个DetailViewController，并调用presentViewController将view呈现出来，从而拥有了一个strong指针指向创建的DetailViewController对象。反过来，DetailViewController也通过delegate拥有了一个指向MainViewController的weak指针。</h5><h5 id="当MainViewController调用dismissViewControllerAnimated-时，就会自动失去DetailViewController的strong引用，这时候DetailViewController对象就会被自动释放。"><a href="#当MainViewController调用dismissViewControllerAnimated-时，就会自动失去DetailViewController的strong引用，这时候DetailViewController对象就会被自动释放。" class="headerlink" title="当MainViewController调用dismissViewControllerAnimated:时，就会自动失去DetailViewController的strong引用，这时候DetailViewController对象就会被自动释放。"></a>当MainViewController调用dismissViewControllerAnimated:时，就会自动失去DetailViewController的strong引用，这时候DetailViewController对象就会被自动释放。</h5><h5 id="如果这两个指针都是strong类型，就会出现所有权回环。导致对象无法在适当的时候被释放。"><a href="#如果这两个指针都是strong类型，就会出现所有权回环。导致对象无法在适当的时候被释放。" class="headerlink" title="如果这两个指针都是strong类型，就会出现所有权回环。导致对象无法在适当的时候被释放。"></a>如果这两个指针都是strong类型，就会出现所有权回环。导致对象无法在适当的时候被释放。</h5><h4 id="unsafe-unretained"><a href="#unsafe-unretained" class="headerlink" title="unsafe_unretained"></a>unsafe_unretained</h4><h5 id="除了strong和weak，还有另外一个unsafe-unretained关键字，一般你不会使用到它。声明为unsafe-unretained的变量或property，编译器不会为其自动添加retain和release。unsafe-unretained只是为了兼容iOS-4，因为iOS-4没有weak-pointer-system。"><a href="#除了strong和weak，还有另外一个unsafe-unretained关键字，一般你不会使用到它。声明为unsafe-unretained的变量或property，编译器不会为其自动添加retain和release。unsafe-unretained只是为了兼容iOS-4，因为iOS-4没有weak-pointer-system。" class="headerlink" title="除了strong和weak，还有另外一个unsafe_unretained关键字，一般你不会使用到它。声明为unsafe_unretained的变量或property，编译器不会为其自动添加retain和release。unsafe_unretained只是为了兼容iOS 4，因为iOS 4没有weak pointer system。"></a>除了strong和weak，还有另外一个unsafe_unretained关键字，一般你不会使用到它。声明为unsafe_unretained的变量或property，编译器不会为其自动添加retain和release。unsafe_unretained只是为了兼容iOS 4，因为iOS 4没有weak pointer system。</h5><h5 id="这里大家做个了解就可以"><a href="#这里大家做个了解就可以" class="headerlink" title="这里大家做个了解就可以"></a>这里大家做个了解就可以</h5><hr>
<h2 id="ARC和Block"><a href="#ARC和Block" class="headerlink" title="ARC和Block"></a>ARC和Block</h2><h5 id="略"><a href="#略" class="headerlink" title="略"></a>略</h5><hr>
<h2 id="ARC和Singleton"><a href="#ARC和Singleton" class="headerlink" title="ARC和Singleton"></a>ARC和Singleton</h2><h4 id="MRC"><a href="#MRC" class="headerlink" title="MRC"></a>MRC</h4><h5 id="如果你的应用使用了Singleton，你的实现可能包含以下方法："><a href="#如果你的应用使用了Singleton，你的实现可能包含以下方法：" class="headerlink" title="如果你的应用使用了Singleton，你的实现可能包含以下方法："></a>如果你的应用使用了Singleton，你的实现可能包含以下方法：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> + (id)allocWithZone:(NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">return</span> [[self sharedInstance] retain];</span><br><span class="line">&#125;</span><br><span class="line">- (id)copyWithZone:(NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">return</span> self;</span><br><span class="line">&#125;</span><br><span class="line">- (id)retain</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">return</span> self;</span><br><span class="line">&#125;</span><br><span class="line">- (NSUInteger)retainCount</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">return</span> NSUIntegerMax;</span><br><span class="line">&#125;</span><br><span class="line">- (oneway void)release</span><br><span class="line">&#123;</span><br><span class="line">     // empty</span><br><span class="line">&#125;</span><br><span class="line">- (id)autorelease</span><br><span class="line">&#123; </span><br><span class="line">     <span class="built_in">return</span> self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="这是典型的singleton实现模式，retain和release都覆盖掉，使其不能创建多个实例对象。毕竟Singleton就是为了只创建一个全局对象。"><a href="#这是典型的singleton实现模式，retain和release都覆盖掉，使其不能创建多个实例对象。毕竟Singleton就是为了只创建一个全局对象。" class="headerlink" title="这是典型的singleton实现模式，retain和release都覆盖掉，使其不能创建多个实例对象。毕竟Singleton就是为了只创建一个全局对象。"></a>这是典型的singleton实现模式，retain和release都覆盖掉，使其不能创建多个实例对象。毕竟Singleton就是为了只创建一个全局对象。</h5><h4 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#import "AppManager.h"</span></span><br><span class="line"></span><br><span class="line">static AppManager   *_appManager = nil;</span><br><span class="line"></span><br><span class="line">@implementation AppManager</span><br><span class="line"></span><br><span class="line">+ (instancetype)sharedInstance &#123;</span><br><span class="line">    static dispatch_once_t  onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        _appManager = [[super allocWithZone:NULL] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">return</span> _appManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)allocWithZone:(struct _NSZone *)zone &#123;</span><br><span class="line">    <span class="built_in">return</span> [self sharedInstance];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (id)copyWithZone:(struct _NSZone *)zone OBJC_ARC_UNAVAILABLE;</span><br><span class="line">+ (id)mutableCopyWithZone:(struct _NSZone *)zone OBJC_ARC_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<h5 id="在ARC中，所有指针变量默认都是nil，在ARC之前，只有实例变量才会默认为nil。如果你编写下面代码："><a href="#在ARC中，所有指针变量默认都是nil，在ARC之前，只有实例变量才会默认为nil。如果你编写下面代码：" class="headerlink" title="在ARC中，所有指针变量默认都是nil，在ARC之前，只有实例变量才会默认为nil。如果你编写下面代码："></a>在ARC中，所有指针变量默认都是nil，在ARC之前，只有实例变量才会默认为nil。如果你编写下面代码：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> - (void)myMethod</span><br><span class="line">&#123;</span><br><span class="line">	int someNumber;</span><br><span class="line">	NSLog(@<span class="string">"Number: %d"</span>, someNumber);</span><br><span class="line">	NSString *someString;</span><br><span class="line">	NSLog(@<span class="string">"String: %p"</span>, someString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="编译器会：”Variable-is-uninitialized-when-used-here”，而输出则是随机数值："><a href="#编译器会：”Variable-is-uninitialized-when-used-here”，而输出则是随机数值：" class="headerlink" title="编译器会：”Variable is uninitialized when used here”，而输出则是随机数值："></a>编译器会：”Variable is uninitialized when used here”，而输出则是随机数值：</h5><h5 id="Woot-2186-207-Number-67"><a href="#Woot-2186-207-Number-67" class="headerlink" title="Woot[2186:207] Number: 67"></a>Woot[2186:207] Number: 67</h5><h5 id="Woot-2186-207-String-0x4babb5"><a href="#Woot-2186-207-String-0x4babb5" class="headerlink" title="Woot[2186:207] String: 0x4babb5"></a>Woot[2186:207] String: 0x4babb5</h5><h5 id="但在ARC中，输出则如下："><a href="#但在ARC中，输出则如下：" class="headerlink" title="但在ARC中，输出则如下："></a>但在ARC中，输出则如下：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Artists[2227:207] Number: 10120117</span><br><span class="line">Artists[2227:207] String: 0x0</span><br></pre></td></tr></table></figure>
<h5 id="int仍然是随机值（这样使用编译器也会警告），但someString的初始值已经是nil，这样的优点是指针永远不会指向非法对象。"><a href="#int仍然是随机值（这样使用编译器也会警告），但someString的初始值已经是nil，这样的优点是指针永远不会指向非法对象。" class="headerlink" title="int仍然是随机值（这样使用编译器也会警告），但someString的初始值已经是nil，这样的优点是指针永远不会指向非法对象。"></a>int仍然是随机值（这样使用编译器也会警告），但someString的初始值已经是nil，这样的优点是指针永远不会指向非法对象。</h5><h5 id="autorelease对象可能会比你想象中存活更长时间，在iOS中，每次UI事件（点击按钮等）都会清空一次-autorelease-pool（具体应该与RunLoop相关，后面文章会说到），但是如果你的事件处理器进行了大量操作，例如循环地创建许多对象，最好是使用你自己的-autorelease-pool，避免应用面临内存不足："><a href="#autorelease对象可能会比你想象中存活更长时间，在iOS中，每次UI事件（点击按钮等）都会清空一次-autorelease-pool（具体应该与RunLoop相关，后面文章会说到），但是如果你的事件处理器进行了大量操作，例如循环地创建许多对象，最好是使用你自己的-autorelease-pool，避免应用面临内存不足：" class="headerlink" title="autorelease对象可能会比你想象中存活更长时间，在iOS中，每次UI事件（点击按钮等）都会清空一次 autorelease pool（具体应该与RunLoop相关，后面文章会说到），但是如果你的事件处理器进行了大量操作，例如循环地创建许多对象，最好是使用你自己的 autorelease pool，避免应用面临内存不足："></a>autorelease对象可能会比你想象中存活更长时间，在iOS中，每次UI事件（点击按钮等）都会清空一次 autorelease pool（具体应该与RunLoop相关，后面文章会说到），但是如果你的事件处理器进行了大量操作，例如循环地创建许多对象，最好是使用你自己的 autorelease pool，避免应用面临内存不足：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; 10000; i++)</span><br><span class="line">&#123;</span><br><span class="line">     @autoreleasepool</span><br><span class="line">     &#123;</span><br><span class="line">          NSString *s = [NSString stringWithFormat:. . .];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><h5 id="此篇整理于2013年，如有错误，敬请斧正。"><a href="#此篇整理于2013年，如有错误，敬请斧正。" class="headerlink" title="此篇整理于2013年，如有错误，敬请斧正。"></a>此篇整理于2013年，如有错误，敬请斧正。</h5>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jackthenoob.github.io/2019/05/20/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="垂杨小梳雨">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lyddwn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/20/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-20T11:22:35+08:00">
                2019-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>欢迎来到我的<a href="https://jackthenoob.github.io">技术博客</a>!<br>下面准备把之前工作中的积累都慢慢转到Github上来。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">垂杨小梳雨</p>
              <p class="site-description motion-element" itemprop="description">None</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">垂杨小梳雨</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
