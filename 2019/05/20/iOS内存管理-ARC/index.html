<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="iOS,内存管理,ARC,">










<meta name="description" content="什么是ARCARC（Automatic Reference Counting）是在iOS5.0推出的新功能，是新LLVM 3.0编译器的特性。简单地说，就是代码中自动加入了retain/release，原先需要手动添加的用来处理内存管理的引用计数的代码可以自动地由编译器完成了。ARC是编译器特性，而不是iOS运行时特性（除了weak指针系统,它会在所指向的内存释放的时候自动将自身置为nil，后面文">
<meta name="keywords" content="iOS,内存管理,ARC">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS内存管理-ARC">
<meta property="og:url" content="http://jackthenoob.github.io/2019/05/20/iOS内存管理-ARC/index.html">
<meta property="og:site_name" content="Lyddwn">
<meta property="og:description" content="什么是ARCARC（Automatic Reference Counting）是在iOS5.0推出的新功能，是新LLVM 3.0编译器的特性。简单地说，就是代码中自动加入了retain/release，原先需要手动添加的用来处理内存管理的引用计数的代码可以自动地由编译器完成了。ARC是编译器特性，而不是iOS运行时特性（除了weak指针系统,它会在所指向的内存释放的时候自动将自身置为nil，后面文">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://jackthenoob.github.io/2019/05/20/iOS内存管理-ARC/a001.png">
<meta property="og:image" content="http://jackthenoob.github.io/2019/05/20/iOS内存管理-ARC/a002.png">
<meta property="og:image" content="http://jackthenoob.github.io/2019/05/20/iOS内存管理-ARC/a003.png">
<meta property="og:image" content="http://jackthenoob.github.io/2019/05/20/iOS内存管理-ARC/a004.png">
<meta property="og:image" content="http://jackthenoob.github.io/2019/05/20/iOS内存管理-ARC/a005.png">
<meta property="og:image" content="http://jackthenoob.github.io/2019/05/20/iOS内存管理-ARC/a006.png">
<meta property="og:image" content="http://jackthenoob.github.io/2019/05/20/iOS内存管理-ARC/a007.png">
<meta property="og:image" content="http://jackthenoob.github.io/2019/05/20/iOS内存管理-ARC/a007.png">
<meta property="og:updated_time" content="2019-05-23T02:49:21.059Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS内存管理-ARC">
<meta name="twitter:description" content="什么是ARCARC（Automatic Reference Counting）是在iOS5.0推出的新功能，是新LLVM 3.0编译器的特性。简单地说，就是代码中自动加入了retain/release，原先需要手动添加的用来处理内存管理的引用计数的代码可以自动地由编译器完成了。ARC是编译器特性，而不是iOS运行时特性（除了weak指针系统,它会在所指向的内存释放的时候自动将自身置为nil，后面文">
<meta name="twitter:image" content="http://jackthenoob.github.io/2019/05/20/iOS内存管理-ARC/a001.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://jackthenoob.github.io/2019/05/20/iOS内存管理-ARC/">





  <title>iOS内存管理-ARC | Lyddwn</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Lyddwn</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">生活不只是代码</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            Commonweal 404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jackthenoob.github.io/2019/05/20/iOS内存管理-ARC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="垂杨小梳雨">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lyddwn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">iOS内存管理-ARC</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-20T18:25:19+08:00">
                2019-05-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="什么是ARC"><a href="#什么是ARC" class="headerlink" title="什么是ARC"></a>什么是ARC</h2><h5 id="ARC（Automatic-Reference-Counting）是在iOS5-0推出的新功能，是新LLVM-3-0编译器的特性。简单地说，就是代码中自动加入了retain-release，原先需要手动添加的用来处理内存管理的引用计数的代码可以自动地由编译器完成了。"><a href="#ARC（Automatic-Reference-Counting）是在iOS5-0推出的新功能，是新LLVM-3-0编译器的特性。简单地说，就是代码中自动加入了retain-release，原先需要手动添加的用来处理内存管理的引用计数的代码可以自动地由编译器完成了。" class="headerlink" title="ARC（Automatic Reference Counting）是在iOS5.0推出的新功能，是新LLVM 3.0编译器的特性。简单地说，就是代码中自动加入了retain/release，原先需要手动添加的用来处理内存管理的引用计数的代码可以自动地由编译器完成了。"></a>ARC（Automatic Reference Counting）是在iOS5.0推出的新功能，是新LLVM 3.0编译器的特性。简单地说，就是代码中自动加入了retain/release，原先需要手动添加的用来处理内存管理的引用计数的代码可以自动地由编译器完成了。</h5><h5 id="ARC是编译器特性，而不是iOS运行时特性（除了weak指针系统-它会在所指向的内存释放的时候自动将自身置为nil，后面文章会专门说下），它也不是其它语言中的垃圾收集器。因此ARC和手动内存管理性能是一样的，有些时候还能更加快速，因为编译器还可以执行某些优化。"><a href="#ARC是编译器特性，而不是iOS运行时特性（除了weak指针系统-它会在所指向的内存释放的时候自动将自身置为nil，后面文章会专门说下），它也不是其它语言中的垃圾收集器。因此ARC和手动内存管理性能是一样的，有些时候还能更加快速，因为编译器还可以执行某些优化。" class="headerlink" title="ARC是编译器特性，而不是iOS运行时特性（除了weak指针系统,它会在所指向的内存释放的时候自动将自身置为nil，后面文章会专门说下），它也不是其它语言中的垃圾收集器。因此ARC和手动内存管理性能是一样的，有些时候还能更加快速，因为编译器还可以执行某些优化。"></a>ARC是编译器特性，而不是iOS运行时特性（除了weak指针系统,它会在所指向的内存释放的时候自动将自身置为nil，后面文章会专门说下），它也不是其它语言中的垃圾收集器。因此ARC和手动内存管理性能是一样的，有些时候还能更加快速，因为编译器还可以执行某些优化。</h5><h2 id="ARC使用规则"><a href="#ARC使用规则" class="headerlink" title="ARC使用规则"></a>ARC使用规则</h2><h5 id="ARC下，指针保持对象的生命。只有还有一个变量（strong）指向对象，对象就会保持在内存中。"><a href="#ARC下，指针保持对象的生命。只有还有一个变量（strong）指向对象，对象就会保持在内存中。" class="headerlink" title="ARC下，指针保持对象的生命。只有还有一个变量（strong）指向对象，对象就会保持在内存中。"></a>ARC下，指针保持对象的生命。只有还有一个变量（strong）指向对象，对象就会保持在内存中。</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *firstName = self.textField.text;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/20/iOS内存管理-ARC/a001.png" alt></p>
<h5 id="上图中，firstName现在指向NSString对象，这时这个对象（textField的内容字符串）将被hold住。比如用字符串-“Ray”作为例子（字符串的retainCount规则和普通的对象不一样，这边就把它当作一个普通的对象来看吧…），这个时候firstName持有了-”Ray”。retainCount-＝-1。"><a href="#上图中，firstName现在指向NSString对象，这时这个对象（textField的内容字符串）将被hold住。比如用字符串-“Ray”作为例子（字符串的retainCount规则和普通的对象不一样，这边就把它当作一个普通的对象来看吧…），这个时候firstName持有了-”Ray”。retainCount-＝-1。" class="headerlink" title="上图中，firstName现在指向NSString对象，这时这个对象（textField的内容字符串）将被hold住。比如用字符串@“Ray”作为例子（字符串的retainCount规则和普通的对象不一样，这边就把它当作一个普通的对象来看吧…），这个时候firstName持有了@”Ray”。retainCount ＝ 1。"></a>上图中，firstName现在指向NSString对象，这时这个对象（textField的内容字符串）将被hold住。比如用字符串@“Ray”作为例子（字符串的retainCount规则和普通的对象不一样，这边就把它当作一个普通的对象来看吧…），这个时候firstName持有了@”Ray”。retainCount ＝ 1。</h5><p><img src="/2019/05/20/iOS内存管理-ARC/a002.png" alt></p>
<h5 id="一个对象可以有多个拥有者-如上图：retainCount-2。"><a href="#一个对象可以有多个拥有者-如上图：retainCount-2。" class="headerlink" title="一个对象可以有多个拥有者,如上图：retainCount=2。"></a>一个对象可以有多个拥有者,如上图：retainCount=2。</h5><h5 id="当用户修改了文本框的text后，此时text属性会指向新的对象。原来的对象仍有firstName指向"><a href="#当用户修改了文本框的text后，此时text属性会指向新的对象。原来的对象仍有firstName指向" class="headerlink" title="当用户修改了文本框的text后，此时text属性会指向新的对象。原来的对象仍有firstName指向"></a>当用户修改了文本框的text后，此时text属性会指向新的对象。原来的对象仍有firstName指向</h5><p><img src="/2019/05/20/iOS内存管理-ARC/a003.png" alt></p>
<h5 id="而当firstName指向另外一个对象时，或者超出作用域范围时，-“Ray”这个字符串对象不在有任何所有者，retainCount-＝-0，将会被释放。"><a href="#而当firstName指向另外一个对象时，或者超出作用域范围时，-“Ray”这个字符串对象不在有任何所有者，retainCount-＝-0，将会被释放。" class="headerlink" title="而当firstName指向另外一个对象时，或者超出作用域范围时，@“Ray”这个字符串对象不在有任何所有者，retainCount ＝ 0，将会被释放。"></a>而当firstName指向另外一个对象时，或者超出作用域范围时，@“Ray”这个字符串对象不在有任何所有者，retainCount ＝ 0，将会被释放。</h5><p><img src="/2019/05/20/iOS内存管理-ARC/a004.png" alt></p>
<h5 id="WARNING-上面我们所说的firstName、text这些指针都是“Strong”，能够保持对象的生命。默认的实例、本地变量都是Strong类型。"><a href="#WARNING-上面我们所说的firstName、text这些指针都是“Strong”，能够保持对象的生命。默认的实例、本地变量都是Strong类型。" class="headerlink" title="WARNING:上面我们所说的firstName、text这些指针都是“Strong”，能够保持对象的生命。默认的实例、本地变量都是Strong类型。"></a>WARNING:上面我们所说的firstName、text这些指针都是“Strong”，能够保持对象的生命。默认的实例、本地变量都是Strong类型。</h5><h5 id="这边再提下刚刚我们说到的ARC的一个基本规则。"><a href="#这边再提下刚刚我们说到的ARC的一个基本规则。" class="headerlink" title="这边再提下刚刚我们说到的ARC的一个基本规则。"></a>这边再提下刚刚我们说到的ARC的一个基本规则。</h5><font color="#e4393c" size="3">只要某个对象被任一strong指针指向，那么它将不会被销毁。如果对象没有被任何strong指针指向，那么就将被销毁。</font>

<h4 id="weak指针"><a href="#weak指针" class="headerlink" title="weak指针"></a>weak指针</h4><h5 id="weak变量仍然指向一个对象，但不是对象的拥有者："><a href="#weak变量仍然指向一个对象，但不是对象的拥有者：" class="headerlink" title="weak变量仍然指向一个对象，但不是对象的拥有者："></a>weak变量仍然指向一个对象，但不是对象的拥有者：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__weak NSString *weakName = self.textField.text;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/20/iOS内存管理-ARC/a005.png" alt></p>
<h5 id="当self-textField-text指向其他对象，-此时weakName会自动变成nil，称为“zeroing”-weak-pointer："><a href="#当self-textField-text指向其他对象，-此时weakName会自动变成nil，称为“zeroing”-weak-pointer：" class="headerlink" title="当self.textField.text指向其他对象， 此时weakName会自动变成nil，称为“zeroing” weak pointer："></a>当self.textField.text指向其他对象， 此时weakName会自动变成nil，称为“zeroing” weak pointer：</h5><p><img src="/2019/05/20/iOS内存管理-ARC/a006.png" alt></p>
<h5 id="它解决了MRC下assign指针指向已经释放的对象（我们常说的野指针），对它发送消息Crash的问题。"><a href="#它解决了MRC下assign指针指向已经释放的对象（我们常说的野指针），对它发送消息Crash的问题。" class="headerlink" title="它解决了MRC下assign指针指向已经释放的对象（我们常说的野指针），对它发送消息Crash的问题。"></a>它解决了MRC下assign指针指向已经释放的对象（我们常说的野指针），对它发送消息Crash的问题。</h5><p><img src="/2019/05/20/iOS内存管理-ARC/a007.png" alt></p>
<hr>
<h5 id="ARC可以节省代码（MRC下属性赋值），我们不需要关心什么时候retain、release。但是不意味着我们不需要考虑内存管理"><a href="#ARC可以节省代码（MRC下属性赋值），我们不需要关心什么时候retain、release。但是不意味着我们不需要考虑内存管理" class="headerlink" title="ARC可以节省代码（MRC下属性赋值），我们不需要关心什么时候retain、release。但是不意味着我们不需要考虑内存管理"></a>ARC可以节省代码（MRC下属性赋值），我们不需要关心什么时候retain、release。但是不意味着我们不需要考虑内存管理</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id obj = [array objectAtIndex:0];</span><br><span class="line">[array removeObjectAtIndex:0];</span><br><span class="line">NSLog(@<span class="string">"%@"</span>, obj);</span><br></pre></td></tr></table></figure>
<p>上面代码在MRC下是错误的。从Array中移除一个对象会使对象不可用，对象不属于Array时会立即被释放。随后NSLog()打印该对象就会导致应用崩溃。 </p>
<p>而在ARC中这段代码是完全合法的。因为obj变量是一个strong指针，它成为了对象的拥有者，从Array中移除该对象也不会导致对象被释放。 </p>
<h5 id="内存管理其他注意点："><a href="#内存管理其他注意点：" class="headerlink" title="内存管理其他注意点："></a>内存管理其他注意点：</h5><ul>
<li>通知、KVO需要释放。（可在dealloc中）</li>
<li>NSTimer（rep=true）会强引用传入的target。</li>
<li>Block</li>
</ul>
<h5 id="ARC限制：-用于NSObject对象。"><a href="#ARC限制：-用于NSObject对象。" class="headerlink" title="ARC限制： 用于NSObject对象。"></a>ARC限制： 用于NSObject对象。</h5><h5 id="如果应用使用了Core-Foundation或malloc-free-，此时需要你来管理内存（这个我们下面再说）"><a href="#如果应用使用了Core-Foundation或malloc-free-，此时需要你来管理内存（这个我们下面再说）" class="headerlink" title="如果应用使用了Core Foundation或malloc()/free()，此时需要你来管理内存（这个我们下面再说）"></a>如果应用使用了Core Foundation或malloc()/free()，此时需要你来管理内存（这个我们下面再说）</h5><hr>
<h2 id="Xcode的ARC自动迁移"><a href="#Xcode的ARC自动迁移" class="headerlink" title="Xcode的ARC自动迁移"></a>Xcode的ARC自动迁移</h2><h5 id="要启用一个项目的ARC，你有以下几种选择："><a href="#要启用一个项目的ARC，你有以下几种选择：" class="headerlink" title="要启用一个项目的ARC，你有以下几种选择："></a>要启用一个项目的ARC，你有以下几种选择：</h5><ul>
<li>Xcode带了一个自动转换工具，可以迁移源代码至ARC</li>
<li>你可以手动转换源文件</li>
<li>你可以在Xcode中禁用某些文件使用ARC，这点对于第三方库非常有用。</li>
</ul>
<h5 id="这边说下测试提出的需要将IBOutlet改为Strong的事情。"><a href="#这边说下测试提出的需要将IBOutlet改为Strong的事情。" class="headerlink" title="这边说下测试提出的需要将IBOutlet改为Strong的事情。"></a>这边说下测试提出的需要将IBOutlet改为Strong的事情。</h5><h5 id="在ARC中，所有outlet属性都推荐使用weak，这些view对象已经属于View-Controller的view-hierarchy，不需要再次定义为strong（ARC中效果等同于retain）。唯一应该使用strong的outlet是File’s-Owner，连接到nib的顶层对象。"><a href="#在ARC中，所有outlet属性都推荐使用weak，这些view对象已经属于View-Controller的view-hierarchy，不需要再次定义为strong（ARC中效果等同于retain）。唯一应该使用strong的outlet是File’s-Owner，连接到nib的顶层对象。" class="headerlink" title="在ARC中，所有outlet属性都推荐使用weak，这些view对象已经属于View Controller的view hierarchy，不需要再次定义为strong（ARC中效果等同于retain）。唯一应该使用strong的outlet是File’s Owner，连接到nib的顶层对象。"></a>在ARC中，所有<em>outlet</em>属性都推荐使用weak，这些view对象已经属于View Controller的view hierarchy，不需要再次定义为strong（ARC中效果等同于retain）。唯一应该使用strong的outlet是File’s Owner，连接到nib的顶层对象。</h5><hr>
<h2 id="ARC中dealloc与autorelease"><a href="#ARC中dealloc与autorelease" class="headerlink" title="ARC中dealloc与autorelease"></a>ARC中dealloc与autorelease</h2><h3 id="dealloc"><a href="#dealloc" class="headerlink" title="dealloc"></a>dealloc</h3><h5 id="在ARC下我们一般不需要写dealloc函数。因为我们不需要调用-super-dealloc-也不需要release属性。而Strong属性出了作用域（这个class）会被置为nil，对象相应的会被释放销毁。（内存从创建到如何销毁下面文章会写到）"><a href="#在ARC下我们一般不需要写dealloc函数。因为我们不需要调用-super-dealloc-也不需要release属性。而Strong属性出了作用域（这个class）会被置为nil，对象相应的会被释放销毁。（内存从创建到如何销毁下面文章会写到）" class="headerlink" title="在ARC下我们一般不需要写dealloc函数。因为我们不需要调用[super dealloc],也不需要release属性。而Strong属性出了作用域（这个class）会被置为nil，对象相应的会被释放销毁。（内存从创建到如何销毁下面文章会写到）"></a>在ARC下我们一般不需要写dealloc函数。因为我们不需要调用[super dealloc],也不需要release属性。而Strong属性出了作用域（这个class）会被置为nil，对象相应的会被释放销毁。（内存从创建到如何销毁下面文章会写到）</h5><h5 id="而dealloc函数还是会被调用执行的，在这个函数里面，我们有时候需要释放CoreFoundation对象、remove-observer、remove-KVO以及一些其他资源（-AudioServicesDisposeSystemSoundID-soundID-）"><a href="#而dealloc函数还是会被调用执行的，在这个函数里面，我们有时候需要释放CoreFoundation对象、remove-observer、remove-KVO以及一些其他资源（-AudioServicesDisposeSystemSoundID-soundID-）" class="headerlink" title="而dealloc函数还是会被调用执行的，在这个函数里面，我们有时候需要释放CoreFoundation对象、remove observer、remove KVO以及一些其他资源（ AudioServicesDisposeSystemSoundID(soundID); ）"></a>而dealloc函数还是会被调用执行的，在这个函数里面，我们有时候需要释放CoreFoundation对象、remove observer、remove KVO以及一些其他资源（ AudioServicesDisposeSystemSoundID(soundID); ）</h5><h5 id="这里要注意的是：不要在dealloc函数中释放Timer。NSTimer会保持一份target强引用，导致这个Class永远不会被释放。所以需要在对象Class销毁前做处理"><a href="#这里要注意的是：不要在dealloc函数中释放Timer。NSTimer会保持一份target强引用，导致这个Class永远不会被释放。所以需要在对象Class销毁前做处理" class="headerlink" title="这里要注意的是：不要在dealloc函数中释放Timer。NSTimer会保持一份target强引用，导致这个Class永远不会被释放。所以需要在对象Class销毁前做处理"></a>这里要注意的是：不要在dealloc函数中释放Timer。NSTimer会保持一份target强引用，导致这个Class永远不会被释放。所以需要在对象Class销毁前做处理</h5><h5 id="在Github上有个开源项目MSWeakTimer。"><a href="#在Github上有个开源项目MSWeakTimer。" class="headerlink" title="在Github上有个开源项目MSWeakTimer。"></a>在Github上有个开源项目<a href="https://github.com/mindsnacks/MSWeakTimer" target="_blank" rel="noopener">MSWeakTimer</a>。</h5><h3 id="autoreleasepool"><a href="#autoreleasepool" class="headerlink" title="autoreleasepool"></a>autoreleasepool</h3><h5 id="ARC仍然保留了AutoreleasePool，但是采用了新的Block语法，于是我们的main函数会如下修改："><a href="#ARC仍然保留了AutoreleasePool，但是采用了新的Block语法，于是我们的main函数会如下修改：" class="headerlink" title="ARC仍然保留了AutoreleasePool，但是采用了新的Block语法，于是我们的main函数会如下修改："></a>ARC仍然保留了AutoreleasePool，但是采用了新的Block语法，于是我们的main函数会如下修改：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];</span><br><span class="line">int retVal = UIApplicationMain(argc, argv, nil,</span><br><span class="line">NSStringFromClass([AppDelegate class]));</span><br><span class="line">[pool release];</span><br><span class="line"><span class="built_in">return</span> retVal;</span><br></pre></td></tr></table></figure>
<h5 id="修改为："><a href="#修改为：" class="headerlink" title="修改为："></a>修改为：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">	int retVal = UIApplicationMain(argc, argv, nil,</span><br><span class="line">	NSStringFromClass([AppDelegate class]));</span><br><span class="line">	<span class="built_in">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Core-Foundation的内存管理-Toll-Free-Bridge"><a href="#Core-Foundation的内存管理-Toll-Free-Bridge" class="headerlink" title="Core Foundation的内存管理-Toll-Free Bridge"></a>Core Foundation的内存管理-Toll-Free Bridge</h2><h5 id="在ARC下，objective-c对象与Core-Foundation对象相互转换时，需要用到briage-cast。"><a href="#在ARC下，objective-c对象与Core-Foundation对象相互转换时，需要用到briage-cast。" class="headerlink" title="在ARC下，objective-c对象与Core Foundation对象相互转换时，需要用到briage cast。"></a>在ARC下，objective-c对象与Core Foundation对象相互转换时，需要用到briage cast。</h5><h5 id="举个栗子：NSString和CFStringRef就可以同等对待，在任何地方都可以互换使用，背后的设计就是toll-free-bridging。"><a href="#举个栗子：NSString和CFStringRef就可以同等对待，在任何地方都可以互换使用，背后的设计就是toll-free-bridging。" class="headerlink" title="举个栗子：NSString和CFStringRef就可以同等对待，在任何地方都可以互换使用，背后的设计就是toll-free bridging。"></a>举个栗子：NSString和CFStringRef就可以同等对待，在任何地方都可以互换使用，背后的设计就是toll-free bridging。</h5><p>在ARC之前，我们时这么处理的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFStringRef s1 = (CFStringRef) [[NSString alloc] initWithFormat:@<span class="string">"Hello, %@!"</span>, name];</span><br></pre></td></tr></table></figure></p>
<h5 id="当然，alloc分配了NSString对象，你需要在使用完之后进行释放，注意是释放转换后的CFStringRef对象："><a href="#当然，alloc分配了NSString对象，你需要在使用完之后进行释放，注意是释放转换后的CFStringRef对象：" class="headerlink" title="当然，alloc分配了NSString对象，你需要在使用完之后进行释放，注意是释放转换后的CFStringRef对象："></a>当然，alloc分配了NSString对象，你需要在使用完之后进行释放，注意是释放转换后的CFStringRef对象：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFRelease(s1);</span><br></pre></td></tr></table></figure>
<h5 id="反过来，从Core-Foundation到Objective-C的方向也类似："><a href="#反过来，从Core-Foundation到Objective-C的方向也类似：" class="headerlink" title="反过来，从Core Foundation到Objective-C的方向也类似："></a>反过来，从Core Foundation到Objective-C的方向也类似：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CFStringRef s2 = CFStringCreateWithCString(kCFAllocatorDefault, bytes, kCFStringEncodingMacRoman);</span><br><span class="line">NSString *s3 = (NSString *)s2;</span><br><span class="line">// release the object when you<span class="string">'re done</span></span><br><span class="line"><span class="string">[s3 release];</span></span><br></pre></td></tr></table></figure>
<h5 id="在ARC下，情况变得不一样！以下代码在手动内存管理中是完全合法的，但在ARC中却存在问题："><a href="#在ARC下，情况变得不一样！以下代码在手动内存管理中是完全合法的，但在ARC中却存在问题：" class="headerlink" title="在ARC下，情况变得不一样！以下代码在手动内存管理中是完全合法的，但在ARC中却存在问题："></a>在ARC下，情况变得不一样！以下代码在手动内存管理中是完全合法的，但在ARC中却存在问题：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)escape:(NSString *)text</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">return</span> [(NSString *)CFURLCreateStringByAddingPercentEscapes(</span><br><span class="line">							NULL,</span><br><span class="line">							(CFStringRef)text,</span><br><span class="line">							NULL,</span><br><span class="line">							(CFStringRef)@<span class="string">"!*'();:@&amp;=+$,/?%#[]"</span>, // 这里不需要bridging casts，因为这是一个常量，不需要释放！</span><br><span class="line"> 							CFStringConvertNSStringEncodingToEncoding(NSUTF8StringEncoding)) autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="#e4393c" size="4">在ARC下编译器必须知道由谁来负责释放转换后的对象</font>

<h5 id="如果你把一个NSObject当作Core-Foundation对象来使用，则ARC将不再负责释放该对象。但你必须明确地告诉ARC你的这个意图，编译器没办法自己做主。"><a href="#如果你把一个NSObject当作Core-Foundation对象来使用，则ARC将不再负责释放该对象。但你必须明确地告诉ARC你的这个意图，编译器没办法自己做主。" class="headerlink" title="如果你把一个NSObject当作Core Foundation对象来使用，则ARC将不再负责释放该对象。但你必须明确地告诉ARC你的这个意图，编译器没办法自己做主。"></a>如果你把一个NSObject当作Core Foundation对象来使用，则ARC将不再负责释放该对象。但你必须明确地告诉ARC你的这个意图，编译器没办法自己做主。</h5><h5 id="同样如果你创建一个Core-Foundation对象并把它转换为NSObject对象，你也必须告诉ARC占据对象的所有权，并在适当的时候释放该对象。这就是所谓的bridging-casts。"><a href="#同样如果你创建一个Core-Foundation对象并把它转换为NSObject对象，你也必须告诉ARC占据对象的所有权，并在适当的时候释放该对象。这就是所谓的bridging-casts。" class="headerlink" title="同样如果你创建一个Core Foundation对象并把它转换为NSObject对象，你也必须告诉ARC占据对象的所有权，并在适当的时候释放该对象。这就是所谓的bridging casts。"></a>同样如果你创建一个Core Foundation对象并把它转换为NSObject对象，你也必须告诉ARC占据对象的所有权，并在适当的时候释放该对象。这就是所谓的bridging casts。</h5><h5 id="上面代码中，CFURLCreateStringByAddingPercentEscapes-函数的参数需要两个CFStringRef对象，其中常量NSString可以直接转换，因为不需要进行对象释放；但是-text-参数不一样，它是传递进来的一个NSString对象。而函数参数和局部变量一样，都是strong指针，这种对象在函数入口处会被retain，并且对象会持续存在直到指针被销毁（这里也就是函数返回时）。"><a href="#上面代码中，CFURLCreateStringByAddingPercentEscapes-函数的参数需要两个CFStringRef对象，其中常量NSString可以直接转换，因为不需要进行对象释放；但是-text-参数不一样，它是传递进来的一个NSString对象。而函数参数和局部变量一样，都是strong指针，这种对象在函数入口处会被retain，并且对象会持续存在直到指针被销毁（这里也就是函数返回时）。" class="headerlink" title="上面代码中，CFURLCreateStringByAddingPercentEscapes()函数的参数需要两个CFStringRef对象，其中常量NSString可以直接转换，因为不需要进行对象释放；但是 text 参数不一样，它是传递进来的一个NSString对象。而函数参数和局部变量一样，都是strong指针，这种对象在函数入口处会被retain，并且对象会持续存在直到指针被销毁（这里也就是函数返回时）。"></a>上面代码中，CFURLCreateStringByAddingPercentEscapes()函数的参数需要两个CFStringRef对象，其中常量NSString可以直接转换，因为不需要进行对象释放；但是 text 参数不一样，它是传递进来的一个NSString对象。而函数参数和局部变量一样，都是strong指针，这种对象在函数入口处会被retain，并且对象会持续存在直到指针被销毁（这里也就是函数返回时）。</h5><h5 id="对于text参数，我们希望ARC保持这个变量的所有权，同时又希望临时将它当作CFStringRef对象来使用。这种情况下可以使用-bridge说明符，它告诉ARC不要更改对象的所有权，按普通规则释放该对象即可。"><a href="#对于text参数，我们希望ARC保持这个变量的所有权，同时又希望临时将它当作CFStringRef对象来使用。这种情况下可以使用-bridge说明符，它告诉ARC不要更改对象的所有权，按普通规则释放该对象即可。" class="headerlink" title="对于text参数，我们希望ARC保持这个变量的所有权，同时又希望临时将它当作CFStringRef对象来使用。这种情况下可以使用__bridge说明符，它告诉ARC不要更改对象的所有权，按普通规则释放该对象即可。"></a>对于text参数，我们希望ARC保持这个变量的所有权，同时又希望临时将它当作CFStringRef对象来使用。这种情况下可以使用__bridge说明符，它告诉ARC不要更改对象的所有权，按普通规则释放该对象即可。</h5><h5 id="多数情况下，Objective-C对象和Core-Foundation对象之间互相转换时，我们都应该使用-bridge。"><a href="#多数情况下，Objective-C对象和Core-Foundation对象之间互相转换时，我们都应该使用-bridge。" class="headerlink" title="多数情况下，Objective-C对象和Core Foundation对象之间互相转换时，我们都应该使用__bridge。"></a>多数情况下，Objective-C对象和Core Foundation对象之间互相转换时，我们都应该使用__bridge。</h5><h4 id="但是-它lei来了"><a href="#但是-它lei来了" class="headerlink" title="但是~它lei来了"></a>但是~它lei来了</h4><h5 id="但是有时候我们确实需要给予ARC某个对象的所有权，或者解除ARC对某个对象的所有权。这种情况下我们就需要使用另外两种bridging-casts："><a href="#但是有时候我们确实需要给予ARC某个对象的所有权，或者解除ARC对某个对象的所有权。这种情况下我们就需要使用另外两种bridging-casts：" class="headerlink" title="但是有时候我们确实需要给予ARC某个对象的所有权，或者解除ARC对某个对象的所有权。这种情况下我们就需要使用另外两种bridging casts："></a>但是有时候我们确实需要给予ARC某个对象的所有权，或者解除ARC对某个对象的所有权。这种情况下我们就需要使用另外两种bridging casts：</h5><ul>
<li>__bridge_transfer：给予ARC所有权</li>
<li>__bridge_retained：解除ARC所有权</li>
</ul>
<h5 id="因为-CFURLCreateStringByAddingPercentEscapes-函数创建了一个新的CFStringRef对象-而我们要的是NSString对象，因此我们要强制转换。"><a href="#因为-CFURLCreateStringByAddingPercentEscapes-函数创建了一个新的CFStringRef对象-而我们要的是NSString对象，因此我们要强制转换。" class="headerlink" title="因为 CFURLCreateStringByAddingPercentEscapes() 函数创建了一个新的CFStringRef对象,而我们要的是NSString对象，因此我们要强制转换。"></a>因为 CFURLCreateStringByAddingPercentEscapes() 函数创建了一个新的CFStringRef对象,而我们要的是NSString对象，因此我们要强制转换。</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CFStringRef result = CFURLCreateStringByAddingPercentEscapes(. . .);</span><br><span class="line">NSString *s = (NSString *)result;</span><br><span class="line"><span class="built_in">return</span> s;</span><br></pre></td></tr></table></figure>
<h5 id="当我们不需要强制转换为NSObject对象时，我们只需要调用CFRelease方法即可"><a href="#当我们不需要强制转换为NSObject对象时，我们只需要调用CFRelease方法即可" class="headerlink" title="当我们不需要强制转换为NSObject对象时，我们只需要调用CFRelease方法即可"></a>当我们不需要强制转换为NSObject对象时，我们只需要调用CFRelease方法即可</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">do</span> something with the result </span><br><span class="line">CGRelease(result)</span><br></pre></td></tr></table></figure>
<font color="#e4393c" size="4">ARC只能作业于Objective-c对象。那么问题来了 既然我们创建了一个Core Foundation对象 谁来负责释放它？</font>

<h4 id="这里需要我们使用-bridge-transfer"><a href="#这里需要我们使用-bridge-transfer" class="headerlink" title="这里需要我们使用  __bridge_transfer "></a>这里需要我们使用 <font color="#e4393c" size="4"> __bridge_transfer </font></h4><h5 id="bridge-transfer-会告诉ARC：”Hi，ARC同学，好久不见。我这里有个货是一个CFStringRef对象，但是有人把它搞成了NSString对象了，我希望你来管-销毁-它，我这里就撒手不管了-调用CFRelease-”。"><a href="#bridge-transfer-会告诉ARC：”Hi，ARC同学，好久不见。我这里有个货是一个CFStringRef对象，但是有人把它搞成了NSString对象了，我希望你来管-销毁-它，我这里就撒手不管了-调用CFRelease-”。" class="headerlink" title=" __bridge_transfer 会告诉ARC：”Hi，ARC同学，好久不见。我这里有个货是一个CFStringRef对象，但是有人把它搞成了NSString对象了，我希望你来管(销毁)它，我这里就撒手不管了(调用CFRelease())”。"></a><font color="#e4393c" size="3"> __bridge_transfer </font>会告诉ARC：”Hi，ARC同学，好久不见。我这里有个货是一个CFStringRef对象，但是有人把它搞成了NSString对象了，我希望你来管(销毁)它，我这里就撒手不管了(调用CFRelease())”。</h5><h5 id="如果我们使用-bridge，就会导致内存泄漏。ARC并不知道自己应该在使用完对象之后释放该对象，也没有人调用CFRelease-。结果这个对象就会永远保留在内存中。因此选择正确的-bridge-说明符是至关重要的。"><a href="#如果我们使用-bridge，就会导致内存泄漏。ARC并不知道自己应该在使用完对象之后释放该对象，也没有人调用CFRelease-。结果这个对象就会永远保留在内存中。因此选择正确的-bridge-说明符是至关重要的。" class="headerlink" title="如果我们使用 __bridge，就会导致内存泄漏。ARC并不知道自己应该在使用完对象之后释放该对象，也没有人调用CFRelease()。结果这个对象就会永远保留在内存中。因此选择正确的 bridge 说明符是至关重要的。"></a>如果我们使用 __bridge，就会导致内存泄漏。ARC并不知道自己应该在使用完对象之后释放该对象，也没有人调用CFRelease()。结果这个对象就会永远保留在内存中。因此选择正确的 bridge 说明符是至关重要的。</h5><h5 id="为了代码更加可读和容易理解，iOS还提供了一个辅助函数：CFBridgingRelease-。函数所做事情和-bridge-transfer-强制转换完全一样，但更加简洁和清晰。CFBridgingRelease-函数定义为内联函数，因此不会导致额外的开销。函数之所以命名为CFBridgingRelease-，是因为一般你会在需要使用CFRelease-释放对象的地方，调用CFBridgingRelease-来传递对象的所有权。"><a href="#为了代码更加可读和容易理解，iOS还提供了一个辅助函数：CFBridgingRelease-。函数所做事情和-bridge-transfer-强制转换完全一样，但更加简洁和清晰。CFBridgingRelease-函数定义为内联函数，因此不会导致额外的开销。函数之所以命名为CFBridgingRelease-，是因为一般你会在需要使用CFRelease-释放对象的地方，调用CFBridgingRelease-来传递对象的所有权。" class="headerlink" title="为了代码更加可读和容易理解，iOS还提供了一个辅助函数：CFBridgingRelease()。函数所做事情和 __bridge_transfer 强制转换完全一样，但更加简洁和清晰。CFBridgingRelease() 函数定义为内联函数，因此不会导致额外的开销。函数之所以命名为CFBridgingRelease()，是因为一般你会在需要使用CFRelease()释放对象的地方，调用CFBridgingRelease()来传递对象的所有权。"></a>为了代码更加可读和容易理解，iOS还提供了一个辅助函数：CFBridgingRelease()。函数所做事情和 __bridge_transfer 强制转换完全一样，但更加简洁和清晰。CFBridgingRelease() 函数定义为内联函数，因此不会导致额外的开销。函数之所以命名为CFBridgingRelease()，是因为一般你会在需要使用CFRelease()释放对象的地方，调用CFBridgingRelease()来传递对象的所有权。</h5><h4 id="清晰明了"><a href="#清晰明了" class="headerlink" title="清晰明了"></a>清晰明了</h4><h5 id="因此最后我们的代码如下："><a href="#因此最后我们的代码如下：" class="headerlink" title="因此最后我们的代码如下："></a>因此最后我们的代码如下：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> - (NSString *)escape:(NSString *)text</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">return</span> CFBridgingRelease(CFURLCreateStringByAddingPercentEscapes(</span><br><span class="line">						NULL,</span><br><span class="line">						(__bridge CFStringRef)text,</span><br><span class="line">						NULL,</span><br><span class="line">						CFSTR(<span class="string">"!*'();:@&amp;=+$,/?%#[]"</span>),</span><br><span class="line">						CFStringConvertNSStringEncodingToEncoding(NSUTF8StringEncoding)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="另一个常见的需要CFBridgingRelease的情况是AddressBook-framework："><a href="#另一个常见的需要CFBridgingRelease的情况是AddressBook-framework：" class="headerlink" title="另一个常见的需要CFBridgingRelease的情况是AddressBook framework："></a>另一个常见的需要CFBridgingRelease的情况是AddressBook framework：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)firstName</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">return</span> CFBridgingRelease(ABRecordCopyCompositeName(...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-只要你调用命名为Create-Copy-Retain的Core-Foundation函数，你都需要使用-CFBridgingRelease-安全地将值传递给ARC。"><a href="#总结-只要你调用命名为Create-Copy-Retain的Core-Foundation函数，你都需要使用-CFBridgingRelease-安全地将值传递给ARC。" class="headerlink" title="总结:只要你调用命名为Create, Copy, Retain的Core Foundation函数，你都需要使用 CFBridgingRelease() 安全地将值传递给ARC。"></a>总结:只要你调用命名为Create, Copy, Retain的Core Foundation函数，你都需要使用 CFBridgingRelease() 安全地将值传递给ARC。</h3><h5 id="bridge-retained-则正好相反，假设你有一个NSString对象，并且要将它传递给某个Core-Foundation-API，该函数希望接收这个string对象的所有权。这时候你就不希望ARC也去释放该对象，否则就会对同一对象释放两次，而且必将导致应用崩溃！换句话说，使用-bridge-retained-将对象的所有权给予-Core-Foundation，而ARC不再负责释放该对象。"><a href="#bridge-retained-则正好相反，假设你有一个NSString对象，并且要将它传递给某个Core-Foundation-API，该函数希望接收这个string对象的所有权。这时候你就不希望ARC也去释放该对象，否则就会对同一对象释放两次，而且必将导致应用崩溃！换句话说，使用-bridge-retained-将对象的所有权给予-Core-Foundation，而ARC不再负责释放该对象。" class="headerlink" title=" bridge_retained  则正好相反，假设你有一个NSString对象，并且要将它传递给某个Core Foundation API，该函数希望接收这个string对象的所有权。这时候你就不希望ARC也去释放该对象，否则就会对同一对象释放两次，而且必将导致应用崩溃！换句话说，使用 bridge_retained 将对象的所有权给予 Core Foundation，而ARC不再负责释放该对象。"></a><font color="#e4393c" size="4"> <strong>bridge_retained </strong></font> 则正好相反，假设你有一个NSString对象，并且要将它传递给某个Core Foundation API，该函数希望接收这个string对象的所有权。这时候你就不希望ARC也去释放该对象，否则就会对同一对象释放两次，而且必将导致应用崩溃！换句话说，使用 bridge_retained 将对象的所有权给予 Core Foundation，而ARC不再负责释放该对象。</h5><h5 id="如下面例子所示："><a href="#如下面例子所示：" class="headerlink" title="如下面例子所示："></a>如下面例子所示：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSString *s1 = [[NSString alloc] initWithFormat:@<span class="string">"Hello, %@!"</span>, name];</span><br><span class="line">CFStringRef s2 = (__bridge_retained CFStringRef)s1;</span><br><span class="line">// <span class="keyword">do</span> something with s2</span><br><span class="line">// . . .</span><br><span class="line">CFRelease(s2);</span><br></pre></td></tr></table></figure>
<h5 id="一旦-bridge-retained-CFStringRef-转换完成，ARC就不再负责释放该对象。如果你在这里使用-bridge，应用就很可能会崩溃。ARC可能在Core-Foundation正在使用该对象时，释放掉它。"><a href="#一旦-bridge-retained-CFStringRef-转换完成，ARC就不再负责释放该对象。如果你在这里使用-bridge，应用就很可能会崩溃。ARC可能在Core-Foundation正在使用该对象时，释放掉它。" class="headerlink" title="一旦 (bridge_retained CFStringRef) 转换完成，ARC就不再负责释放该对象。如果你在这里使用 bridge，应用就很可能会崩溃。ARC可能在Core Foundation正在使用该对象时，释放掉它。"></a>一旦 (<strong>bridge_retained CFStringRef) 转换完成，ARC就不再负责释放该对象。如果你在这里使用 </strong>bridge，应用就很可能会崩溃。ARC可能在Core Foundation正在使用该对象时，释放掉它。</h5><h5 id="同样-bridge-retained-也有一个辅助函数：CFBridgingRetain-。从名字就可以看出，这个函数会让Core-Foundation执行retain，实际如下："><a href="#同样-bridge-retained-也有一个辅助函数：CFBridgingRetain-。从名字就可以看出，这个函数会让Core-Foundation执行retain，实际如下：" class="headerlink" title="同样 __bridge_retained  也有一个辅助函数：CFBridgingRetain()。从名字就可以看出，这个函数会让Core Foundation执行retain，实际如下："></a>同样<font color="#e4393c" size="4"> __bridge_retained </font> 也有一个辅助函数：CFBridgingRetain()。从名字就可以看出，这个函数会让Core Foundation执行retain，实际如下：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CFStringRef s2 = CFBridgingRetain(s1);</span><br><span class="line">// . . .</span><br><span class="line">CFRelease(s2);</span><br></pre></td></tr></table></figure>
<h5 id="现在你应该明白了，上面例子的CFRelease-是和CFBridgingRetain-对应的。"><a href="#现在你应该明白了，上面例子的CFRelease-是和CFBridgingRetain-对应的。" class="headerlink" title="现在你应该明白了，上面例子的CFRelease()是和CFBridgingRetain()对应的。"></a>现在你应该明白了，上面例子的CFRelease()是和CFBridgingRetain()对应的。</h5><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li>使用<font color="#e4393c" size="4">  CFBridgingRelease()</font>，从Core Foundation传递所有权给Objective-C；</li>
<li>使用<font color="#e4393c" size="4"> CFBridgingRetain() </font>，从Objective-C传递所有权给Core Foundation；</li>
<li>使用__brideg，表示临时使用某种类型，不改变对象的所有权。</li>
</ul>
<hr>
<h2 id="Delegate和Weak-Property"><a href="#Delegate和Weak-Property" class="headerlink" title="Delegate和Weak Property"></a>Delegate和Weak Property</h2><h5 id="使用Delegate模式时，通常我们会使用weak-property来引用delegate，这样可以避免所有权回环。"><a href="#使用Delegate模式时，通常我们会使用weak-property来引用delegate，这样可以避免所有权回环。" class="headerlink" title="使用Delegate模式时，通常我们会使用weak property来引用delegate，这样可以避免所有权回环。"></a>使用Delegate模式时，通常我们会使用weak property来引用delegate，这样可以避免所有权回环。</h5><p><img src="/2019/05/20/iOS内存管理-ARC/a007.png" alt></p>
<h5 id="retain循环引用的概念，两个对象互相retain时，会导致两个对象都无法被释放，这也是内存泄漏的常见原因之一。因此需要你使用weak指针来避免。"><a href="#retain循环引用的概念，两个对象互相retain时，会导致两个对象都无法被释放，这也是内存泄漏的常见原因之一。因此需要你使用weak指针来避免。" class="headerlink" title="retain循环引用的概念，两个对象互相retain时，会导致两个对象都无法被释放，这也是内存泄漏的常见原因之一。因此需要你使用weak指针来避免。"></a>retain循环引用的概念，两个对象互相retain时，会导致两个对象都无法被释放，这也是内存泄漏的常见原因之一。因此需要你使用weak指针来避免。</h5><h5 id="还有Block使用不当导致的循环引用，下面会提到"><a href="#还有Block使用不当导致的循环引用，下面会提到" class="headerlink" title="还有Block使用不当导致的循环引用，下面会提到"></a>还有Block使用不当导致的循环引用，下面会提到</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DetailViewController *controller = [[DetailViewController alloc] initWithNibName:@<span class="string">"DetailViewController"</span> bundle:nil];</span><br><span class="line">controller.delegate = self;</span><br><span class="line">[self presentViewController:controller animated:YES completion:nil];</span><br></pre></td></tr></table></figure>
<h5 id="在上面代码中，MainViewController创建一个DetailViewController，并调用presentViewController将view呈现出来，从而拥有了一个strong指针指向创建的DetailViewController对象。反过来，DetailViewController也通过delegate拥有了一个指向MainViewController的weak指针。"><a href="#在上面代码中，MainViewController创建一个DetailViewController，并调用presentViewController将view呈现出来，从而拥有了一个strong指针指向创建的DetailViewController对象。反过来，DetailViewController也通过delegate拥有了一个指向MainViewController的weak指针。" class="headerlink" title="在上面代码中，MainViewController创建一个DetailViewController，并调用presentViewController将view呈现出来，从而拥有了一个strong指针指向创建的DetailViewController对象。反过来，DetailViewController也通过delegate拥有了一个指向MainViewController的weak指针。"></a>在上面代码中，MainViewController创建一个DetailViewController，并调用presentViewController将view呈现出来，从而拥有了一个strong指针指向创建的DetailViewController对象。反过来，DetailViewController也通过delegate拥有了一个指向MainViewController的weak指针。</h5><h5 id="当MainViewController调用dismissViewControllerAnimated-时，就会自动失去DetailViewController的strong引用，这时候DetailViewController对象就会被自动释放。"><a href="#当MainViewController调用dismissViewControllerAnimated-时，就会自动失去DetailViewController的strong引用，这时候DetailViewController对象就会被自动释放。" class="headerlink" title="当MainViewController调用dismissViewControllerAnimated:时，就会自动失去DetailViewController的strong引用，这时候DetailViewController对象就会被自动释放。"></a>当MainViewController调用dismissViewControllerAnimated:时，就会自动失去DetailViewController的strong引用，这时候DetailViewController对象就会被自动释放。</h5><h5 id="如果这两个指针都是strong类型，就会出现所有权回环。导致对象无法在适当的时候被释放。"><a href="#如果这两个指针都是strong类型，就会出现所有权回环。导致对象无法在适当的时候被释放。" class="headerlink" title="如果这两个指针都是strong类型，就会出现所有权回环。导致对象无法在适当的时候被释放。"></a>如果这两个指针都是strong类型，就会出现所有权回环。导致对象无法在适当的时候被释放。</h5><h4 id="unsafe-unretained"><a href="#unsafe-unretained" class="headerlink" title="unsafe_unretained"></a>unsafe_unretained</h4><h5 id="除了strong和weak，还有另外一个unsafe-unretained关键字，一般你不会使用到它。声明为unsafe-unretained的变量或property，编译器不会为其自动添加retain和release。unsafe-unretained只是为了兼容iOS-4，因为iOS-4没有weak-pointer-system。"><a href="#除了strong和weak，还有另外一个unsafe-unretained关键字，一般你不会使用到它。声明为unsafe-unretained的变量或property，编译器不会为其自动添加retain和release。unsafe-unretained只是为了兼容iOS-4，因为iOS-4没有weak-pointer-system。" class="headerlink" title="除了strong和weak，还有另外一个unsafe_unretained关键字，一般你不会使用到它。声明为unsafe_unretained的变量或property，编译器不会为其自动添加retain和release。unsafe_unretained只是为了兼容iOS 4，因为iOS 4没有weak pointer system。"></a>除了strong和weak，还有另外一个unsafe_unretained关键字，一般你不会使用到它。声明为unsafe_unretained的变量或property，编译器不会为其自动添加retain和release。unsafe_unretained只是为了兼容iOS 4，因为iOS 4没有weak pointer system。</h5><h5 id="这里大家做个了解就可以"><a href="#这里大家做个了解就可以" class="headerlink" title="这里大家做个了解就可以"></a>这里大家做个了解就可以</h5><hr>
<h2 id="ARC和Block"><a href="#ARC和Block" class="headerlink" title="ARC和Block"></a>ARC和Block</h2><h5 id="略"><a href="#略" class="headerlink" title="略"></a>略</h5><hr>
<h2 id="ARC和Singleton"><a href="#ARC和Singleton" class="headerlink" title="ARC和Singleton"></a>ARC和Singleton</h2><h4 id="MRC"><a href="#MRC" class="headerlink" title="MRC"></a>MRC</h4><h5 id="如果你的应用使用了Singleton，你的实现可能包含以下方法："><a href="#如果你的应用使用了Singleton，你的实现可能包含以下方法：" class="headerlink" title="如果你的应用使用了Singleton，你的实现可能包含以下方法："></a>如果你的应用使用了Singleton，你的实现可能包含以下方法：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> + (id)allocWithZone:(NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">return</span> [[self sharedInstance] retain];</span><br><span class="line">&#125;</span><br><span class="line">- (id)copyWithZone:(NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">return</span> self;</span><br><span class="line">&#125;</span><br><span class="line">- (id)retain</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">return</span> self;</span><br><span class="line">&#125;</span><br><span class="line">- (NSUInteger)retainCount</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">return</span> NSUIntegerMax;</span><br><span class="line">&#125;</span><br><span class="line">- (oneway void)release</span><br><span class="line">&#123;</span><br><span class="line">     // empty</span><br><span class="line">&#125;</span><br><span class="line">- (id)autorelease</span><br><span class="line">&#123; </span><br><span class="line">     <span class="built_in">return</span> self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="这是典型的singleton实现模式，retain和release都覆盖掉，使其不能创建多个实例对象。毕竟Singleton就是为了只创建一个全局对象。"><a href="#这是典型的singleton实现模式，retain和release都覆盖掉，使其不能创建多个实例对象。毕竟Singleton就是为了只创建一个全局对象。" class="headerlink" title="这是典型的singleton实现模式，retain和release都覆盖掉，使其不能创建多个实例对象。毕竟Singleton就是为了只创建一个全局对象。"></a>这是典型的singleton实现模式，retain和release都覆盖掉，使其不能创建多个实例对象。毕竟Singleton就是为了只创建一个全局对象。</h5><h4 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#import "AppManager.h"</span></span><br><span class="line"></span><br><span class="line">static AppManager   *_appManager = nil;</span><br><span class="line"></span><br><span class="line">@implementation AppManager</span><br><span class="line"></span><br><span class="line">+ (instancetype)sharedInstance &#123;</span><br><span class="line">    static dispatch_once_t  onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        _appManager = [[super allocWithZone:NULL] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">return</span> _appManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)allocWithZone:(struct _NSZone *)zone &#123;</span><br><span class="line">    <span class="built_in">return</span> [self sharedInstance];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (id)copyWithZone:(struct _NSZone *)zone OBJC_ARC_UNAVAILABLE;</span><br><span class="line">+ (id)mutableCopyWithZone:(struct _NSZone *)zone OBJC_ARC_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<h5 id="在ARC中，所有指针变量默认都是nil，在ARC之前，只有实例变量才会默认为nil。如果你编写下面代码："><a href="#在ARC中，所有指针变量默认都是nil，在ARC之前，只有实例变量才会默认为nil。如果你编写下面代码：" class="headerlink" title="在ARC中，所有指针变量默认都是nil，在ARC之前，只有实例变量才会默认为nil。如果你编写下面代码："></a>在ARC中，所有指针变量默认都是nil，在ARC之前，只有实例变量才会默认为nil。如果你编写下面代码：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> - (void)myMethod</span><br><span class="line">&#123;</span><br><span class="line">	int someNumber;</span><br><span class="line">	NSLog(@<span class="string">"Number: %d"</span>, someNumber);</span><br><span class="line">	NSString *someString;</span><br><span class="line">	NSLog(@<span class="string">"String: %p"</span>, someString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="编译器会：”Variable-is-uninitialized-when-used-here”，而输出则是随机数值："><a href="#编译器会：”Variable-is-uninitialized-when-used-here”，而输出则是随机数值：" class="headerlink" title="编译器会：”Variable is uninitialized when used here”，而输出则是随机数值："></a>编译器会：”Variable is uninitialized when used here”，而输出则是随机数值：</h5><h5 id="Woot-2186-207-Number-67"><a href="#Woot-2186-207-Number-67" class="headerlink" title="Woot[2186:207] Number: 67"></a>Woot[2186:207] Number: 67</h5><h5 id="Woot-2186-207-String-0x4babb5"><a href="#Woot-2186-207-String-0x4babb5" class="headerlink" title="Woot[2186:207] String: 0x4babb5"></a>Woot[2186:207] String: 0x4babb5</h5><h5 id="但在ARC中，输出则如下："><a href="#但在ARC中，输出则如下：" class="headerlink" title="但在ARC中，输出则如下："></a>但在ARC中，输出则如下：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Artists[2227:207] Number: 10120117</span><br><span class="line">Artists[2227:207] String: 0x0</span><br></pre></td></tr></table></figure>
<h5 id="int仍然是随机值（这样使用编译器也会警告），但someString的初始值已经是nil，这样的优点是指针永远不会指向非法对象。"><a href="#int仍然是随机值（这样使用编译器也会警告），但someString的初始值已经是nil，这样的优点是指针永远不会指向非法对象。" class="headerlink" title="int仍然是随机值（这样使用编译器也会警告），但someString的初始值已经是nil，这样的优点是指针永远不会指向非法对象。"></a>int仍然是随机值（这样使用编译器也会警告），但someString的初始值已经是nil，这样的优点是指针永远不会指向非法对象。</h5><h5 id="autorelease对象可能会比你想象中存活更长时间，在iOS中，每次UI事件（点击按钮等）都会清空一次-autorelease-pool（具体应该与RunLoop相关，后面文章会说到），但是如果你的事件处理器进行了大量操作，例如循环地创建许多对象，最好是使用你自己的-autorelease-pool，避免应用面临内存不足："><a href="#autorelease对象可能会比你想象中存活更长时间，在iOS中，每次UI事件（点击按钮等）都会清空一次-autorelease-pool（具体应该与RunLoop相关，后面文章会说到），但是如果你的事件处理器进行了大量操作，例如循环地创建许多对象，最好是使用你自己的-autorelease-pool，避免应用面临内存不足：" class="headerlink" title="autorelease对象可能会比你想象中存活更长时间，在iOS中，每次UI事件（点击按钮等）都会清空一次 autorelease pool（具体应该与RunLoop相关，后面文章会说到），但是如果你的事件处理器进行了大量操作，例如循环地创建许多对象，最好是使用你自己的 autorelease pool，避免应用面临内存不足："></a>autorelease对象可能会比你想象中存活更长时间，在iOS中，每次UI事件（点击按钮等）都会清空一次 autorelease pool（具体应该与RunLoop相关，后面文章会说到），但是如果你的事件处理器进行了大量操作，例如循环地创建许多对象，最好是使用你自己的 autorelease pool，避免应用面临内存不足：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; 10000; i++)</span><br><span class="line">&#123;</span><br><span class="line">     @autoreleasepool</span><br><span class="line">     &#123;</span><br><span class="line">          NSString *s = [NSString stringWithFormat:. . .];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><h5 id="此篇整理于2013年，如有错误，敬请斧正。"><a href="#此篇整理于2013年，如有错误，敬请斧正。" class="headerlink" title="此篇整理于2013年，如有错误，敬请斧正。"></a>此篇整理于2013年，如有错误，敬请斧正。</h5>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag"># iOS</a>
          
            <a href="/tags/内存管理/" rel="tag"># 内存管理</a>
          
            <a href="/tags/ARC/" rel="tag"># ARC</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/20/hello-world/" rel="next" title="Hello World">
                <i class="fa fa-chevron-left"></i> Hello World
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/21/Lighter-your-ViewController-打造轻量化ViewController/" rel="prev" title="Lighter your ViewController-打造轻量化ViewController">
                Lighter your ViewController-打造轻量化ViewController <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">垂杨小梳雨</p>
              <p class="site-description motion-element" itemprop="description">None</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是ARC"><span class="nav-number">1.</span> <span class="nav-text">什么是ARC</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ARC（Automatic-Reference-Counting）是在iOS5-0推出的新功能，是新LLVM-3-0编译器的特性。简单地说，就是代码中自动加入了retain-release，原先需要手动添加的用来处理内存管理的引用计数的代码可以自动地由编译器完成了。"><span class="nav-number">1.0.0.1.</span> <span class="nav-text">ARC（Automatic Reference Counting）是在iOS5.0推出的新功能，是新LLVM 3.0编译器的特性。简单地说，就是代码中自动加入了retain/release，原先需要手动添加的用来处理内存管理的引用计数的代码可以自动地由编译器完成了。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ARC是编译器特性，而不是iOS运行时特性（除了weak指针系统-它会在所指向的内存释放的时候自动将自身置为nil，后面文章会专门说下），它也不是其它语言中的垃圾收集器。因此ARC和手动内存管理性能是一样的，有些时候还能更加快速，因为编译器还可以执行某些优化。"><span class="nav-number">1.0.0.2.</span> <span class="nav-text">ARC是编译器特性，而不是iOS运行时特性（除了weak指针系统,它会在所指向的内存释放的时候自动将自身置为nil，后面文章会专门说下），它也不是其它语言中的垃圾收集器。因此ARC和手动内存管理性能是一样的，有些时候还能更加快速，因为编译器还可以执行某些优化。</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#ARC使用规则"><span class="nav-number">2.</span> <span class="nav-text">ARC使用规则</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ARC下，指针保持对象的生命。只有还有一个变量（strong）指向对象，对象就会保持在内存中。"><span class="nav-number">2.0.0.1.</span> <span class="nav-text">ARC下，指针保持对象的生命。只有还有一个变量（strong）指向对象，对象就会保持在内存中。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#上图中，firstName现在指向NSString对象，这时这个对象（textField的内容字符串）将被hold住。比如用字符串-“Ray”作为例子（字符串的retainCount规则和普通的对象不一样，这边就把它当作一个普通的对象来看吧…），这个时候firstName持有了-”Ray”。retainCount-＝-1。"><span class="nav-number">2.0.0.2.</span> <span class="nav-text">上图中，firstName现在指向NSString对象，这时这个对象（textField的内容字符串）将被hold住。比如用字符串@“Ray”作为例子（字符串的retainCount规则和普通的对象不一样，这边就把它当作一个普通的对象来看吧…），这个时候firstName持有了@”Ray”。retainCount ＝ 1。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#一个对象可以有多个拥有者-如上图：retainCount-2。"><span class="nav-number">2.0.0.3.</span> <span class="nav-text">一个对象可以有多个拥有者,如上图：retainCount=2。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#当用户修改了文本框的text后，此时text属性会指向新的对象。原来的对象仍有firstName指向"><span class="nav-number">2.0.0.4.</span> <span class="nav-text">当用户修改了文本框的text后，此时text属性会指向新的对象。原来的对象仍有firstName指向</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#而当firstName指向另外一个对象时，或者超出作用域范围时，-“Ray”这个字符串对象不在有任何所有者，retainCount-＝-0，将会被释放。"><span class="nav-number">2.0.0.5.</span> <span class="nav-text">而当firstName指向另外一个对象时，或者超出作用域范围时，@“Ray”这个字符串对象不在有任何所有者，retainCount ＝ 0，将会被释放。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#WARNING-上面我们所说的firstName、text这些指针都是“Strong”，能够保持对象的生命。默认的实例、本地变量都是Strong类型。"><span class="nav-number">2.0.0.6.</span> <span class="nav-text">WARNING:上面我们所说的firstName、text这些指针都是“Strong”，能够保持对象的生命。默认的实例、本地变量都是Strong类型。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#这边再提下刚刚我们说到的ARC的一个基本规则。"><span class="nav-number">2.0.0.7.</span> <span class="nav-text">这边再提下刚刚我们说到的ARC的一个基本规则。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#weak指针"><span class="nav-number">2.0.1.</span> <span class="nav-text">weak指针</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#weak变量仍然指向一个对象，但不是对象的拥有者："><span class="nav-number">2.0.1.1.</span> <span class="nav-text">weak变量仍然指向一个对象，但不是对象的拥有者：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#当self-textField-text指向其他对象，-此时weakName会自动变成nil，称为“zeroing”-weak-pointer："><span class="nav-number">2.0.1.2.</span> <span class="nav-text">当self.textField.text指向其他对象， 此时weakName会自动变成nil，称为“zeroing” weak pointer：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#它解决了MRC下assign指针指向已经释放的对象（我们常说的野指针），对它发送消息Crash的问题。"><span class="nav-number">2.0.1.3.</span> <span class="nav-text">它解决了MRC下assign指针指向已经释放的对象（我们常说的野指针），对它发送消息Crash的问题。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ARC可以节省代码（MRC下属性赋值），我们不需要关心什么时候retain、release。但是不意味着我们不需要考虑内存管理"><span class="nav-number">2.0.1.4.</span> <span class="nav-text">ARC可以节省代码（MRC下属性赋值），我们不需要关心什么时候retain、release。但是不意味着我们不需要考虑内存管理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#内存管理其他注意点："><span class="nav-number">2.0.1.5.</span> <span class="nav-text">内存管理其他注意点：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ARC限制：-用于NSObject对象。"><span class="nav-number">2.0.1.6.</span> <span class="nav-text">ARC限制： 用于NSObject对象。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#如果应用使用了Core-Foundation或malloc-free-，此时需要你来管理内存（这个我们下面再说）"><span class="nav-number">2.0.1.7.</span> <span class="nav-text">如果应用使用了Core Foundation或malloc()/free()，此时需要你来管理内存（这个我们下面再说）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Xcode的ARC自动迁移"><span class="nav-number">3.</span> <span class="nav-text">Xcode的ARC自动迁移</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#要启用一个项目的ARC，你有以下几种选择："><span class="nav-number">3.0.0.1.</span> <span class="nav-text">要启用一个项目的ARC，你有以下几种选择：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#这边说下测试提出的需要将IBOutlet改为Strong的事情。"><span class="nav-number">3.0.0.2.</span> <span class="nav-text">这边说下测试提出的需要将IBOutlet改为Strong的事情。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#在ARC中，所有outlet属性都推荐使用weak，这些view对象已经属于View-Controller的view-hierarchy，不需要再次定义为strong（ARC中效果等同于retain）。唯一应该使用strong的outlet是File’s-Owner，连接到nib的顶层对象。"><span class="nav-number">3.0.0.3.</span> <span class="nav-text">在ARC中，所有outlet属性都推荐使用weak，这些view对象已经属于View Controller的view hierarchy，不需要再次定义为strong（ARC中效果等同于retain）。唯一应该使用strong的outlet是File’s Owner，连接到nib的顶层对象。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ARC中dealloc与autorelease"><span class="nav-number">4.</span> <span class="nav-text">ARC中dealloc与autorelease</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dealloc"><span class="nav-number">4.1.</span> <span class="nav-text">dealloc</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#在ARC下我们一般不需要写dealloc函数。因为我们不需要调用-super-dealloc-也不需要release属性。而Strong属性出了作用域（这个class）会被置为nil，对象相应的会被释放销毁。（内存从创建到如何销毁下面文章会写到）"><span class="nav-number">4.1.0.1.</span> <span class="nav-text">在ARC下我们一般不需要写dealloc函数。因为我们不需要调用[super dealloc],也不需要release属性。而Strong属性出了作用域（这个class）会被置为nil，对象相应的会被释放销毁。（内存从创建到如何销毁下面文章会写到）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#而dealloc函数还是会被调用执行的，在这个函数里面，我们有时候需要释放CoreFoundation对象、remove-observer、remove-KVO以及一些其他资源（-AudioServicesDisposeSystemSoundID-soundID-）"><span class="nav-number">4.1.0.2.</span> <span class="nav-text">而dealloc函数还是会被调用执行的，在这个函数里面，我们有时候需要释放CoreFoundation对象、remove observer、remove KVO以及一些其他资源（ AudioServicesDisposeSystemSoundID(soundID); ）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#这里要注意的是：不要在dealloc函数中释放Timer。NSTimer会保持一份target强引用，导致这个Class永远不会被释放。所以需要在对象Class销毁前做处理"><span class="nav-number">4.1.0.3.</span> <span class="nav-text">这里要注意的是：不要在dealloc函数中释放Timer。NSTimer会保持一份target强引用，导致这个Class永远不会被释放。所以需要在对象Class销毁前做处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#在Github上有个开源项目MSWeakTimer。"><span class="nav-number">4.1.0.4.</span> <span class="nav-text">在Github上有个开源项目MSWeakTimer。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#autoreleasepool"><span class="nav-number">4.2.</span> <span class="nav-text">autoreleasepool</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ARC仍然保留了AutoreleasePool，但是采用了新的Block语法，于是我们的main函数会如下修改："><span class="nav-number">4.2.0.1.</span> <span class="nav-text">ARC仍然保留了AutoreleasePool，但是采用了新的Block语法，于是我们的main函数会如下修改：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#修改为："><span class="nav-number">4.2.0.2.</span> <span class="nav-text">修改为：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Core-Foundation的内存管理-Toll-Free-Bridge"><span class="nav-number">5.</span> <span class="nav-text">Core Foundation的内存管理-Toll-Free Bridge</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#在ARC下，objective-c对象与Core-Foundation对象相互转换时，需要用到briage-cast。"><span class="nav-number">5.0.0.1.</span> <span class="nav-text">在ARC下，objective-c对象与Core Foundation对象相互转换时，需要用到briage cast。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#举个栗子：NSString和CFStringRef就可以同等对待，在任何地方都可以互换使用，背后的设计就是toll-free-bridging。"><span class="nav-number">5.0.0.2.</span> <span class="nav-text">举个栗子：NSString和CFStringRef就可以同等对待，在任何地方都可以互换使用，背后的设计就是toll-free bridging。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#当然，alloc分配了NSString对象，你需要在使用完之后进行释放，注意是释放转换后的CFStringRef对象："><span class="nav-number">5.0.0.3.</span> <span class="nav-text">当然，alloc分配了NSString对象，你需要在使用完之后进行释放，注意是释放转换后的CFStringRef对象：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#反过来，从Core-Foundation到Objective-C的方向也类似："><span class="nav-number">5.0.0.4.</span> <span class="nav-text">反过来，从Core Foundation到Objective-C的方向也类似：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#在ARC下，情况变得不一样！以下代码在手动内存管理中是完全合法的，但在ARC中却存在问题："><span class="nav-number">5.0.0.5.</span> <span class="nav-text">在ARC下，情况变得不一样！以下代码在手动内存管理中是完全合法的，但在ARC中却存在问题：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#如果你把一个NSObject当作Core-Foundation对象来使用，则ARC将不再负责释放该对象。但你必须明确地告诉ARC你的这个意图，编译器没办法自己做主。"><span class="nav-number">5.0.0.6.</span> <span class="nav-text">如果你把一个NSObject当作Core Foundation对象来使用，则ARC将不再负责释放该对象。但你必须明确地告诉ARC你的这个意图，编译器没办法自己做主。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#同样如果你创建一个Core-Foundation对象并把它转换为NSObject对象，你也必须告诉ARC占据对象的所有权，并在适当的时候释放该对象。这就是所谓的bridging-casts。"><span class="nav-number">5.0.0.7.</span> <span class="nav-text">同样如果你创建一个Core Foundation对象并把它转换为NSObject对象，你也必须告诉ARC占据对象的所有权，并在适当的时候释放该对象。这就是所谓的bridging casts。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#上面代码中，CFURLCreateStringByAddingPercentEscapes-函数的参数需要两个CFStringRef对象，其中常量NSString可以直接转换，因为不需要进行对象释放；但是-text-参数不一样，它是传递进来的一个NSString对象。而函数参数和局部变量一样，都是strong指针，这种对象在函数入口处会被retain，并且对象会持续存在直到指针被销毁（这里也就是函数返回时）。"><span class="nav-number">5.0.0.8.</span> <span class="nav-text">上面代码中，CFURLCreateStringByAddingPercentEscapes()函数的参数需要两个CFStringRef对象，其中常量NSString可以直接转换，因为不需要进行对象释放；但是 text 参数不一样，它是传递进来的一个NSString对象。而函数参数和局部变量一样，都是strong指针，这种对象在函数入口处会被retain，并且对象会持续存在直到指针被销毁（这里也就是函数返回时）。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#对于text参数，我们希望ARC保持这个变量的所有权，同时又希望临时将它当作CFStringRef对象来使用。这种情况下可以使用-bridge说明符，它告诉ARC不要更改对象的所有权，按普通规则释放该对象即可。"><span class="nav-number">5.0.0.9.</span> <span class="nav-text">对于text参数，我们希望ARC保持这个变量的所有权，同时又希望临时将它当作CFStringRef对象来使用。这种情况下可以使用__bridge说明符，它告诉ARC不要更改对象的所有权，按普通规则释放该对象即可。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#多数情况下，Objective-C对象和Core-Foundation对象之间互相转换时，我们都应该使用-bridge。"><span class="nav-number">5.0.0.10.</span> <span class="nav-text">多数情况下，Objective-C对象和Core Foundation对象之间互相转换时，我们都应该使用__bridge。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#但是-它lei来了"><span class="nav-number">5.0.1.</span> <span class="nav-text">但是~它lei来了</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#但是有时候我们确实需要给予ARC某个对象的所有权，或者解除ARC对某个对象的所有权。这种情况下我们就需要使用另外两种bridging-casts："><span class="nav-number">5.0.1.1.</span> <span class="nav-text">但是有时候我们确实需要给予ARC某个对象的所有权，或者解除ARC对某个对象的所有权。这种情况下我们就需要使用另外两种bridging casts：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#因为-CFURLCreateStringByAddingPercentEscapes-函数创建了一个新的CFStringRef对象-而我们要的是NSString对象，因此我们要强制转换。"><span class="nav-number">5.0.1.2.</span> <span class="nav-text">因为 CFURLCreateStringByAddingPercentEscapes() 函数创建了一个新的CFStringRef对象,而我们要的是NSString对象，因此我们要强制转换。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#当我们不需要强制转换为NSObject对象时，我们只需要调用CFRelease方法即可"><span class="nav-number">5.0.1.3.</span> <span class="nav-text">当我们不需要强制转换为NSObject对象时，我们只需要调用CFRelease方法即可</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#这里需要我们使用-bridge-transfer"><span class="nav-number">5.0.2.</span> <span class="nav-text">这里需要我们使用  __bridge_transfer </span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#bridge-transfer-会告诉ARC：”Hi，ARC同学，好久不见。我这里有个货是一个CFStringRef对象，但是有人把它搞成了NSString对象了，我希望你来管-销毁-它，我这里就撒手不管了-调用CFRelease-”。"><span class="nav-number">5.0.2.1.</span> <span class="nav-text"> __bridge_transfer 会告诉ARC：”Hi，ARC同学，好久不见。我这里有个货是一个CFStringRef对象，但是有人把它搞成了NSString对象了，我希望你来管(销毁)它，我这里就撒手不管了(调用CFRelease())”。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#如果我们使用-bridge，就会导致内存泄漏。ARC并不知道自己应该在使用完对象之后释放该对象，也没有人调用CFRelease-。结果这个对象就会永远保留在内存中。因此选择正确的-bridge-说明符是至关重要的。"><span class="nav-number">5.0.2.2.</span> <span class="nav-text">如果我们使用 __bridge，就会导致内存泄漏。ARC并不知道自己应该在使用完对象之后释放该对象，也没有人调用CFRelease()。结果这个对象就会永远保留在内存中。因此选择正确的 bridge 说明符是至关重要的。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#为了代码更加可读和容易理解，iOS还提供了一个辅助函数：CFBridgingRelease-。函数所做事情和-bridge-transfer-强制转换完全一样，但更加简洁和清晰。CFBridgingRelease-函数定义为内联函数，因此不会导致额外的开销。函数之所以命名为CFBridgingRelease-，是因为一般你会在需要使用CFRelease-释放对象的地方，调用CFBridgingRelease-来传递对象的所有权。"><span class="nav-number">5.0.2.3.</span> <span class="nav-text">为了代码更加可读和容易理解，iOS还提供了一个辅助函数：CFBridgingRelease()。函数所做事情和 __bridge_transfer 强制转换完全一样，但更加简洁和清晰。CFBridgingRelease() 函数定义为内联函数，因此不会导致额外的开销。函数之所以命名为CFBridgingRelease()，是因为一般你会在需要使用CFRelease()释放对象的地方，调用CFBridgingRelease()来传递对象的所有权。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#清晰明了"><span class="nav-number">5.0.3.</span> <span class="nav-text">清晰明了</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#因此最后我们的代码如下："><span class="nav-number">5.0.3.1.</span> <span class="nav-text">因此最后我们的代码如下：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#另一个常见的需要CFBridgingRelease的情况是AddressBook-framework："><span class="nav-number">5.0.4.</span> <span class="nav-text">另一个常见的需要CFBridgingRelease的情况是AddressBook framework：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-只要你调用命名为Create-Copy-Retain的Core-Foundation函数，你都需要使用-CFBridgingRelease-安全地将值传递给ARC。"><span class="nav-number">5.1.</span> <span class="nav-text">总结:只要你调用命名为Create, Copy, Retain的Core Foundation函数，你都需要使用 CFBridgingRelease() 安全地将值传递给ARC。</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#bridge-retained-则正好相反，假设你有一个NSString对象，并且要将它传递给某个Core-Foundation-API，该函数希望接收这个string对象的所有权。这时候你就不希望ARC也去释放该对象，否则就会对同一对象释放两次，而且必将导致应用崩溃！换句话说，使用-bridge-retained-将对象的所有权给予-Core-Foundation，而ARC不再负责释放该对象。"><span class="nav-number">5.1.0.1.</span> <span class="nav-text"> bridge_retained  则正好相反，假设你有一个NSString对象，并且要将它传递给某个Core Foundation API，该函数希望接收这个string对象的所有权。这时候你就不希望ARC也去释放该对象，否则就会对同一对象释放两次，而且必将导致应用崩溃！换句话说，使用 bridge_retained 将对象的所有权给予 Core Foundation，而ARC不再负责释放该对象。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#如下面例子所示："><span class="nav-number">5.1.0.2.</span> <span class="nav-text">如下面例子所示：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#一旦-bridge-retained-CFStringRef-转换完成，ARC就不再负责释放该对象。如果你在这里使用-bridge，应用就很可能会崩溃。ARC可能在Core-Foundation正在使用该对象时，释放掉它。"><span class="nav-number">5.1.0.3.</span> <span class="nav-text">一旦 (bridge_retained CFStringRef) 转换完成，ARC就不再负责释放该对象。如果你在这里使用 bridge，应用就很可能会崩溃。ARC可能在Core Foundation正在使用该对象时，释放掉它。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#同样-bridge-retained-也有一个辅助函数：CFBridgingRetain-。从名字就可以看出，这个函数会让Core-Foundation执行retain，实际如下："><span class="nav-number">5.1.0.4.</span> <span class="nav-text">同样 __bridge_retained  也有一个辅助函数：CFBridgingRetain()。从名字就可以看出，这个函数会让Core Foundation执行retain，实际如下：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#现在你应该明白了，上面例子的CFRelease-是和CFBridgingRetain-对应的。"><span class="nav-number">5.1.0.5.</span> <span class="nav-text">现在你应该明白了，上面例子的CFRelease()是和CFBridgingRetain()对应的。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结："><span class="nav-number">5.2.</span> <span class="nav-text">总结：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Delegate和Weak-Property"><span class="nav-number">6.</span> <span class="nav-text">Delegate和Weak Property</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#使用Delegate模式时，通常我们会使用weak-property来引用delegate，这样可以避免所有权回环。"><span class="nav-number">6.0.0.1.</span> <span class="nav-text">使用Delegate模式时，通常我们会使用weak property来引用delegate，这样可以避免所有权回环。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#retain循环引用的概念，两个对象互相retain时，会导致两个对象都无法被释放，这也是内存泄漏的常见原因之一。因此需要你使用weak指针来避免。"><span class="nav-number">6.0.0.2.</span> <span class="nav-text">retain循环引用的概念，两个对象互相retain时，会导致两个对象都无法被释放，这也是内存泄漏的常见原因之一。因此需要你使用weak指针来避免。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#还有Block使用不当导致的循环引用，下面会提到"><span class="nav-number">6.0.0.3.</span> <span class="nav-text">还有Block使用不当导致的循环引用，下面会提到</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#在上面代码中，MainViewController创建一个DetailViewController，并调用presentViewController将view呈现出来，从而拥有了一个strong指针指向创建的DetailViewController对象。反过来，DetailViewController也通过delegate拥有了一个指向MainViewController的weak指针。"><span class="nav-number">6.0.0.4.</span> <span class="nav-text">在上面代码中，MainViewController创建一个DetailViewController，并调用presentViewController将view呈现出来，从而拥有了一个strong指针指向创建的DetailViewController对象。反过来，DetailViewController也通过delegate拥有了一个指向MainViewController的weak指针。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#当MainViewController调用dismissViewControllerAnimated-时，就会自动失去DetailViewController的strong引用，这时候DetailViewController对象就会被自动释放。"><span class="nav-number">6.0.0.5.</span> <span class="nav-text">当MainViewController调用dismissViewControllerAnimated:时，就会自动失去DetailViewController的strong引用，这时候DetailViewController对象就会被自动释放。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#如果这两个指针都是strong类型，就会出现所有权回环。导致对象无法在适当的时候被释放。"><span class="nav-number">6.0.0.6.</span> <span class="nav-text">如果这两个指针都是strong类型，就会出现所有权回环。导致对象无法在适当的时候被释放。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unsafe-unretained"><span class="nav-number">6.0.1.</span> <span class="nav-text">unsafe_unretained</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#除了strong和weak，还有另外一个unsafe-unretained关键字，一般你不会使用到它。声明为unsafe-unretained的变量或property，编译器不会为其自动添加retain和release。unsafe-unretained只是为了兼容iOS-4，因为iOS-4没有weak-pointer-system。"><span class="nav-number">6.0.1.1.</span> <span class="nav-text">除了strong和weak，还有另外一个unsafe_unretained关键字，一般你不会使用到它。声明为unsafe_unretained的变量或property，编译器不会为其自动添加retain和release。unsafe_unretained只是为了兼容iOS 4，因为iOS 4没有weak pointer system。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#这里大家做个了解就可以"><span class="nav-number">6.0.1.2.</span> <span class="nav-text">这里大家做个了解就可以</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ARC和Block"><span class="nav-number">7.</span> <span class="nav-text">ARC和Block</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#略"><span class="nav-number">7.0.0.1.</span> <span class="nav-text">略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ARC和Singleton"><span class="nav-number">8.</span> <span class="nav-text">ARC和Singleton</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MRC"><span class="nav-number">8.0.1.</span> <span class="nav-text">MRC</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#如果你的应用使用了Singleton，你的实现可能包含以下方法："><span class="nav-number">8.0.1.1.</span> <span class="nav-text">如果你的应用使用了Singleton，你的实现可能包含以下方法：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#这是典型的singleton实现模式，retain和release都覆盖掉，使其不能创建多个实例对象。毕竟Singleton就是为了只创建一个全局对象。"><span class="nav-number">8.0.1.2.</span> <span class="nav-text">这是典型的singleton实现模式，retain和release都覆盖掉，使其不能创建多个实例对象。毕竟Singleton就是为了只创建一个全局对象。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ARC"><span class="nav-number">8.0.2.</span> <span class="nav-text">ARC</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#在ARC中，所有指针变量默认都是nil，在ARC之前，只有实例变量才会默认为nil。如果你编写下面代码："><span class="nav-number">8.0.2.1.</span> <span class="nav-text">在ARC中，所有指针变量默认都是nil，在ARC之前，只有实例变量才会默认为nil。如果你编写下面代码：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#编译器会：”Variable-is-uninitialized-when-used-here”，而输出则是随机数值："><span class="nav-number">8.0.2.2.</span> <span class="nav-text">编译器会：”Variable is uninitialized when used here”，而输出则是随机数值：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Woot-2186-207-Number-67"><span class="nav-number">8.0.2.3.</span> <span class="nav-text">Woot[2186:207] Number: 67</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Woot-2186-207-String-0x4babb5"><span class="nav-number">8.0.2.4.</span> <span class="nav-text">Woot[2186:207] String: 0x4babb5</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#但在ARC中，输出则如下："><span class="nav-number">8.0.2.5.</span> <span class="nav-text">但在ARC中，输出则如下：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#int仍然是随机值（这样使用编译器也会警告），但someString的初始值已经是nil，这样的优点是指针永远不会指向非法对象。"><span class="nav-number">8.0.2.6.</span> <span class="nav-text">int仍然是随机值（这样使用编译器也会警告），但someString的初始值已经是nil，这样的优点是指针永远不会指向非法对象。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#autorelease对象可能会比你想象中存活更长时间，在iOS中，每次UI事件（点击按钮等）都会清空一次-autorelease-pool（具体应该与RunLoop相关，后面文章会说到），但是如果你的事件处理器进行了大量操作，例如循环地创建许多对象，最好是使用你自己的-autorelease-pool，避免应用面临内存不足："><span class="nav-number">8.0.2.7.</span> <span class="nav-text">autorelease对象可能会比你想象中存活更长时间，在iOS中，每次UI事件（点击按钮等）都会清空一次 autorelease pool（具体应该与RunLoop相关，后面文章会说到），但是如果你的事件处理器进行了大量操作，例如循环地创建许多对象，最好是使用你自己的 autorelease pool，避免应用面临内存不足：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最后"><span class="nav-number">9.</span> <span class="nav-text">最后</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#此篇整理于2013年，如有错误，敬请斧正。"><span class="nav-number">9.0.0.1.</span> <span class="nav-text">此篇整理于2013年，如有错误，敬请斧正。</span></a></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">垂杨小梳雨</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
