<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">
<meta name="google-site-verification" content="H2oSN0uYOmfFvx5hCvt0zPYP4ekyAQlLKkExeaFjhrg">








<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="None">
<meta name="keywords" content="iOS,swift,react-native,javascript,微信开发,微信小程序,C,C语言,程序猿,博客,Lyddwn,码农">
<meta property="og:type" content="website">
<meta property="og:title" content="Lyddwn">
<meta property="og:url" content="http://jackthenoob.github.io/page/2/index.html">
<meta property="og:site_name" content="Lyddwn">
<meta property="og:description" content="None">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lyddwn">
<meta name="twitter:description" content="None">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://jackthenoob.github.io/page/2/">





  <title>Lyddwn</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Lyddwn</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">生活不只是代码</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            Commonweal 404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jackthenoob.github.io/2019/05/21/Lighter-your-ViewController-打造轻量化ViewController/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="垂杨小梳雨">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lyddwn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/21/Lighter-your-ViewController-打造轻量化ViewController/" itemprop="url">Lighter your ViewController-打造轻量化ViewController</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-21T10:18:23+08:00">
                2019-05-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h5 id="随着业务的不断迭代，一些较大的业务模块的ViewController变得极为臃肿，越来越难以维护。为ViewController瘦身变成的越来越迫切。"><a href="#随着业务的不断迭代，一些较大的业务模块的ViewController变得极为臃肿，越来越难以维护。为ViewController瘦身变成的越来越迫切。" class="headerlink" title="随着业务的不断迭代，一些较大的业务模块的ViewController变得极为臃肿，越来越难以维护。为ViewController瘦身变成的越来越迫切。"></a>随着业务的不断迭代，一些较大的业务模块的ViewController变得极为臃肿，越来越难以维护。为ViewController瘦身变成的越来越迫切。</h5><h5 id="提供一些思路供大家参考。"><a href="#提供一些思路供大家参考。" class="headerlink" title="提供一些思路供大家参考。"></a>提供一些思路供大家参考。</h5><h2 id="1-Separate-out-UITableViewDataSource-and-UITableViewDelegate"><a href="#1-Separate-out-UITableViewDataSource-and-UITableViewDelegate" class="headerlink" title="1.Separate out UITableViewDataSource and UITableViewDelegate"></a>1.Separate out UITableViewDataSource and UITableViewDelegate</h2><h5 id="剥离DataSource和其他Protocols"><a href="#剥离DataSource和其他Protocols" class="headerlink" title="剥离DataSource和其他Protocols"></a>剥离DataSource和其他Protocols</h5><h5 id="这个方法最早见于objc-io上。将UITableViewDatasource相关的代码从ViewController中抽取并封装到其他类中。也相对提高重用性。"><a href="#这个方法最早见于objc-io上。将UITableViewDatasource相关的代码从ViewController中抽取并封装到其他类中。也相对提高重用性。" class="headerlink" title="这个方法最早见于objc.io上。将UITableViewDatasource相关的代码从ViewController中抽取并封装到其他类中。也相对提高重用性。"></a>这个方法最早见于objc.io上。将UITableViewDatasource相关的代码从ViewController中抽取并封装到其他类中。也相对提高重用性。</h5><h5 id="然后我在一个较大的业务中尝试使用了。感觉效果一般。"><a href="#然后我在一个较大的业务中尝试使用了。感觉效果一般。" class="headerlink" title="然后我在一个较大的业务中尝试使用了。感觉效果一般。"></a>然后我在一个较大的业务中尝试使用了。感觉效果一般。</h5><h5 id="示例工程中，有一个类PhotosViewController，里面原本有如下3个方法："><a href="#示例工程中，有一个类PhotosViewController，里面原本有如下3个方法：" class="headerlink" title="示例工程中，有一个类PhotosViewController，里面原本有如下3个方法："></a>示例工程中，有一个类PhotosViewController，里面原本有如下3个方法：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pragma mark Pragma </span></span><br><span class="line">  </span><br><span class="line">- (Photo*)photoAtIndexPath:(NSIndexPath*)indexPath &#123; </span><br><span class="line">	<span class="built_in">return</span> photos[(NSUInteger)indexPath.row]; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line">- (NSInteger)tableView:(UITableView*)tableView </span><br><span class="line">numberOfRowsInSection:(NSInteger)section &#123; </span><br><span class="line">	<span class="built_in">return</span> photos.count; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line">- (UITableViewCell*)tableView:(UITableView*)tableView </span><br><span class="line">cellForRowAtIndexPath:(NSIndexPath*)indexPath &#123; </span><br><span class="line">	PhotoCell* cell = [tableView dequeueReusableCellWithIdentifier:PhotoCellIdentifier forIndexPath:indexPath]; </span><br><span class="line">	Photo* photo = [self photoAtIndexPath:indexPath]; </span><br><span class="line">	cell.label.text = photo.name; </span><br><span class="line">	<span class="built_in">return</span> cell; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="如下代码所示，这里通过一个block来配置UITableViewCell，当然，也可以使用delegate对UITableViewCell进行配置，这主要取决于开发者。"><a href="#如下代码所示，这里通过一个block来配置UITableViewCell，当然，也可以使用delegate对UITableViewCell进行配置，这主要取决于开发者。" class="headerlink" title="如下代码所示，这里通过一个block来配置UITableViewCell，当然，也可以使用delegate对UITableViewCell进行配置，这主要取决于开发者。"></a>如下代码所示，这里通过一个block来配置UITableViewCell，当然，也可以使用delegate对UITableViewCell进行配置，这主要取决于开发者。</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@implementation ArrayDataSource </span><br><span class="line">  </span><br><span class="line">- (id)itemAtIndexPath:(NSIndexPath*)indexPath &#123; </span><br><span class="line">	<span class="built_in">return</span> items[(NSUInteger)indexPath.row]; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line">- (NSInteger)tableView:(UITableView*)tableView </span><br><span class="line">numberOfRowsInSection:(NSInteger)section &#123; </span><br><span class="line">	<span class="built_in">return</span> items.count; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line">- (UITableViewCell*)tableView:(UITableView*)tableView </span><br><span class="line">cellForRowAtIndexPath:(NSIndexPath*)indexPath &#123; </span><br><span class="line">	id cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier forIndexPath:indexPath]; </span><br><span class="line">	id item = [self itemAtIndexPath:indexPath]; </span><br><span class="line">	configureCellBlock(cell,item); </span><br><span class="line">	<span class="built_in">return</span> cell; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h5 id="可以把ViewController中的那3个方法移除掉，并创建自定义类的一个示例对象，然后将其设置为table-view的data-source，如下代码所示。"><a href="#可以把ViewController中的那3个方法移除掉，并创建自定义类的一个示例对象，然后将其设置为table-view的data-source，如下代码所示。" class="headerlink" title="可以把ViewController中的那3个方法移除掉，并创建自定义类的一个示例对象，然后将其设置为table view的data source，如下代码所示。"></a>可以把ViewController中的那3个方法移除掉，并创建自定义类的一个示例对象，然后将其设置为table view的data source，如下代码所示。</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">	void (^configureCell)(PhotoCell*, Photo*) = ^(PhotoCell* cell, Photo* photo) &#123; </span><br><span class="line">		cell.label.text = photo.name; </span><br><span class="line">	&#125;; </span><br><span class="line">	photosArrayDataSource = [[ArrayDataSource alloc] initWithItems:photos </span><br><span class="line">	cellIdentifier:PhotoCellIdentifier </span><br><span class="line">	configureCellBlock:configureCell]; </span><br><span class="line">	self.tableView.dataSource = photosArrayDataSource; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-Category"><a href="#2-Category" class="headerlink" title="2.Category"></a>2.Category</h2><h5 id="大体思路：根据当前业务，将业务拆分为多个小模块。创建多个Category，每个Category处理自己业务模块逻辑。"><a href="#大体思路：根据当前业务，将业务拆分为多个小模块。创建多个Category，每个Category处理自己业务模块逻辑。" class="headerlink" title="大体思路：根据当前业务，将业务拆分为多个小模块。创建多个Category，每个Category处理自己业务模块逻辑。"></a>大体思路：根据当前业务，将业务拆分为多个小模块。创建多个Category，每个Category处理自己业务模块逻辑。</h5><h5 id="目录结构如下："><a href="#目录结构如下：" class="headerlink" title="目录结构如下："></a>目录结构如下：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">OrderViewController.h</span><br><span class="line">OrderViewController.m</span><br><span class="line">OrderViewController+NetRequest.h</span><br><span class="line">OrderViewController+NetRequest.m</span><br><span class="line">OrderViewController+DataReport.h</span><br><span class="line">OrderViewController+DataReport.m</span><br><span class="line">OrderViewController+Address.h</span><br><span class="line">OrderViewController+Address.m</span><br><span class="line">OrderViewController+Shipping.h</span><br><span class="line">OrderViewController+Shipping.m</span><br><span class="line">OrderViewController+Invoice.h</span><br><span class="line">OrderViewController+Invoice.m</span><br><span class="line">OrderViewController+Wallet.h</span><br><span class="line">OrderViewController+Wallet.m</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h5 id="上面目录结构是电商的订单提交页面，主体功能可以分为订单地址、配送信息、发票、钱包等业务场景，再将网络请求、数据上报等功能抽离到相应Category，实现代码分离。减少主ViewController大小。"><a href="#上面目录结构是电商的订单提交页面，主体功能可以分为订单地址、配送信息、发票、钱包等业务场景，再将网络请求、数据上报等功能抽离到相应Category，实现代码分离。减少主ViewController大小。" class="headerlink" title="上面目录结构是电商的订单提交页面，主体功能可以分为订单地址、配送信息、发票、钱包等业务场景，再将网络请求、数据上报等功能抽离到相应Category，实现代码分离。减少主ViewController大小。"></a>上面目录结构是电商的订单提交页面，主体功能可以分为订单地址、配送信息、发票、钱包等业务场景，再将网络请求、数据上报等功能抽离到相应Category，实现代码分离。减少主ViewController大小。</h5><h5 id="其实还是比较简单有效的方法。如果要说弊端，那最多可能稍微拖慢App加载速度吧。"><a href="#其实还是比较简单有效的方法。如果要说弊端，那最多可能稍微拖慢App加载速度吧。" class="headerlink" title="其实还是比较简单有效的方法。如果要说弊端，那最多可能稍微拖慢App加载速度吧。"></a>其实还是比较简单有效的方法。如果要说弊端，那最多可能稍微拖慢App加载速度吧。</h5><h2 id="3-模块化调用"><a href="#3-模块化调用" class="headerlink" title="3.模块化调用"></a>3.模块化调用</h2><h5 id="将一些业务逻辑处理封装到其他类中，由ViewController去调用这些类。即：不要在ViewController中做一些复杂的逻辑处理，由其他类代理处理"><a href="#将一些业务逻辑处理封装到其他类中，由ViewController去调用这些类。即：不要在ViewController中做一些复杂的逻辑处理，由其他类代理处理" class="headerlink" title="将一些业务逻辑处理封装到其他类中，由ViewController去调用这些类。即：不要在ViewController中做一些复杂的逻辑处理，由其他类代理处理"></a>将一些业务逻辑处理封装到其他类中，由ViewController去调用这些类。即：不要在ViewController中做一些复杂的逻辑处理，由其他类代理处理</h5><h4 id="比如："><a href="#比如：" class="headerlink" title="比如："></a>比如：</h4><ul>
<li>业务Model自己逻辑自己处理。VC只负责调用。</li>
<li>网络请求、数据处理服务创建相应Manager类处理。</li>
<li>复杂的View结构通过添加子ViewController实现。</li>
<li>使用KVO。比如你创建一个列表，数据需要通过网络请求刷新[webservice fetchNewData],通过KVO可以实现多个网络请求的自动刷新。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h5 id="这些只是可供大家参考的方法，目的是为了编写方便维护的、可读性高的代码。"><a href="#这些只是可供大家参考的方法，目的是为了编写方便维护的、可读性高的代码。" class="headerlink" title="这些只是可供大家参考的方法，目的是为了编写方便维护的、可读性高的代码。"></a>这些只是可供大家参考的方法，目的是为了编写方便维护的、可读性高的代码。</h5><h5 id="写于2015-01-19"><a href="#写于2015-01-19" class="headerlink" title="写于2015-01-19"></a>写于2015-01-19</h5>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jackthenoob.github.io/2019/05/20/iOS内存管理-ARC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="垂杨小梳雨">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lyddwn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/20/iOS内存管理-ARC/" itemprop="url">iOS内存管理-ARC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-20T18:25:19+08:00">
                2019-05-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是ARC"><a href="#什么是ARC" class="headerlink" title="什么是ARC"></a>什么是ARC</h2><p>ARC（Automatic Reference Counting）是在iOS5.0推出的新功能，是新LLVM 3.0编译器的特性。简单地说，就是代码中自动加入了retain/release，原先需要手动添加的用来处理内存管理的引用计数的代码可以自动地由编译器完成了。</p>
<p>ARC是编译器特性，而不是iOS运行时特性（除了weak指针系统,它会在所指向的内存释放的时候自动将自身置为nil，后面文章会专门说下），它也不是其它语言中的垃圾收集器。因此ARC和手动内存管理性能是一样的，有些时候还能更加快速，因为编译器还可以执行某些优化。</p>
<h2 id="ARC使用规则"><a href="#ARC使用规则" class="headerlink" title="ARC使用规则"></a>ARC使用规则</h2><p>ARC下，指针保持对象的生命。只有还有一个变量（strong）指向对象，对象就会保持在内存中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *firstName = self.textField.text;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/20/iOS内存管理-ARC/a001.png" alt></p>
<p>上图中，firstName现在指向NSString对象，这时这个对象（textField的内容字符串）将被hold住。比如用字符串@“Ray”作为例子（字符串的retainCount规则和普通的对象不一样，这边就把它当作一个普通的对象来看吧…），这个时候firstName持有了@”Ray”。retainCount ＝ 1。</p>
<p><img src="/2019/05/20/iOS内存管理-ARC/a002.png" alt></p>
<p>一个对象可以有多个拥有者,如上图：retainCount=2。</p>
<p>当用户修改了文本框的text后，此时text属性会指向新的对象。原来的对象仍有firstName指向</p>
<p><img src="/2019/05/20/iOS内存管理-ARC/a003.png" alt></p>
<p>而当firstName指向另外一个对象时，或者超出作用域范围时，@“Ray”这个字符串对象不在有任何所有者，retainCount ＝ 0，将会被释放。</p>
<p><img src="/2019/05/20/iOS内存管理-ARC/a004.png" alt></p>
<p>WARNING:上面我们所说的firstName、text这些指针都是“Strong”，能够保持对象的生命。默认的实例、本地变量都是Strong类型。</p>
<p>这边再提下刚刚我们说到的ARC的一个基本规则。</p>
<font color="#e4393c" size="3">只要某个对象被任一strong指针指向，那么它将不会被销毁。如果对象没有被任何strong指针指向，那么就将被销毁。</font>

<h3 id="weak指针"><a href="#weak指针" class="headerlink" title="weak指针"></a>weak指针</h3><p>weak变量仍然指向一个对象，但不是对象的拥有者：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__weak NSString *weakName = self.textField.text;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/20/iOS内存管理-ARC/a005.png" alt></p>
<p>当self.textField.text指向其他对象， 此时weakName会自动变成nil，称为“zeroing” weak pointer： </p>
<p><img src="/2019/05/20/iOS内存管理-ARC/a006.png" alt></p>
<p>它解决了MRC下assign指针指向已经释放的对象（我们常说的野指针），对它发送消息Crash的问题。</p>
<p><img src="/2019/05/20/iOS内存管理-ARC/a007.png" alt></p>
<hr>
<p>ARC可以节省代码（MRC下属性赋值），我们不需要关心什么时候retain、release。但是不意味着我们不需要考虑内存管理</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id obj = [array objectAtIndex:0];</span><br><span class="line">[array removeObjectAtIndex:0];</span><br><span class="line">NSLog(@<span class="string">"%@"</span>, obj);</span><br></pre></td></tr></table></figure>
<p>上面代码在MRC下是错误的。从Array中移除一个对象会使对象不可用，对象不属于Array时会立即被释放。随后NSLog()打印该对象就会导致应用崩溃。 </p>
<p>而在ARC中这段代码是完全合法的。因为obj变量是一个strong指针，它成为了对象的拥有者，从Array中移除该对象也不会导致对象被释放。 </p>
<p>内存管理其他注意点：</p>
<ul>
<li>通知、KVO需要释放。（可在dealloc中）</li>
<li>NSTimer（rep=true）会强引用传入的target。</li>
<li>Block</li>
</ul>
<p>ARC限制： 用于NSObject对象。</p>
<p>如果应用使用了Core Foundation或malloc()/free()，此时需要你来管理内存（这个我们下面再说）</p>
<hr>
<h2 id="Xcode的ARC自动迁移"><a href="#Xcode的ARC自动迁移" class="headerlink" title="Xcode的ARC自动迁移"></a>Xcode的ARC自动迁移</h2><p>要启用一个项目的ARC，你有以下几种选择：</p>
<ul>
<li>Xcode带了一个自动转换工具，可以迁移源代码至ARC</li>
<li>你可以手动转换源文件</li>
<li>你可以在Xcode中禁用某些文件使用ARC，这点对于第三方库非常有用。</li>
</ul>
<p>这边说下测试提出的需要将IBOutlet改为Strong的事情。</p>
<p>在ARC中，所有<em>outlet</em>属性都推荐使用weak，这些view对象已经属于View Controller的view hierarchy，不需要再次定义为strong（ARC中效果等同于retain）。唯一应该使用strong的outlet是File’s Owner，连接到nib的顶层对象。 </p>
<hr>
<h2 id="ARC中dealloc与autorelease"><a href="#ARC中dealloc与autorelease" class="headerlink" title="ARC中dealloc与autorelease"></a>ARC中dealloc与autorelease</h2><h3 id="dealloc"><a href="#dealloc" class="headerlink" title="dealloc"></a>dealloc</h3><p>在ARC下我们一般不需要写dealloc函数。因为我们不需要调用[super dealloc],也不需要release属性。而Strong属性出了作用域（这个class）会被置为nil，对象相应的会被释放销毁。（内存从创建到如何销毁下面文章会写到）</p>
<p>而dealloc函数还是会被调用执行的，在这个函数里面，我们有时候需要释放CoreFoundation对象、remove observer、remove KVO以及一些其他资源（ AudioServicesDisposeSystemSoundID(soundID); ）</p>
<p>这里要注意的是：</p>
<p>不要在dealloc函数中释放Timer。NSTimer会保持一份target强引用，导致这个Class永远不会被释放。所以需要在对象Class销毁前做处理</p>
<h5 id="在Github上有个开源项目MSWeakTimer。"><a href="#在Github上有个开源项目MSWeakTimer。" class="headerlink" title="在Github上有个开源项目MSWeakTimer。"></a>在Github上有个开源项目<a href="https://github.com/mindsnacks/MSWeakTimer" target="_blank" rel="noopener">MSWeakTimer</a>。</h5><h3 id="autoreleasepool"><a href="#autoreleasepool" class="headerlink" title="autoreleasepool"></a>autoreleasepool</h3><p>ARC仍然保留了AutoreleasePool，但是采用了新的Block语法，于是我们的main函数会如下修改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];</span><br><span class="line">int retVal = UIApplicationMain(argc, argv, nil,</span><br><span class="line">NSStringFromClass([AppDelegate class]));</span><br><span class="line">[pool release];</span><br><span class="line"><span class="built_in">return</span> retVal;</span><br></pre></td></tr></table></figure>
<p>修改为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">	int retVal = UIApplicationMain(argc, argv, nil,</span><br><span class="line">	NSStringFromClass([AppDelegate class]));</span><br><span class="line">	<span class="built_in">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Core-Foundation的内存管理-Toll-Free-Bridge"><a href="#Core-Foundation的内存管理-Toll-Free-Bridge" class="headerlink" title="Core Foundation的内存管理-Toll-Free Bridge"></a>Core Foundation的内存管理-Toll-Free Bridge</h2><p>在ARC下，objective-c对象与Core Foundation对象相互转换时，需要用到briage cast。</p>
<p>举个栗子：NSString和CFStringRef就可以同等对待，在任何地方都可以互换使用，背后的设计就是toll-free bridging。</p>
<p>在ARC之前，我们时这么处理的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFStringRef s1 = (CFStringRef) [[NSString alloc] initWithFormat:@<span class="string">"Hello, %@!"</span>, name];</span><br></pre></td></tr></table></figure>
<p>当然，alloc分配了NSString对象，你需要在使用完之后进行释放，注意是释放转换后的CFStringRef对象：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFRelease(s1);</span><br></pre></td></tr></table></figure>
<p>反过来，从Core Foundation到Objective-C的方向也类似：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CFStringRef s2 = CFStringCreateWithCString(kCFAllocatorDefault, bytes, kCFStringEncodingMacRoman);</span><br><span class="line">NSString *s3 = (NSString *)s2;</span><br><span class="line">// release the object when you<span class="string">'re done</span></span><br><span class="line"><span class="string">[s3 release];</span></span><br></pre></td></tr></table></figure>
<p>在ARC下，情况变得不一样！以下代码在手动内存管理中是完全合法的，但在ARC中却存在问题：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)escape:(NSString *)text</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">return</span> [(NSString *)CFURLCreateStringByAddingPercentEscapes(</span><br><span class="line">							NULL,</span><br><span class="line">							(CFStringRef)text,</span><br><span class="line">							NULL,</span><br><span class="line">							(CFStringRef)@<span class="string">"!*'();:@&amp;=+$,/?%#[]"</span>, // 这里不需要bridging casts，因为这是一个常量，不需要释放！</span><br><span class="line"> 							CFStringConvertNSStringEncodingToEncoding(NSUTF8StringEncoding)) autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="#e4393c" size="4">在ARC下编译器必须知道由谁来负责释放转换后的对象</font>

<p>如果你把一个NSObject当作Core Foundation对象来使用，则ARC将不再负责释放该对象。但你必须明确地告诉ARC你的这个意图，编译器没办法自己做主。</p>
<p>同样如果你创建一个Core Foundation对象并把它转换为NSObject对象，你也必须告诉ARC占据对象的所有权，并在适当的时候释放该对象。这就是所谓的bridging casts。</p>
<p>上面代码中，<br>CFURLCreateStringByAddingPercentEscapes()函数的参数需要两个CFStringRef对象，其中常量NSString可以直接转换，因为不需要进行对象释放；但是 text 参数不一样，它是传递进来的一个NSString对象。而函数参数和局部变量一样，都是strong指针，这种对象在函数入口处会被retain，并且对象会持续存在直到指针被销毁（这里也就是函数返回时）。</p>
<p>对于text参数，我们希望ARC保持这个变量的所有权，同时又希望临时将它当作CFStringRef对象来使用。这种情况下可以使用__bridge说明符，它告诉ARC不要更改对象的所有权，按普通规则释放该对象即可。</p>
<p>多数情况下，Objective-C对象和Core Foundation对象之间互相转换时，我们都应该使用__bridge。</p>
<p>但是~它lei来了<br>但是有时候我们确实需要给予ARC某个对象的所有权，或者解除ARC对某个对象的所有权。这种情况下我们就需要使用另外两种</p>
<p>bridging casts：</p>
<ul>
<li>__bridge_transfer：给予ARC所有权</li>
<li>__bridge_retained：解除ARC所有权</li>
</ul>
<p>因为 CFURLCreateStringByAddingPercentEscapes() 函数创建了一个新的CFStringRef对象,而我们要的是NSString对象，因此我们要强制转换。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CFStringRef result = CFURLCreateStringByAddingPercentEscapes(. . .);</span><br><span class="line">NSString *s = (NSString *)result;</span><br><span class="line"><span class="built_in">return</span> s;</span><br></pre></td></tr></table></figure>
<p>当我们不需要强制转换为NSObject对象时，我们只需要调用CFRelease方法即可</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">do</span> something with the result </span><br><span class="line">CGRelease(result)</span><br></pre></td></tr></table></figure>
<font color="#e4393c" size="4">ARC只能作业于Objective-c对象。那么问题来了 既然我们创建了一个Core Foundation对象 谁来负责释放它？</font>

<p>这里需要我们使用 <font color="#e4393c" size="4"> __bridge_transfer </font></p>
<p><font color="#e4393c" size="3"> __bridge_transfer </font>会告诉ARC：”Hi，ARC同学，好久不见。我这里有个货是一个CFStringRef对象，但是有人把它搞成了NSString对象了，我希望你来管(销毁)它，我这里就撒手不管了(调用CFRelease())”。 </p>
<p>如果我们使用 __bridge，就会导致内存泄漏。ARC并不知道自己应该在使用完对象之后释放该对象，也没有人调用CFRelease()。结果这个对象就会永远保留在内存中。因此选择正确的 bridge 说明符是至关重要的。</p>
<p>为了代码更加可读和容易理解，iOS还提供了一个辅助函数：CFBridgingRelease()。函数所做事情和 __bridge_transfer 强制转换完全一样，但更加简洁和清晰。CFBridgingRelease() 函数定义为内联函数，因此不会导致额外的开销。函数之所以命名为CFBridgingRelease()，是因为一般你会在需要使用CFRelease()释放对象的地方，调用CFBridgingRelease()来传递对象的所有权。</p>
<p>清晰明了</p>
<p>因此最后我们的代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> - (NSString *)escape:(NSString *)text</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">return</span> CFBridgingRelease(CFURLCreateStringByAddingPercentEscapes(</span><br><span class="line">						NULL,</span><br><span class="line">						(__bridge CFStringRef)text,</span><br><span class="line">						NULL,</span><br><span class="line">						CFSTR(<span class="string">"!*'();:@&amp;=+$,/?%#[]"</span>),</span><br><span class="line">						CFStringConvertNSStringEncodingToEncoding(NSUTF8StringEncoding)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个常见的需要CFBridgingRelease的情况是AddressBook framework：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)firstName</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">return</span> CFBridgingRelease(ABRecordCopyCompositeName(...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结:只要你调用命名为Create, Copy, Retain的Core Foundation函数，你都需要使用 CFBridgingRelease() 安全地将值传递给ARC。 </p>
<p><font color="#e4393c" size="4"> <strong>bridge_retained </strong></font> 则正好相反，假设你有一个NSString对象，并且要将它传递给某个Core Foundation API，该函数希望接收这个string对象的所有权。这时候你就不希望ARC也去释放该对象，否则就会对同一对象释放两次，而且必将导致应用崩溃！换句话说，使用 bridge_retained 将对象的所有权给予 Core Foundation，而ARC不再负责释放该对象。</p>
<p>如下面例子所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSString *s1 = [[NSString alloc] initWithFormat:@<span class="string">"Hello, %@!"</span>, name];</span><br><span class="line">CFStringRef s2 = (__bridge_retained CFStringRef)s1;</span><br><span class="line">// <span class="keyword">do</span> something with s2</span><br><span class="line">// . . .</span><br><span class="line">CFRelease(s2);</span><br></pre></td></tr></table></figure>
<p>一旦 (<strong>bridge_retained CFStringRef) 转换完成，ARC就不再负责释放该对象。如果你在这里使用 </strong>bridge，应用就很可能会崩溃。ARC可能在Core Foundation正在使用该对象时，释放掉它。</p>
<p>同样<font color="#e4393c" size="4"> __bridge_retained </font> 也有一个辅助函数：CFBridgingRetain()。从名字就可以看出，这个函数会让Core Foundation执行retain，实际如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CFStringRef s2 = CFBridgingRetain(s1);</span><br><span class="line">// . . .</span><br><span class="line">CFRelease(s2);</span><br></pre></td></tr></table></figure>
<p>现在你应该明白了，上面例子的CFRelease()是和CFBridgingRetain()对应的。 </p>
<p>总结：</p>
<ul>
<li>使用<font color="#e4393c" size="4">  CFBridgingRelease()</font>，从Core Foundation传递所有权给Objective-C；</li>
<li>使用<font color="#e4393c" size="4"> CFBridgingRetain() </font>，从Objective-C传递所有权给Core Foundation；</li>
<li>使用__brideg，表示临时使用某种类型，不改变对象的所有权。</li>
</ul>
<hr>
<h2 id="Delegate和Weak-Property"><a href="#Delegate和Weak-Property" class="headerlink" title="Delegate和Weak Property"></a>Delegate和Weak Property</h2><p>使用Delegate模式时，通常我们会使用weak property来引用delegate，这样可以避免所有权回环。</p>
<p><img src="/2019/05/20/iOS内存管理-ARC/a007.png" alt></p>
<p>retain循环引用的概念，两个对象互相retain时，会导致两个对象都无法被释放，这也是内存泄漏的常见原因之一。因此需要你使用weak指针来避免。</p>
<p>还有Block使用不当导致的循环引用，下面会提到</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DetailViewController *controller = [[DetailViewController alloc] initWithNibName:@<span class="string">"DetailViewController"</span> bundle:nil];</span><br><span class="line">controller.delegate = self;</span><br><span class="line">[self presentViewController:controller animated:YES completion:nil];</span><br></pre></td></tr></table></figure>
<p>在上面代码中，MainViewController创建一个DetailViewController，并调用presentViewController将view呈现出来，从而拥有了一个strong指针指向创建的DetailViewController对象。反过来，DetailViewController也通过delegate拥有了一个指向MainViewController的weak指针.</p>
<p>当MainViewController调用dismissViewControllerAnimated:时，就会自动失去DetailViewController的strong引用，这时候DetailViewController对象就会被自动释放。</p>
<p>如果这两个指针都是strong类型，就会出现所有权回环。导致对象无法在适当的时候被释放。 </p>
<h3 id="unsafe-unretained"><a href="#unsafe-unretained" class="headerlink" title="unsafe_unretained"></a>unsafe_unretained</h3><p>除了strong和weak，还有另外一个unsafe_unretained关键字，一般你不会使用到它。声明为unsafe_unretained的变量或property，编译器不会为其自动添加retain和release。unsafe_unretained只是为了兼容iOS 4，因为iOS 4没有weak pointer system。 </p>
<p>这里大家做个了解就可以</p>
<hr>
<h2 id="ARC和Block"><a href="#ARC和Block" class="headerlink" title="ARC和Block"></a>ARC和Block</h2><h5 id="略"><a href="#略" class="headerlink" title="略"></a>略</h5><hr>
<h2 id="ARC和Singleton"><a href="#ARC和Singleton" class="headerlink" title="ARC和Singleton"></a>ARC和Singleton</h2><h3 id="MRC"><a href="#MRC" class="headerlink" title="MRC"></a>MRC</h3><p>如果你的应用使用了Singleton，你的实现可能包含以下方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> + (id)allocWithZone:(NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">return</span> [[self sharedInstance] retain];</span><br><span class="line">&#125;</span><br><span class="line">- (id)copyWithZone:(NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">return</span> self;</span><br><span class="line">&#125;</span><br><span class="line">- (id)retain</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">return</span> self;</span><br><span class="line">&#125;</span><br><span class="line">- (NSUInteger)retainCount</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">return</span> NSUIntegerMax;</span><br><span class="line">&#125;</span><br><span class="line">- (oneway void)release</span><br><span class="line">&#123;</span><br><span class="line">     // empty</span><br><span class="line">&#125;</span><br><span class="line">- (id)autorelease</span><br><span class="line">&#123; </span><br><span class="line">     <span class="built_in">return</span> self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是典型的singleton实现模式，retain和release都覆盖掉，使其不能创建多个实例对象。毕竟Singleton就是为了只创建一个全局对象。 </p>
<h3 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#import "AppManager.h"</span></span><br><span class="line"></span><br><span class="line">static AppManager   *_appManager = nil;</span><br><span class="line"></span><br><span class="line">@implementation AppManager</span><br><span class="line"></span><br><span class="line">+ (instancetype)sharedInstance &#123;</span><br><span class="line">    static dispatch_once_t  onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        _appManager = [[super allocWithZone:NULL] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">return</span> _appManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)allocWithZone:(struct _NSZone *)zone &#123;</span><br><span class="line">    <span class="built_in">return</span> [self sharedInstance];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (id)copyWithZone:(struct _NSZone *)zone OBJC_ARC_UNAVAILABLE;</span><br><span class="line">+ (id)mutableCopyWithZone:(struct _NSZone *)zone OBJC_ARC_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p>在ARC中，所有指针变量默认都是nil，在ARC之前，只有实例变量才会默认为nil。如果你编写下面代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> - (void)myMethod</span><br><span class="line">&#123;</span><br><span class="line">	int someNumber;</span><br><span class="line">	NSLog(@<span class="string">"Number: %d"</span>, someNumber);</span><br><span class="line">	NSString *someString;</span><br><span class="line">	NSLog(@<span class="string">"String: %p"</span>, someString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器会：”Variable is uninitialized when used here”，而输出则是随机数值：</p>
<p>Woot[2186:207] Number: 67</p>
<p>Woot[2186:207] String: 0x4babb5</p>
<p>但在ARC中，输出则如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Artists[2227:207] Number: 10120117</span><br><span class="line">Artists[2227:207] String: 0x0</span><br></pre></td></tr></table></figure>
<p>int仍然是随机值（这样使用编译器也会警告），但someString的初始值已经是nil，这样的优点是指针永远不会指向非法对象。 </p>
<p>autorelease对象可能会比你想象中存活更长时间，在iOS中，每次UI事件（点击按钮等）都会清空一次 autorelease pool（具体应该与RunLoop相关，后面文章会说到），但是如果你的事件处理器进行了大量操作，例如循环地创建许多对象，最好是使用你自己的 autorelease pool，避免应用面临内存不足：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; 10000; i++)</span><br><span class="line">&#123;</span><br><span class="line">     @autoreleasepool</span><br><span class="line">     &#123;</span><br><span class="line">          NSString *s = [NSString stringWithFormat:. . .];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><h5 id="此篇整理于2013年，如有错误，敬请斧正。"><a href="#此篇整理于2013年，如有错误，敬请斧正。" class="headerlink" title="此篇整理于2013年，如有错误，敬请斧正。"></a>此篇整理于2013年，如有错误，敬请斧正。</h5>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jackthenoob.github.io/2019/05/20/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="垂杨小梳雨">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lyddwn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/20/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-20T11:22:35+08:00">
                2019-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>欢迎来到我的<a href="https://jackthenoob.github.io">技术博客</a>!<br>下面准备把之前工作中的积累都慢慢转到Github上来。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">垂杨小梳雨</p>
              <p class="site-description motion-element" itemprop="description">None</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">垂杨小梳雨</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
